# 三、TCP

## 1.TCP 的三次握手

**第一次握手**

客户端向服务器端发送请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端会进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求后，如果同意链接，则会发送一个应答，包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端接收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发送完这个报文后便进入 ESTABLISHED 状态，服务端收到这个应答之后，也进入 ESTABLISHED 状态，此时链接建立成功。

## 2.为什么要进行三次握手，而不是两次

1. 为了确保双方的接受能力和发送能力都正常。
2. 如果两次握手则会发生下列异常：如果客服端放出链接请求，但是因为连接请求报文丢失而未收到确认，于是客户端再穿一次链接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端一共发出了两个请求连接的报文，其中一个丢失，第二个到达了服务端，但是假设第一个只是在某个网络节点长时间滞留了，延误到连接释放后才到达服务端，如果不采用三次握手，那么服务端就会认为是一个新的连接从而建立连接，浪费了资源。

## 3.TCP 四次挥手

**第一次挥手**

若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。

**第二次挥手**

服务端收到连接释放请求后，会告诉应用层要释放 TCP 连接。然后会发送 ACK 包，并进入 CLOSE_WANT 状态，此时表明客户端到服务端的链接已经释放，不再接收客户端发的数据了。但是因为 TCP 是双向的，所以服务端人就可以发送数据给客户端。

**第三次挥手**

服务端此时还没有发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端进入 LAST_ACK 状态。

**第四次挥手**

客户端收到释放请求后，向服务器发送确认应答，此时客户端进入 TIME_WAIT 状态。该状态会持续 2MSL 时间，如果该时间段内没有服务的重发请求的花，就进入 CLOSED 状态。当服务端收到确认应答后，已进入 CLOSED 状态。

## 4.为什么要进行四次挥手

应为当服务端收到客户端 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文时用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，肯可能斌不会立刻关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端"你的 FIN 报文我收到了"。只有等到我服务端所有报文发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要第四次挥手。

## 5.TCP 粘包

**简介**

默认情况下，TCP 连接会启用延迟传送算法（Nagle），再数据发送前先缓存他们，如果短时间有多个数据发送，会缓冲到一起做一次发送，这样可以减少 IO 消耗，提升性能。如果是传输文件的花，那么根本不需要处理粘包，来一个包拼接一个包即可。但是如果是多条消息，或者别的用途的数据就需要处理粘包。

**解决方案**

- 多次发送之前间隔一个等待时间
- 关闭 Nagle 算法
- 进行封包拆包
