# 一、HTTP

## 1.GET 和 POST 请求的区别

### 基本区别

| 请求         | GET                     | POST                           |
| ------------ | ----------------------- | ------------------------------ |
| **应用场景** | 幂等请求[1]             | 非幂等请求                     |
| **是否缓存** | 缓存                    | 一般不缓存                     |
| **传参方式** | 查询字符串              | 请求体                         |
| **安全性**   | 相对不安全              | 相对安全                       |
| **请求长度** | 浏览器对 url 长度有限制 | 可借助请求体传参，相对限制较少 |
| **参数类型** | 只允许 ASCII 字符       | 没有限制                       |

### 什么是幂等性

在计算机科学中，**幂等性**（Idempotence）是指一个操作可以重复执行多次，而产生的结果与第一次执行的结果相同。在 HTTP 方法中，幂等性有特定的含义：

- **GET**：GET 请求是幂等的，无论执行多少次，结果都是相同的。例如，重复访问一个网页，无论访问多少次，网页的内容不会因为访问次数的增加而变化。
- **PUT**：PUT 请求也是幂等的。无论执行多少次，结果都是相同的，因为它用于更新资源。例如，重复提交一个 PUT 请求来更新某个资源，最终结果是相同的资源状态。

- **DELETE**：DELETE 请求也是幂等的。无论执行多少次，结果都是相同的资源被删除。如果资源已经被删除，再执行 DELETE 请求不会产生不同的结果。

- **POST**：POST 请求通常不是幂等的，因为它会创建资源或导致服务器状态的变化。例如，重复提交一个表单可能会导致创建多个相同的资源记录。

幂等性的重要性在于它能保证系统的可靠性和可恢复性。比如在网络不稳定的情况下，如果客户端没有收到服务器的响应，客户端可以安全地重试幂等的请求而不会产生副作用。

## 2.POST 和 PUT 请求的区别

### 基本区别

POST 和 PUT 都是用于向服务器发送数据的 HTTP 请求方法，但它们有不同的用途和行为。主要区别如下：

1. **用途**：

   - **POST**：通常用于创建资源。每次发送相同的 POST 请求可能会在服务器上创建多个资源。例如，提交一份表单来创建新用户，每次提交都会创建一个新用户。
   - **PUT**：通常用于更新资源。发送相同的 PUT 请求多次，结果是相同的，即该资源被更新为指定的状态。PUT 请求可以创建资源，如果资源在服务器上不存在的话。

2. **幂等性**：

   - **POST**：非幂等的。多次执行相同的 POST 请求可能会导致多个资源被创建。
   - **PUT**：幂等的。多次执行相同的 PUT 请求不会改变结果，资源的状态会保持一致。

3. **请求的意图**：

   - **POST**：表示请求处理可能会导致资源的创建或其他的副作用。它强调动作或过程。
   - **PUT**：表示请求会创建或替换指定的资源。它强调资源的状态。

4. **请求的结构**：

   - **POST**：请求体中包含要发送的数据，通常与目标资源的 URL 无关。服务器决定资源的具体位置和标识符。
   - **PUT**：请求体中包含要发送的数据，并且请求的 URL 通常指定了资源的具体位置或标识符。客户端决定资源的位置和标识符。

5. **资源的创建和更新**：
   - **POST**：用于向服务器提交数据以创建资源。每次请求可能会产生一个新的资源。
   - **PUT**：用于向服务器发送数据以创建或更新资源。资源存在时进行更新，不存在时进行创建。

### 举例说明

- **POST** 请求示例：

  ```
  POST /users HTTP/1.1
  Host: example.com
  Content-Type: application/json

  {
    "name": "John Doe",
    "email": "john@example.com"
  }
  ```

  每次执行这个请求可能会在服务器上创建一个新用户。

- **PUT** 请求示例：

  ```
  PUT /users/123 HTTP/1.1
  Host: example.com
  Content-Type: application/json

  {
    "name": "John Doe",
    "email": "john@example.com"
  }
  ```

  这个请求会更新 ID 为 123 的用户信息。如果该用户不存在，则可能会创建一个新的用户，并赋予其 ID 为 123。

总结来说，POST 通常用于创建资源，而 PUT 通常用于更新资源。POST 非幂等，而 PUT 幂等。

## 3.为什么 POST 会发出两次请求

### 原因

在跨域资源共享 (CORS) 的情况下，浏览器为了安全性，会在发送实际的跨域请求之前发送一个预检请求 (preflight request)。这种预检请求使用 HTTP 方法 `OPTIONS`，目的是检查目标服务器是否允许这种跨域请求。具体过程如下：

1. **预检请求**：
   浏览器发送一个 `OPTIONS` 请求到目标服务器，询问服务器是否允许当前的跨域请求。预检请求包含以下头部：

   - `Access-Control-Request-Method`：实际请求使用的方法（例如 `POST`）。
   - `Access-Control-Request-Headers`：实际请求中使用的自定义头部（如果有）。
   - `Origin`：发起请求的源（域名）。

   预检请求示例：

   ```
   OPTIONS /api/resource HTTP/1.1
   Host: example.com
   Access-Control-Request-Method: POST
   Access-Control-Request-Headers: X-Custom-Header
   Origin: http://another-domain.com
   ```

2. **服务器响应预检请求**：
   服务器响应预检请求，指示是否允许实际请求。如果允许，响应头部会包含：

   - `Access-Control-Allow-Methods`：允许的方法（例如 `POST`）。
   - `Access-Control-Allow-Headers`：允许的自定义头部（例如 `X-Custom-Header`）。
   - `Access-Control-Allow-Origin`：允许的源（例如 `http://another-domain.com`）。

   预检响应示例：

   ```
   HTTP/1.1 200 OK
   Access-Control-Allow-Methods: POST
   Access-Control-Allow-Headers: X-Custom-Header
   Access-Control-Allow-Origin: http://another-domain.com
   ```

3. **实际请求**：
   如果预检请求成功，浏览器会发送实际的 `POST` 请求到服务器。

   实际请求示例：

   ```
   POST /api/resource HTTP/1.1
   Host: example.com
   Content-Type: application/json
   X-Custom-Header: custom-value
   Origin: http://another-domain.com

   { "data": "value" }
   ```

4. **服务器响应实际请求**：
   服务器处理实际请求，并返回响应。

   实际响应示例：

   ```
   HTTP/1.1 200 OK
   Content-Type: application/json

   { "result": "success" }
   ```

### 如何避免或优化预检请求

虽然预检请求是由浏览器自动处理的，但可以通过以下方法减少或优化预检请求的频率：

1. **简化请求头**：
   避免使用复杂的或自定义的请求头。仅使用浏览器默认允许的头部，如 `Content-Type` 为 `application/x-www-form-urlencoded`、`multipart/form-data`、或 `text/plain`。

2. **使用简单方法**：
   避免使用复杂的 HTTP 方法。尽量使用 `GET`、`POST`、`HEAD` 等简单方法。

3. **服务器端配置缓存预检响应**：
   在服务器端配置 `Access-Control-Max-Age` 头部，指示浏览器缓存预检响应的时间，从而减少频繁的预检请求。

   配置示例：

   ```
   Access-Control-Max-Age: 86400  // 预检响应缓存24小时
   ```

通过以上方法，可以减少预检请求的次数，提高跨域请求的性能。

## 4.常见的 HTTP 请求头和响应头

HTTP Request Header

- Accept：浏览器能够处理的内容类型
- Accept-Charset：浏览器能够显示的字符集
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookies：当前页面设置的任何 Cookies
- Host：发出请求的页面所在域
- Referer：发出请求的页面的 URL
- User-Agent：浏览器的用户代理字符串

HTTP Responses Header

- Date：表示消息发送的时间
- server：服务器名称
- Connection：浏览器与服务器之间的连接类型
- Cache-Control：空置 HTTP 缓存
- Content-Type：表示文档的 MIME 类型

## 5.常见的 Content-Type

- application/x-www-form-urlencoded：浏览器原生 form 表单，这种方式提交的数据放在`body`中，数据按照`key1=val1&key2=val2`的方式进行编码，key 和 val 都会进行`URL转码`
- multipart/form-data：通常用在表单上传文件的时候使用
- application/json：JSON 字符串格式
- text/xml：主要用来提交 XML 数据

## 6.HTTP 状态码 304

产生的原理：

客户端在请求一个文件的时候，发现自己缓存的文件有 `Last Modified`，那么在请求中会包含`If Modified Since`，这个时间是缓存文件的`Last Modified`。如果请求中包含`If Modified Since`，就说明已经有缓存在客户端，服务端只需要判断修改时间就可以返回 304 还是 200 了

产生的不良影响：

- 网站快照停止
- 收录减少
- 权重下降

## 7.常见的 HTTP 请求方法

- GET：获取数据
- POST：发送数据给服务器，一般会造成服务器资源的新增
- PUT：用于全量修改目标资源
- PATCH：用于对资源的部分修改
- DELETE：用于删除指定资源
- HEAD：获取报文首部，但是不返回报文主体内容，例如下载大文件前用于先获取文件大小，再来决定是否下载文件。
- OPTIONS：浏览器自动执行的，用来询问支持的请求方法，判断跨域请求、预检请求、目标是否安全

## 8.`HTTP1.0`和`HTTP1.1 `之间的区别

| 协议     | HTTP1.0                                | HTTP1.1                                                      |
| -------- | -------------------------------------- | ------------------------------------------------------------ |
| 链接模式 | 短链接，每次请求都需要重新建立         | 默认使用长连接                                               |
| 请求资源 | 一次性获取所有响应，不支持断点续传     | 请求头加入 range 头域，允许只请求一部分资源，返回码是 206    |
| 缓存     | If-Modified-Since Expires 控制缓存策略 | 增加 Unmodified-Since If-Match if-None-Match 来控制缓存策略  |
| host     | 认为每台服务器都只绑定一个 IP 地址     | 增加 host 字段，这样九可以将请求发送到同一服务器上的不同网站 |
| 请求方法 | GET、POST                              | 怎加了 PUT、HEAD、OPTIONS                                    |

## 9.`HTTP1.1 `和 `HTTP2.0`的区别

| 协议       | HTTP1.1                                  | HTTP2.0                                                          |
| ---------- | ---------------------------------------- | ---------------------------------------------------------------- |
| 二进制协议 | 报文头信息必须为文本，数据体可以为二进制 | 头信息和提信息都为二进制，同意称为“帧”                           |
| 多路复用   | 只能复用 TCP，但是得排队请求             | 复用 TCP 的同时，可以不按顺序的同时发送多个请求                  |
| 数据流     | -                                        | 每个数据流都有独一无二的编号，数据包发送时用来区分他属于哪个请求 |
| 头信息压缩 | -                                        | 头信息可以压缩，获知使用索引方式                                 |
| 服务器推送 | -                                        | 可以主动推送静态资源                                             |

## 10.队头堵塞

简介

HTTP 规定报文必须是“一发一收”，这就形成了先进先出的“串行"队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被优先处理。如果队首的请求太慢，那么队列后面的请求就不得不一起等待，结果就是他的请求承担了不应承担的事件成本，造成队头堵塞的现象。

解决方案

- 并发链接：对于一个域名允许分配多个长连接，那么相当于怎加了任务队列，不至于一个对的任务阻塞其他所有任务。
- 域名分片：将域名分出很多二级域名，他们呢都指向同样一台服务器，并能够让并发的链接变多，解决了队头堵塞问题。

## 11.`HTTP`和`HTTPS`协议的区别

- HTTPS 需要 CA 证书，费用较贵。HTTP 则不需要。
- HTTP 是明文传输，HTTPS 具有 SSL 加密
- 端口号不同，HTTP 协议的端口是 80，HTTPS 是 443

## 12.输入 URL 到页面完成加载的过程

1. **解析 URL**：分析所需要使用的传输协议和请求资源的路径，URL 不合法则转发给搜索引擎，合法则检查是否有非法字符然后进行转义。
2. **缓存判断**：浏览器判断请求的资源是否存在缓存，如果存在且未失效则直接使用，否则向服务器发送请求。
3. **DNS 解析**：首先判断本地是否存在该域名 IP 地址的缓存，没有则请求本地 DNS 服务器=》根域名服务器=》顶级域名服务器=》权威域名服务器
4. **TCP 三次握手**：确认客户端与服务端接收与发送的能力。
5. **发送 HTTP 请求**：服务器处理请求，返回 HTTP 报文
6. **页面渲染**：并行生成 DOM 树和 CSS 树，再通过这两个树构建渲染树，再计算元素的大小和位置，最后还是绘制。
7. **TCP 四次挥手**：断开链接的过程

## 13.HTTP 请求和响应报文的结构

请求体

- 请求行：请求方法、URL、HTTP 协议版本号，例如`GET index/html HTTP1.1`
- 请求头：关键字+值的键值对，例如 `accept:application/json, text/plain`
- 空行
- 请求体：例如 post 携带的请求数据

响应体

- 响应行：网路协议版本、状态码、状态码原因短语。例如： `HTTP/1.1 200 OK`
- 响应头：同上
- 空行
- 响应体：服务器返回的数据

## 14.URL 的组成部分

- 协议：例如 HTTP、FTP
- 域名：`www.baidu.com`
- 端口：如果省略则使用默认端口，HTTP：80，HTTPS：443
- 虚拟目录：从域名的第一个”/“开始到最后一个”/“结束
- 文件名：如果省略则使用默认文件名
- 参数：例如`username=123&password=123`
- 锚部分：#后面的部分

例如：`www.aspxfans.com:8080/news/index?ID=246188&name=123#name`

## 15.强缓存与协商缓存

强缓存

- 简介：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台中可以看到 200 返回码，size 显示 from disk cache 或者 from memory cache（灰色表示缓存）
- 相关请求头：Expires、Cache-Control

协商缓存

- 简介：向服务器发送请求，服务器根据请求头的一些参数判断是否命中协商缓存，如果命中这返回 304 状态码，并且带上新的响应头通知浏览器读取缓存
- 相关请求头：Etag、If-None-Match、Last-Modified、If-Modified-Since

## 16.HTTP 的 keep-alive 的作用

- 开启状态：HTTP1.0 默认关闭，需要手动开启，HTTP1.1 默认开启
- 作用：使客户端到服务端的链接持续有效（长连接，用于复用 TCP 链接），当出现对服务器的后续请求时，keep-alive 功能可以避免重新建立链接
- 使用方法：请求头中添加`Connection: keep-alive`
- 优点：
  - 减少 CPU 和内存的占用（应为打开的连接数变少，复用了链接）
  - 减少了后续请求的延迟（无需再次握手）
- 缺点：本可以释放的资源被占用，有的请求已经结束了，但是还在链接。
- 解决方法：服务器设置过期事件和请求次数，超过事件或者次数直接断开链接。

```http
HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache
```

## 17.常见的 HTTP 状态码

| 类别 | 原因                          | 描述                     |
| ---- | ----------------------------- | ------------------------ |
| 1xx  | Informational 信息性状态码    | 请求正在处理             |
| 2xx  | Success 成功状态码            | 请求正常处理完毕         |
| 3xx  | Redirection 重定向状态码      | 需要进行附加操作完成请求 |
| 4xx  | Client Error 客户端错误状态码 | 服务器无法处理请求       |
| 5xx  | Server Error 服务器错误状态码 | 服务器处理请求出错       |

**2xx**

- 200 OK：表示从客户端发来的请求在服务端被正确处理
- 201 Created：请求已被实现，而且有一个新的资源已经依据请求的需要而建立。
- 202 Accepted：请求服务器已经接受，但是尚未处理，不保证完成请求，一般用于异步情况，防止 HTTP 一直被占用。
- 204 Not Content：请求成功，但响应报文不含实体的主体信息。
- 205 Rest Content：同 204，但是要求请求方重置请求。
- 206 Partial Content：表示服务器已经成功处理了部分 GET 请求，响应头中会包含获取的内容范围，一般用于分段下载。

**3xx**

- 301 Moved Permanently：永久性重定向，表示资源已经被分配了新的 URL。
- 302 Found：临时性重定向，表示资源被临时分配了新的 URL。
- 303 See Other：表示资源存在着另一个 URL，应该使用 GET 方法获取。
- 304 Not Modified：自从上次请求后，请求的网页内容未修改，服务器响应时，不会返回网页内容（协商缓存）
- 307 Temporary Redirect：同 302 ，但是希望客户端保持请求方法不变向新的地址请求。

**4xx**

- 400 Bad Request：请求报文存在语法错误，例如传参格式不正确。
- 401 Unauthorized： 无权限
- 403 Forbidden：对请求的资源被服务器拒绝
- 403 Not Found：表示服务器上没有找到请求的资源。
- 408 Request Timeout：客户端请求超时
- 409 Confict：请求的资源可能引发冲突

**5xx**

- 500 Internal Sever Error：表示服务器在执行请求时发生了错误。
- 501 Not Implemented：表示服务器不支持当前请求所需要的某个功能。
- 503 Service Unavailable：服务器处于超负载或者停机维护状态，无法处理请求。

## 18.同样时重定向 302 和 303、307 的区别

302 是 http1.0 的协议状态码，在 http1.1 版本的时候细化出 303 和 307。303 会把 POST 方法改为 GET 方法重定向请求，307 则是直接保持原样重定向请求

## 19.304 的过程

1. 浏览器请求资源时首先命中资源的 Expires 和 Cache-Control 强缓存头，Expies 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control：max-age 指定最大神明周期。如果成功状态码仍然返回 200，但是不会去请求数据，在浏览器中能明显看到 from cache 字样。
2. 强缓存头失效，进入协商缓存阶段，首先验证 ETag，ETag 可以保证每一个资源时唯一的，资源变化会导致 ETag 变化。服务器根据客户端上送来的 If-None-Match 值来判断是否命中缓存。
3. 协商缓存 Last-Modify/If-Modify-Since 阶段，客户端第一次请求资源时，服务器返回的 header 中会加上 Last-Modify，Last-Modify 时一个时间标志该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之间的 Last-Modify。服务器收到 If-Modify-Since 后，根据时间判断是否命中缓存。命中则返回 304

## 20.DNS 协议

**概念**

DNS 是域名系统的缩写，提供的是一种主机名到 IP 地址的转换服务。他是一个有分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不是记住能够被机器直接读取的 IP 数字串。

**作用**

将域名解析为 IP 地址，客户端向 DNS 服务器发送域名查询服务，DNS 服务器告知客户端 Web 服务器的 IP 地址。

**查询过程**

1. 在浏览器的缓存中查找对应的 IP 地址 =》
2. 将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查找 =》
3. 向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存 =》
4. 向权威域名服务器发送请求，域名服务器返回对应的结果 =》
5. 本地 DNS 服务器将结果保存在本地缓存中 =》
6. 本地 DNS 服务器将结果返回给浏览器

## 21.token 是什么

**简介**

token 也可以称为令牌，一般由`uid + time + sign + payload`组成

```markdown
uid: 用户唯一身份标识
time：当前时间戳
sign：签名，使用 hash/encrypt 压缩成定长的十六进制字符串，防止第三方恶意拼接
固定参数（可选）：将一些常用的固定参数加入到 token 中，一般为了避免重复查库
```

**存放**

token 在客户端一般存放与 LocalStorage、cookie、sessionStorage 中。在服务端一般存于数据库中。

session 是有状态的，一般存于服务器内存或者硬盘中，当服务器采用分布式或者集群式时，session 就会面对负载均衡问题。负载均衡多服务器的请客，不好确认当前用户是否登录，应为多服务器不共享 session。

使用 token 时，客户端登录传递信息给服务端，服务端收到后，把用户信息加密传给客户端，客户端将 token 存放于 localStorage 等容器中。客户端每次访问都传递 token，服务端解密 token，就知道这个用户是谁了。通过 cpu 界面就不需要存储 session，解决负载均衡多服务器的问题。这个方法叫 JWT（JSON Web Token）

**认证过程**

1. 用户登录。成功后服务器返回 Token 给客户端
2. 客户端收到数据后保存在客户端
3. 客户端再次访问服务器，将 token 放在 headers 中，或者其他方式传递给服务端
4. 服务端采用 filter 过滤器校验。校验成功返回请求的数据，校验失败返回错误码。

**加密过程**

- 需要一个随机数 secret
- 后端利用 secret 和加密算法对 payload（如账号密码）生成一个字符串（token），返回给前端
- 前端每次请求都在 header 中带上 token
- 后端用同样的算法解密

**CSRF（Cross-site request forgery）跨站请求伪造**

token 可以抵挡 csrf，cookie+session 不可以。

cookie：登陆后后端生成一个 sessionid 放在 cookie 中返回给客户端, 并且服务端一直记录着这个 sessionid, 客户端以后每次请求都会带上这个 sessionid, 服务端通过这个 sessionid 来验证身份之类的操作。所以别人拿到了 cookie 就相当于拿到了 sessionid ,就可以完全替代你。同时浏览器会自动携带 cookie

token：同样是登录后服务端返回一个 token，客户端保存起来，在以后 http 请求里手动的加入到请求头里，服务端根据 token 进行身份的校验。浏览器不会自动携带 token，所以不会劫持 token。

## 22.token 过期后，页面如何实现无感刷新

**无感刷新**

本质是为了提升用户体验，当 token 过期时不需要用户跳回登录页重新登录，而是当 token 过期后，进行拦截，发送刷新 token 的 ajax，获取新的 token 并进行覆盖，让用户感觉不到 token 已经过期。

**实现方法**

- 后端返回过期时间，前端判断，主动调用刷新。缺点：本地时间容易篡改
- 写个定时器，自动刷新。缺点：浪费资源。
- 在响应拦截其中拦截，判断 token 过期后，调用刷新接口。

# 二、HTTPS

## 1.什么是 HTTPS 协议

超文本传输安全协议是一种通过计算机网络进行安全通讯的传输协议，HTTPS 经由 HTTP 进行通讯，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议 TLS/SSL 具有身份认证、信息加密和完整性校验的功能，可以避免此类问题的发生。

安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作和对接收到的 HTTP 的内容进行解密。

## 2.TLS/SSL 的工作原理

TLS 全称**安全传输层协议**以及前身 SSL**安全套接层**，是介于 TCP 和 HTTP 之间的一层安全协议，不影响原有的 TCP 和 HTTP 协议，所以使用 HTTPS 基本上不需要对 HTTP 页面进行太多改造。

TLS/SSL 的功能实现主要依赖三类基本算法：

- 散列函数 hash：用来验证信息的完整性
- 对称加密算法：采用协商的密钥对数据加密
- 非对称加密：实现身份认证和密钥协商

## 3.对称加密和非对称加密

对称加密和非对称加密都是安全传输层里的加密算法。

**对称加密**

简介：

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥。这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难。通信双方都使用同一个密钥进行加密，解密。

优点：

计算量小，加密速度快，加密效率高。

缺点：

在数据传输前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密的信息就不安全了。最不安全的地方就是在与第一次开始，互相约定密钥进行密钥传输的时候。

**非对称加密**

简介：

通讯双方时使用不同的密钥进行加密和解密，即密钥对。私钥可以解密公钥加密的内容，公钥可以解密私钥加密的内容。公开公钥，别人使用公钥加密数据传送，收到数据后再使用私钥解密。

优点：

安全性比对称加密要好。

缺点：

加密和解密时间长、速度慢、只适合少量数据进行加密。

## 4.数字证书

简介：

使用一种 Hash 算法对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（CA）用它的私钥对信息摘要加密，形成签名（数字签名）。然后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就可以发现得到的信息是否被更改了。

作用：

当存在一个中间人，截取了对方发给我们的公钥，然后把他自己的公钥发送给我们，当我们使用他的公钥进行加密发送后，他就可以使用他的私钥对信息解密，并且使用之前的公钥加密后发送信息。这样我们的信息就被窃取了并且无法知道。

## 5.HTTPS 握手过程

1. 客户端向服务器发送请求，请求中包含使用的协议号版本、生成的随机数、客户端支持的加密方法
2. 服务器收到请求后，确认双方使用的加密方法，给出服务器的证书以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效性后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发送给服务器。并且还会提供一个前面所有内容的 hash 值，用来给服务器校验。
4. 服务器使用自己的私钥解密客户端发来的随机数。并提供前面所有内容的 hash 值给客户端检验。
5. 客户端和饥饿服务端更具约定的加密方法，使用前面三个随机数生成密钥，以后所有对话过程都是用这个密钥来加密信息。

## 6.HTTPS 的优缺点

**优点**

- 使用 HTTPS 协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器。
- 使用 HTTPS 协议可以进行加密传输、身份认证，通讯更安全，防止数据在传输过程中被篡改、窃取，确保数据的安全性。
- HTTPS 是先行框架下最安全的解决方案，虽然不是绝对安全，但是大幅增加中间人攻击成本。

**缺点**

- HTTPS 需要做服务器和客户端双方都加密和解密过程，耗费更多的服务器资源，过程复杂。
- HTTPS 戏小姨或首阶段比较费时，增加页面加载事件。
- SSL 证书是收费的，功能越强大的证书费用越高。
- HTTPS 链接服务器端资源占用高很多，支持方可稍多的网站需要投入更大的成本。
- SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名。

## 7.HTTPS 如何保证安全的

结合对称加密和非对称加密两种方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到堆成加密的密钥，然后双方使用对称加密来通讯。这个时候需要一个第三方颁发证书（CA），证明身份，防止被中间人攻击。

# 三、TCP

## 1.TCP 的三次握手

**第一次握手**

客户端向服务器端发送请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端会进入 SYN-SENT 状态。

**第二次握手**

服务端收到连接请求后，如果同意链接，则会发送一个应答，包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端接收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发送完这个报文后便进入 ESTABLISHED 状态，服务端收到这个应答之后，也进入 ESTABLISHED 状态，此时链接建立成功。

## 2.为什么要进行三次握手，而不是两次

1. 为了确保双方的接受能力和发送能力都正常。
2. 如果两次握手则会发生下列异常：如果客服端放出链接请求，但是因为连接请求报文丢失而未收到确认，于是客户端再穿一次链接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端一共发出了两个请求连接的报文，其中一个丢失，第二个到达了服务端，但是假设第一个只是在某个网络节点长时间滞留了，延误到连接释放后才到达服务端，如果不采用三次握手，那么服务端就会认为是一个新的连接从而建立连接，浪费了资源。

## 3.TCP 四次挥手

**第一次挥手**

若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。

**第二次挥手**

服务端收到连接释放请求后，会告诉应用层要释放 TCP 连接。然后会发送 ACK 包，并进入 CLOSE_WANT 状态，此时表明客户端到服务端的链接已经释放，不再接收客户端发的数据了。但是因为 TCP 是双向的，所以服务端人就可以发送数据给客户端。

**第三次挥手**

服务端此时还没有发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端进入 LAST_ACK 状态。

**第四次挥手**

客户端收到释放请求后，向服务器发送确认应答，此时客户端进入 TIME_WAIT 状态。该状态会持续 2MSL 时间，如果该时间段内没有服务的重发请求的花，就进入 CLOSED 状态。当服务端收到确认应答后，已进入 CLOSED 状态。

## 4.为什么要进行四次挥手

应为当服务端收到客户端 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文时用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，肯可能斌不会立刻关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端"你的 FIN 报文我收到了"。只有等到我服务端所有报文发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要第四次挥手。

## 5.TCP 粘包

**简介**

默认情况下，TCP 连接会启用延迟传送算法（Nagle），再数据发送前先缓存他们，如果短时间有多个数据发送，会缓冲到一起做一次发送，这样可以减少 IO 消耗，提升性能。如果是传输文件的花，那么根本不需要处理粘包，来一个包拼接一个包即可。但是如果是多条消息，或者别的用途的数据就需要处理粘包。

**解决方案**

- 多次发送之前间隔一个等待时间
- 关闭 Nagle 算法
- 进行封包拆包

# 四、Ajax

## 1.Ajax 的组成部分

Ajax 全称：`Asynchronous Javascript And XML`(异步的 js 与 xml)

- A：Asynchronous
- J：Javascript
- A：and
- X：XML 与 XMLHttpRequest（json 的出现晚于 xml）

## 2.XMLHttpRequest 对象

简介

Ajax 的核心是`XMLHttpRequest`，他是一种支持异步请求的技术。`XMLHttpRequest`使你可以使用 Javascript 向服务器发送请求并处理响应而不阻塞用户。可以在页面加载以后进行页面的局部更新。

1. 使用方法
2. 实例化 ajax 对象
3. 调用 open 方法指定请求相关配置
4. 设置请求头
5. 发送请求
6. 注册回调函数

```js
let xhr = new XMLHttpRequest();
xhr.open("post", "http://www.liulongbin.top:3009/api/login");
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.send("username=admin&password=123456");
xhr.onreadystatechange = () => {
  if (xhr.readyState === 4) {
    console.log(xhr.responseText);
  }
};
```

## 3.state 状态码

- 0：请求未建立（创建了 xhr 对象，但是没有调用 open）
- 1：服务器链接已建立
- 2：请求已接受（send 之后，服务器已经接受了请求）
- 3：请求处理中
- 4：请求完成，且响应已就绪

## 4.onreadstatechange 事件

`onload`事件：请求完成时触发一次，此时`xhr.state === 4`

`onreadstatechange`事件：state 状态码每改变一次触发一次

## 5.上传文件

步骤：

1. 给 file 表单注册 onchange 事件
2. 获取文件
3. 创建 FormData 对象
4. 将文件添加到对象中
5. 发送请求

代码实现：

```js
document.querySelector("#input-file").onchange = () => {
  let file = this.files[0];
  if (file === undefined) {
    return alert("请上传文件");
  }
  let fd = new FormData();
  fd.append("file", file);
  axios({
    method: "POST",
    url: "http://www.liulongbin.top:3009/api/upload/avatar",
    data: fd,
  }).then((res) => {
    console.log(res);
  });
};
```

自定义上传按钮：

为自定义按钮绑定点击事件，该事件的回调函数中会主动调用 input-file 中节点的点击事件

```js
DIYBtn.onclick = () => {
  FIleInput.click();
};
```

## 6.取消请求

ajax 原生取消

```js
const xhr = new XMLHttpRequest();
xhr.abort();
```

axios 取消

```js
const controller = new AbortController()

axios.get('/user/admin', {
    signal: controller.signal
}).then(res => {...})

controller.abort()
```

取消请求的意义

- 已发出的请求可能仍然会到达服务端
- 可以取消后续的回调操作，避免多余的回调操作、错误处理、超时处理等，节省资源
- 取消 loading 效果，在单页应用中，在 A 页面跳转到 B 页面时，应该取消 A 页面的请求，否则回调中的一些处理会影响新页面

# 五、浏览器安全与优化

## 1.有哪些可以引起前端安全的问题

**跨站脚本（Cross-Site Scripting, XSS）**

一种代码注入的方式，为了与 CSS 区分所以被称为 XSS。早起常见于网络论坛，起因是网站没有对用户输入进行严格限制，使得攻击者可以将脚本上传到帖子然其他人浏览被注入恶意脚本的页面。其注入方式简单包括但不限于 JavaScript、CSS、Flash 等。

**iframe 滥用**

iframe 内容是由第三方提供的，默认情况下他们不受控制，他们会在 iframe 中运行 js 脚本、flash 插件、弹出对话框等，这可能或破坏前端用户体验。

**跨站点请求伪造（Cross-Site Request Forgeries, CSRF）**

指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或者设定信息等某些状态的更新，属于被动共计。

**恶意第三方库**

无论是后端还是前端开发，绝大多数都是在借助开发框架和各类库进行快速开发，一旦第三方库被植入恶意代码很容易应发安全问题。

## 2.网络劫持有哪几种，如何防范

**DNS 劫持**

- DNS 强制解析：通过修改运营商本地 DNS 记录，来引导用户流量到缓存服务器
- 302 跳转方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的，在对劫持的内存发起 302 跳转的回复，应到用户获取内容。

**HTTP 劫持**

- 由于 http 明文传输，运营商会修改你的 http 相应内容，然后加上广告等。

DNS 劫持已经被监管。HTTP 劫持使用 HTTPS 加密。

## 3.进程与线程

**概念**

从本质上说，进程和线程都是 CPU 工作时间片的一个描述。

- 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上说就代表一个程序。
- 线程是进程中更小的单位，描述了执行一段指令所需的时间。

**区别**

应用：进程可以看做独立应用，线程不能。

资源：进程是 cpu 资源分配的最小单位，是能拥有资源和独立运行的最小单位；线程是 cpu 调度的最小单位，线程是建立在进程基础上的一次程序运行单位，一个进程中可以有多个线程。

通信：线程可以通过直接共享同一进程中的资源，二进程通信需要借助进程中通信。

调度：进程切换比线程切换的开销要大。线程是 CPU 调度的基本单位，线程的切换不会引起进程切换，但是某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

开销：由于创建或者撤销进程时，系统都要为之分配或者回收资源，如内存、I/O 等，其开销远大于创建或销毁线程时的开销。

## 4.如何实现浏览器内多个标签页之间的通信

**websocket 协议**

websocket 协议可以实现服务器推送，所以服务器就可以当做中介者。标签页通过向服务器发送数据，然后有服务器向其他标签页推送转发。

**ShareWorker**

ShareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以当中介者。标签页间通过共享一个线程，然后通过这个共享线程来实现数据的交换。

**localStorage**

可以在一个标签页对 localStorage 的变化时间进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当了中介者的角色。

**postMessage**

如果我们能过获得对应标签的引用，就可以说使用 postMessage 方法进行通信。

## 5.为什么需要浏览器缓存

对于浏览器的缓存，主要针对的是前端的静态资源，再发起请求之后，拉取相应的金泰资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉去资源，并保存到本地。这样就大大减少了请求的次数，提高了网站性能。

所谓的浏览器缓存指的是浏览器将用户请求过的静态资源存储到电脑的本地磁盘中，当浏览器再次访问时，直接从本地加载，不需要再去服务器请求了。

## 6.点击刷新按钮或者按 F5、Ctrl+F5、地址栏回车有什么区别

**点击刷新按钮或者 F5**

浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味之服务器会对文件检查新鲜度，返回结果可能是 304，也可能是 200。

**Ctrl+F5**

浏览器不会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果时 200。

**地址栏回车**

浏览器按照正常流程，价差本地缓存，然后服务器校验新鲜度，最后返回内容。

## 7.浏览器渲染过程遇到 JS 文件如何处理

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若语法哦 Javascript，那么它会暂停文档的解析，将控制权交给 Javascript 引擎，等 JavaScript 引擎运行完毕，浏览器中再从终端的地方恢复继续解析文档。

也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放到 body 标签尾部的原因。当然在当下，可以给 script 添加`defer`或者`async`属性，来解决这个问题。

## 8.什么是文档的与解析

Webkit 和 Firefox 都做了这个优化，当执行 Javascript 脚本时，另一个线程解析剩下的脚本，斌家在后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，与解析并不改变 DOM 树，他将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本，样式表及图片。

## 9.CSS 如何阻塞文档解析

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript 脚本执行时可能在文档解析时请求样式表的信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这样会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，然后再继续文档的解析。

## 10.浏览器的本低存储方式

**1.Cookie**

**简介**

Cookie 时最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否都是同一用户发起的，为解决这个问题，Cookie 就出现了，Cookie 的大小只有 4kb，他是一种纯文本文件，每次发起 HTTP 请求都会携带 Cookie。

就是最开始是服务端用于记录用户状态的一种方式，由服务端设置，在客户端存储，然后每次同源请求时，发送给服务端。cookie 最多存储 4k 数据，他生存时间由 expires 属性确定，并且 cookie 只能被同源的页面访问。

**特性**

- Cookie 一旦创建成功，名称就无法修改。
- Cookie 是无法跨域名的，也就是说 a 域名和 b 域名下的 cookie 是无法共享的，这也是有 Cookie'的隐私安全性决定的，这样能够阻止非法获取其他网站的 Cookie。
- 每个域名下的 Cookie 的数量不能超过 20 个，每个 Cookie 的大小不能超过 4kb
- 有安全问题，如果 Cookie 被拦截了，那就可以获取 session 的所有信息，即使加密也于事无补，无需知道 cookie 的意义，只需要转发 cookie 就能达到目的
- Cookie 再请求一个新的页面的时候都会被发送出去。

**2.LocalStorage**

**简介**

LocalStorage 是 HTML5 引入的新特性，由于有时候我们的信息储存较大，Cookie 就不能满足我们的需要，这时候就需要 LocalStorage。

**优点**

- 大小为 5MB，可以储存更多信息
- 是持久储存，斌不会随着页面的关闭而消失，除非主动清理。
- 仅仅存储在本地，不会随 HTTP 发送到服务器

**缺点**

- 兼容问题，IE8 以下版本不支持
- 浏览器设置为隐私模式无法读取 LocalStorage
- 有同源策略限制

**3.SessionStorage**

**简介**

SessionStorage 和 LocalStorage 都是在 HTML5 才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

它借鉴了服务端 session 的概念，代表的是一次会话中所保存的数据。他一般能存储 5M 或者更大的数据，他在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一窗口的同源页面所访问。

**SessionStorage 与 LocalStorage 对比**

- 都是本地数据存储
- 都具有同源策略，Session Storage 更加严格，要求同意浏览器的同意窗口下才能共享。
- 不能被爬虫读取

## 11.同源策略和跨域

**同源策略**

protocal（协议）、domain（域名）、port（端口）三者必须一致

**同源策略的限制**

- 当前域下的 js 脚本不能访问其他域下的 cookie、localStorage 和 indexDB
- 当前域下的 js 脚本不能访问操作其他域下的 DOM
- 当前域下的 ajax 无法发送跨域请求。

**同源策略的目的**

主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

**跨域的概念**

指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，时浏览器对 JavaScript 世家的安全限制，防止他人恶意攻击网站。

## 12.如何解决跨域问题

**CORS**

CORS 需要浏览器和服务器同时支持，整个 CORS 过程都是浏览器完成的，无需用户参与。因此实现 CORS 的关键就是服务器，只要服务器实现了 CORS 请求，就可以跨域通讯。

**JSONP**

jsonp 的原理是用`<script>`标签没有跨域限制，通过`<script>`标签 src 属性，发送带有 callback 参数的 get 请求，服务端通过将接口返回的数据平凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。

**possMessage**

postMessage 是 HTML5 中的 API，且是为数不多的可以跨域操作的 window 属性之一，它可以解决下面的问题：

- 页面和其他打开的新窗口的数据传递
- 多窗口之间的信息传递
- 页面与嵌套的 iframe 信息传递
- 上面三个场景的跨域数据传递

```js
postMessage(data, origin)
data: 传参，最好使用JSON.stringify()序列化
origin：协议+主机+端口号，也可以设置为“*”，表示可以传递给任意窗口，如果只当和当前窗口同源的话设置为“/”
```

**Node 中间件代理**

同源策略是浏览器需要遵循的标准，而如果是服务器向服务器发送请求则不需要遵循同源策略，代理服务器，需要做一下几个步骤：

- 接受客户端请求
- 将请求转发给服务器
- 拿到服务器响应数据

**nginx 反向代理**

实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

通过 nginx 配置一个代理服务器，域名与 domain1 相同，端口不同做跳板机，反向代理 domain2 接口，斌且可以顺便修改 cookie 中的 domain 信息，方便当前域写入 cookie，实现跨域登录。

## 13.正向代理和反向代理

**正向代理**

客户端想获取一个服务端数据，但是因为种种原因无法获取。于是客户端设置了一个代理服务器，指向指定的目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器颖仓真是客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

**反向代理**

服务器为了能够将工作负载到多个服务器来提高完整性能等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实的服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要修改 DNS 让域名揭晓到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

## 14.XSS 和 CSRF

**XSS**

简介

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户浏览器上运行，从而盗取用户的信息 cookie 等。

XSS 攻击的本质是应为网站没有对恶意代码进行过滤，与正常代码混合在一起，浏览器没有办法分辨哪些脚本时可信的，从而导致恶意代码的执行。

危害

攻击者可以通过这种方式进行一下操作

- 获取页面数据，如 DOM、cookie、localStorage
- DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器。
- 破坏页面结构
- 留恋劫持，将连接指向其他网站

防御方式

可以从浏览器的执行来进行预防，一种是使用纯前端方法，不适用服务端拼接后返回（不适用服务端渲染）。另一种是对需要插入 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对恶意代码进行判断。

**CSRF**

简介

CSRF 指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后代的用户验证，冒充用户向服务器执行一些操作。

CSRF 的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来冒充用户。

防御方式

- 进行同源检测，服务器根据 http 请求头中的 origin 或者 referer 信息来判断亲求是否为允许访问的站点，从而对请求进行过滤。
- 使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token，当网站再次发起请求时，在请求参数中加入服务端返回的 token，然后服务器对这个 token 进行验证。
- 对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证
- 在设置 cookie 属性的时候设置 Samesite，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况都不能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求的时 get 请求，且会发生页面跳转的请求所使用。

## 15.中间人攻击

**简介**

中间人是指攻击者在通讯的两端分别建立的独立的联系，并交换其收到的数据，时通讯的两端认为他们赈灾通过一个私密的连接与对方直接对话，但事实上真个会话都被攻击者完全掌控。在中间人攻击下，攻击者可以拦截通讯双方的通话并插入新的内容。

**攻击过程**

- 客户端发送请求到服务端，被中间人截获
- 服务器向客户端发送公钥
- 中间人截获公钥，保留在自己手上。然后自己生成一个伪造公钥，发送给客户端
- 客户端收到伪造的公钥后，生成加密 hash 发送给服务器
- 中间人收到加密的 hash 后，用自己的私钥解密获得真密钥，同时生假的加密 hash 值，发送给服务器。
- 服务器用私钥解密获得的假密钥，然后加密数据发送给客户端

## 16.介绍 websocket

websocket 是一种网络通讯协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，这个是对比 HTTP 协议来说的，HTTP 协议是一种无状态、无连接、单向的应用层协议，通信请求只能由哭护短发起，服务端对请求做出应答处理。

HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接，就可以一直保持连接状态。

## 17.什么是轮询

**轮询**

指的是每隔一段时间进行一次查询或者询问。轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。

**短轮询**

通过客户端定期轮询来询问服务端时候又新的信息产生，如果有则返回，没有就不响应，缺点：轮询间隔大，结果不实时；轮询间隔小，消耗的资源则多，怎加服务器负担。

**长轮询**

是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，则布里克返回，而是 Hold 一段时间等新的信息产生或者超时再返回，客户端收到服务器的应答后继续轮询。可以看出长轮询比端轮询可以减少大量的无用请求，并且客户端收取新信息也会实时不少。

## 18.如何做 SEO 优化

简介

SEO，即搜索引擎优化，SEO 时随着搜索引擎出现而来的，两者是相互促进，互利共生的关系。SEO 的存在就是为了提升网页在搜索引擎自然搜索结果中收录数量以及排序位置而作的优化。而优化的目的就是为了提升网站在搜索引擎中的权重，怎加对搜索引擎的友好度，使得用户访问网站时能排在前面。

方法

- 优化完整结构布局
- 控制首页连接数量
- 网页层级不要太深
- 控制页面大小，减少 HTTP 请求，提高网站加载速度
- 使用语义化标签
- 利用浏览器缓存
