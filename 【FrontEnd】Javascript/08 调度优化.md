# 帧回调：`requestAnimationFrame`

> 浏览器提供的异步 API，在**下一帧渲染前**执行回调，与屏幕刷新率同步，专为高性能动画设计。

## 1. 工作原理

- 浏览器默认 60fps（≈16.67ms/帧），高刷屏幕自动适配
- 回调在每帧**绘制前**执行，与渲染管线对齐
- 标签页不活跃时**自动暂停**，节省资源

## 2. 基本语法

```js
let animationId;

function animate() {
  drawSomething(); // 更新动画逻辑

  animationId = requestAnimationFrame(animate); // 注册下一帧
}

animate();                          // 启动
cancelAnimationFrame(animationId);  // 停止
```

## 3. 对比 `setTimeout / setInterval`

| 特性 | `requestAnimationFrame` | `setTimeout / setInterval` |
| --- | --- | --- |
| 帧同步 | ✅ 与浏览器刷新同步 | ❌ 不同步，可能掉帧 |
| 节流 | ✅ 不活跃时自动暂停 | ❌ 持续执行 |
| 性能 | ✅ GPU 友好，少布局重排 | ❌ CPU 压力大 |
| 适用场景 | 动画、渲染相关 | 通用定时任务 |

## 4. 常见用法

### 节流高频事件（scroll / resize）

```js
let ticking = false;

window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(() => {
      handleScroll();
      ticking = false;
    });
    ticking = true;
  }
});
```

### Vue 中使用

```js
import { onMounted, onBeforeUnmount } from 'vue';

let animationId;

onMounted(() => {
  function update() {
    // 更新数据或 DOM
    animationId = requestAnimationFrame(update);
  }
  update();
});

onBeforeUnmount(() => {
  cancelAnimationFrame(animationId); // 必须取消，否则内存泄漏
});
```

## 5. 适用场景

| 场景 | 示例 |
| --- | --- |
| 动画 | 位置、旋转、缩放、颜色变换 |
| 拖拽 | 鼠标跟随、滑块、虚拟滚动 |
| 可视化 | 数据图表、粒子动画 |
| 游戏开发 | 主循环、角色移动、碰撞检测 |
| 性能节流 | 替代 `mousemove` 高频触发 |

## 6. 注意事项

- 每帧逻辑不要太重，否则超过 16ms 就会掉帧
- 非动画逻辑用 `setTimeout`，不要滥用 rAF
- 组件销毁时必须调用 `cancelAnimationFrame`

---

# 空闲回调：`requestIdleCallback`

> 浏览器提供的异步 API，在**主线程空闲时**执行低优先级任务，不影响关键渲染路径。

## 1. 工作原理

浏览器完成高优先级任务（交互、布局、渲染）后，若当前帧还有剩余时间，则调用注册的回调。

回调接收 `IdleDeadline` 对象，用于判断剩余空闲时间：

| 属性 / 方法 | 含义 |
| --- | --- |
| `timeRemaining()` | 当前帧剩余的空闲毫秒数 |
| `didTimeout` | 是否因超时被强制执行 |

## 2. 基本语法

```js
const handle = requestIdleCallback((deadline) => {
  // 在空闲时间内尽量多处理任务
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    doNextTask();
  }
}, { timeout: 2000 }); // 最多等 2s，超时强制执行

cancelIdleCallback(handle); // 取消
```

`options.timeout`：若超过该毫秒数回调仍未执行，则强制放入事件循环执行（可能影响性能）。

## 3. 对比 `requestAnimationFrame`

| 对比项 | `requestAnimationFrame` | `requestIdleCallback` |
| --- | --- | --- |
| 执行时机 | 下一帧渲染前 | 主线程空闲时 |
| 适用任务 | 动画、视觉更新 | 后台、非紧急任务 |
| 帧同步 | 是（~60fps） | 否（取决于系统负载） |
| 是否保证执行 | 是（每帧都调） | 否（可能跳过，需设 timeout） |

## 4. 使用场景

| 场景 | 示例 |
| --- | --- |
| 异步预加载 | 懒加载模块、组件、图片 |
| 缓存处理 | 本地缓存更新、预��入 |
| 非阻塞任务 | 日志上传、埋点、性能统计 |
| DOM 清理 | 虚拟 DOM diff 后清理无关节点 |
| UI 空闲优化 | 拖动结束后处理回弹动画 |

## 5. 示例

```js
// 空闲时预加载模块
requestIdleCallback(async () => {
  const { default: heavyModule } = await import('./heavy-module.js');
  heavyModule.init();
});

// 空闲时预加载图片
requestIdleCallback(() => {
  const img = new Image();
  img.src = 'https://example.com/slow-image.jpg';
});
```

## 6. Safari 兼容（Polyfill）

`requestIdleCallback` 在 Safari 中不支持，可用以下 polyfill：

```js
window.requestIdleCallback = window.requestIdleCallback || function (cb) {
  return setTimeout(() => {
    const start = Date.now();
    cb({
      didTimeout: false,
      timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
    });
  }, 1);
};

window.cancelIdleCallback = window.cancelIdleCallback || clearTimeout;
```

---

# 监听元素交叉：`IntersectionObserver`

> 异步监听目标元素与视口（或指定容器）的交叉状态变化，替代滚动事件监听，性能更优。

## 1. 核心原理

- 观察元素与根元素的交叉情况，触发异步回调
- 浏览器底层优化调度，不阻塞主线程
- 避免了手写 `scrollTop` 判断带来的性能瓶颈

## 2. 语法

```js
const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('元素进入视口');
      observer.unobserve(entry.target); // 触发一次后取消监听
    }
  });
}, {
  root: null,        // null 表示浏览器视口
  rootMargin: '0px', // 类似 CSS margin，可提前/延后触发
  threshold: 0.1     // 交叉比例 0~1，可传数组
});

observer.observe(element);
```

## 3. 参数说明

| 参数 | 说明 |
| --- | --- |
| `root` | 基准容器，默认为浏览器视口 |
| `rootMargin` | 偏移量，`'100px'` 表示提前 100px 触发 |
| `threshold` | 交叉比例，`0` 一进入就触发，`1` 完全进入才触发 |

## 4. 典型场景与参数建议

| 场景 | rootMargin | threshold |
| --- | --- | --- |
| 图片懒加载 | `'200px'` | `0` |
| 滚动加载更多 | `'0px 0px 300px 0px'` | `0` |
| 曝光统计 | `'0px'` | `0.5` 或 `1` |
| 动画触发 | `'50px'` | `0.3` |

## 5. 图片懒加载示例

```js
const images = document.querySelectorAll('img[data-src]');

const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
}, { rootMargin: '100px', threshold: 0.1 });

images.forEach(img => observer.observe(img));
```

## 6. 兼容性

IE 不支持，需使用 polyfill。现代浏览器全面支持。

---

# 监听大小变化：`ResizeObserver`

> 异步监听 DOM 元素的**布局尺寸变化**（宽/高），不监听内容变化。

## 1. 使用场景

- 响应式布局：元素尺寸变化后重新排版
- 图表自适应：容器缩放时重新绘制
- 虚拟滚动：滚动区域尺寸更新
- Canvas / 游戏：自动缩放适配

## 2. 基本用法

```js
const resizeObserver = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { width, height } = entry.contentRect;
    console.log(`尺寸变化：${width}px x ${height}px`);
  }
});

resizeObserver.observe(document.querySelector('#box'));
resizeObserver.disconnect(); // 停止所有监听
```

## 3. Vue 3 示例

```vue
<template>
  <div ref="elRef" class="resize-box">
    当前宽度：{{ size.width }}，高度：{{ size.height }}
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue';

const elRef = ref(null);
const size = ref({ width: 0, height: 0 });
let observer;

onMounted(() => {
  observer = new ResizeObserver(([entry]) => {
    const { width, height } = entry.contentRect;
    size.value = { width, height };
  });
  if (elRef.value) observer.observe(elRef.value);
});

onBeforeUnmount(() => {
  observer?.disconnect();
});
</script>
```

## 4. `entry.contentRect` 属性

| 属性 | 含义 |
| --- | --- |
| `width` / `height` | 元素可见区域尺寸（不含滚动条） |
| `top` / `left` | 相对于元素本身的位置（通常为 0） |
| `x` / `y` | 同 `top` / `left` |

## 5. 注意事项

| 注意点 | 说明 |
| --- | --- |
| 频繁触发 | 变化频繁时建议加防抖 |
| `display: none` | 元素隐藏时不触发 |
| 避免死循环 | 回调中修改元素尺寸会再次触发回调 |
| 及时清理 | 组件卸载前调用 `disconnect()` |

### 防抖写法

```js
let timer;
const resizeObserver = new ResizeObserver(entries => {
  clearTimeout(timer);
  timer = setTimeout(() => {
    for (const entry of entries) {
      console.log(entry.contentRect.width);
    }
  }, 100);
});
```

---

# 监听节点变化：`MutationObserver`

> 监听 DOM 的**结构或属性变化**，无需轮询，高效捕捉子节点增删、属性修改、文本变更等。

## 1. 可监听的变化类型

| 配置项 | 描述 |
| --- | --- |
| `childList` | 子元素新增或删除 |
| `attributes` | 属性变化 |
| `characterData` | 文本节点内容变化 |
| `subtree` | 递归监听所有后代节点 |
| `attributeOldValue` | 记录属性变化前的旧值 |
| `characterDataOldValue` | 记录文本变化前的旧值 |

## 2. 基本用法

```js
const observer = new MutationObserver((mutationsList) => {
  for (const mutation of mutationsList) {
    if (mutation.type === 'childList') {
      console.log('子节点变化:', mutation.addedNodes, mutation.removedNodes);
    } else if (mutation.type === 'attributes') {
      console.log('属性变化:', mutation.attributeName);
    } else if (mutation.type === 'characterData') {
      console.log('文本变化:', mutation.target.data);
    }
  }
});

observer.observe(document.getElementById('box'), {
  childList: true,
  attributes: true,
  characterData: true,
  subtree: true,
});

observer.disconnect(); // 停止监听
```

## 3. Vue 3 示例

```vue
<template>
  <div ref="targetEl">内容</div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue';

const targetEl = ref(null);
let observer;

onMounted(() => {
  observer = new MutationObserver((mutations) => {
    console.log('变化：', mutations);
  });
  observer.observe(targetEl.value, {
    childList: true,
    attributes: true,
    subtree: true,
  });
});

onBeforeUnmount(() => {
  observer?.disconnect();
});
</script>
```

## 4. 使用场景

| 场景 | 说明 |
| --- | --- |
| 动态渲染检测 | 监听第三方组件或 iframe 插入的内容 |
| 自动表单校验 | 属性变化时触发校验逻辑 |
| 元素出现/消失 | 弹窗、提示、广告位插入检测 |
| 页面数据注入 | Chrome 插件修改页面时触发 |

## 5. 性能建议

| 方法 | 说明 |
| --- | --- |
| `disconnect()` | 不再需要时立即停止监听 |
| `takeRecords()` | 立即获取待处理记录但不触发回调 |
| 防抖处理 | 变化频繁时手动 debounce |
| 精准目标 | 避免监听整个 `document.body`，选择具体容器 |

---

# 微任务调度：`queueMicrotask`

> 将函数加入微任务队列，在当前同步代码执行完后、下一个宏任务开始前执行。

## 1. 执行顺序

```
同步代码 → 微任务队列（queueMicrotask / Promise.then）→ 宏任务（setTimeout / setInterval）
```

```js
console.log('1');

queueMicrotask(() => console.log('2'));

Promise.resolve().then(() => console.log('3'));

setTimeout(() => console.log('4'), 0);

console.log('5');

// 输出：1 → 5 → 2 → 3 → 4
```

> `queueMicrotask` 和 `Promise.then` 都是微任务，按注册顺序执行，所以 2 在 3 之前。

## 2. 对比 `Promise.then()`

| 特点 | `queueMicrotask` | `Promise.then()` |
| --- | --- | --- |
| 本质 | 直接调度微任务 | 也是微任务（基于 Promise 实现） |
| 可读性 | 简洁，适合临时调度 | 链式/嵌套，不适合临时调度 |
| 性能 | 更轻量，少一层 Promise 包装 | 相对较重 |
| 错误处理 | 异常会终止后续微任务队列 | 可通过 `.catch()` 捕获 |

```js
// 异常行为对比
queueMicrotask(() => {
  throw new Error('oops'); // 会中断后续微任务队列
});

Promise.resolve().then(() => {
  throw new Error('oops'); // 可被 .catch() 捕获
}).catch(err => console.log('捕获:', err));
```

## 3. 使用场景

**场景一：延迟到同步代码结束后执行，但比 setTimeout 更早**

```js
// 当前同步任务完成后立即执行，不等下一轮事件循环
queueMicrotask(() => {
  updateUI();
});
```

**场景二：避免递归栈溢出**

```js
function process(data) {
  if (data.length === 0) return;
  queueMicrotask(() => process(data.slice(1))); // 每次递归让出执行权
}
```
