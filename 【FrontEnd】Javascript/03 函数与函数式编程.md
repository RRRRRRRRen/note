# 函数与函数式编程

## 目录

- [函数基础](#函数基础)
- [this 绑定](#this-绑定)
- [箭头函数](#箭头函数)
- [纯函数](#纯函数)
- [函数式编程](#函数式编程)
- [高阶函数](#高阶函数)

---

## 函数基础

### 函数的定义方式

#### 1. 函数声明（Function Declaration）

```javascript
function add(a, b) {
  return a + b;
}

// 特点：会被提升（hoisting）
console.log(multiply(2, 3)); // 6 - 可以在声明前调用
function multiply(a, b) {
  return a * b;
}
```

#### 2. 函数表达式（Function Expression）

```javascript
// 匿名函数表达式
const subtract = function(a, b) {
  return a - b;
};

// 具名函数表达式
const divide = function div(a, b) {
  if (b === 0) {
    throw new Error('Cannot divide by zero');
  }
  return a / b;
};

// 特点：不会被提升
console.log(subtract(5, 3)); // 2
// console.log(test()); // ReferenceError
// const test = function() { return 1; };
```

#### 3. 箭头函数（Arrow Function）

```javascript
// 基本语法
const square = (x) => x * x;

// 多个参数
const add = (a, b) => a + b;

// 多行函数体
const complexFunc = (x, y) => {
  const result = x * y;
  return result + 10;
};

// 返回对象字面量（需要用括号包裹）
const createPerson = (name, age) => ({ name, age });
```

#### 4. 构造函数（Function Constructor）

```javascript
// 不推荐使用
const sum = new Function('a', 'b', 'return a + b');
console.log(sum(2, 3)); // 5

// 缺点：性能差，不安全，难以优化
```

### 函数参数

#### 1. 默认参数

```javascript
// ES6 之前
function greet(name) {
  name = name || 'Guest';
  return 'Hello, ' + name;
}

// ES6 默认参数
function greet(name = 'Guest') {
  return `Hello, ${name}`;
}

console.log(greet()); // 'Hello, Guest'
console.log(greet('Alice')); // 'Hello, Alice'

// 默认参数可以引用前面的参数
function createUser(name, role = 'user', id = name.toLowerCase()) {
  return { name, role, id };
}
```

#### 2. 剩余参数（Rest Parameters）

```javascript
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// 剩余参数必须是最后一个参数
function logInfo(title, ...details) {
  console.log(`${title}:`, details);
}

logInfo('User Info', 'Alice', 25, 'Engineer');
// User Info: ['Alice', 25, 'Engineer']
```

#### 3. 解构参数

```javascript
// 对象解构
function createUser({ name, age, role = 'user' }) {
  return { name, age, role };
}

createUser({ name: 'Alice', age: 25 });

// 数组解构
function getCoordinates([x, y, z = 0]) {
  return { x, y, z };
}

getCoordinates([10, 20]); // { x: 10, y: 20, z: 0 }
```

### arguments 对象 ⭐

`arguments` 是一个类数组对象，包含传递给函数的所有参数。

```javascript
function showArgs() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2, '2': 3 }
  console.log(arguments.length); // 3
  console.log(arguments[0]); // 1

  // arguments 不是真正的数组
  console.log(Array.isArray(arguments)); // false

  // 转换为真正的数组
  const argsArray = Array.from(arguments);
  // 或者
  const argsArray2 = [...arguments];
  // 或者
  const argsArray3 = Array.prototype.slice.call(arguments);
}

showArgs(1, 2, 3);

// 注意：箭头函数没有 arguments
const arrowFunc = () => {
  console.log(arguments); // ReferenceError 或访问外层的 arguments
};
```

---

## this 绑定

### this 的绑定规则

#### 1. 默认绑定

在非严格模式下，`this` 指向全局对象；严格模式下为 `undefined`。

```javascript
function showThis() {
  console.log(this);
}

showThis(); // 非严格模式: window，严格模式: undefined

'use strict';
function strictShowThis() {
  console.log(this);
}

strictShowThis(); // undefined
```

#### 2. 隐式绑定

当函数作为对象的方法调用时，`this` 指向该对象。

```javascript
const person = {
  name: 'Alice',
  greet: function() {
    console.log(`Hello, I'm ${this.name}`);
  }
};

person.greet(); // 'Hello, I'm Alice'

// 隐式绑定丢失
const greet = person.greet;
greet(); // 'Hello, I'm undefined' (this 指向全局对象)

// 嵌套对象
const obj = {
  name: 'Outer',
  inner: {
    name: 'Inner',
    getName: function() {
      return this.name;
    }
  }
};

console.log(obj.inner.getName()); // 'Inner' (this 指向 inner)
```

#### 3. 显式绑定

使用 `call`、`apply`、`bind` 显式指定 `this`。

```javascript
function introduce(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };

// call: 参数逐个传递
introduce.call(person, 'Hello', '!'); // "Hello, I'm Alice!"

// apply: 参数以数组形式传递
introduce.apply(person, ['Hi', '.']); // "Hi, I'm Alice."

// bind: 返回新函数，不立即执行
const boundIntroduce = introduce.bind(person, 'Hey');
boundIntroduce('~'); // "Hey, I'm Alice~"
```

#### 4. new 绑定

使用 `new` 调用构造函数时，`this` 指向新创建的对象。

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log(`I'm ${this.name}, ${this.age} years old`);
  };
}

const alice = new Person('Alice', 25);
alice.greet(); // "I'm Alice, 25 years old"

// new 的执行过程：
// 1. 创建一个新对象
// 2. 将新对象的 __proto__ 指向构造函数的 prototype
// 3. 将构造函数的 this 指向新对象
// 4. 执行构造函数
// 5. 返回新对象（如果构造函数没有返回对象）
```

### this 绑定优先级 ⭐

**优先级从高到低：**

1. new 绑定
2. 显式绑定（call、apply、bind）
3. 隐式绑定（对象方法调用）
4. 默认绑定（独立函数调用）

```javascript
function test() {
  console.log(this.name);
}

const obj1 = { name: 'obj1', test };
const obj2 = { name: 'obj2' };

// 隐式绑定
obj1.test(); // 'obj1'

// 显式绑定优先级高于隐式绑定
obj1.test.call(obj2); // 'obj2'

// bind 优先级高于隐式绑定
const boundTest = test.bind(obj2);
obj1.test = boundTest;
obj1.test(); // 'obj2'

// new 绑定优先级最高
function Person(name) {
  this.name = name;
}

const boundPerson = Person.bind(obj1);
const person = new boundPerson('Alice');
console.log(person.name); // 'Alice' (不是 'obj1')
```

### call、apply、bind 详解 ⭐

#### 共同点

- 都可以改变函数的 `this` 指向
- 第一个参数都是 `this` 要指向的对象
- 如果第一个参数为 `null` 或 `undefined`，非严格模式下指向全局对象

#### 不同点

```javascript
const obj = {
  name: 'Alice',
  age: 25,
  introduce: function(city, hobby) {
    console.log(`I'm ${this.name}, ${this.age} years old, from ${city}, I like ${hobby}`);
  }
};

const person = {
  name: 'Bob',
  age: 30
};

// call: 立即执行，参数逐个传递
obj.introduce.call(person, 'Beijing', 'coding');
// "I'm Bob, 30 years old, from Beijing, I like coding"

// apply: 立即执行，参数以数组形式传递
obj.introduce.apply(person, ['Shanghai', 'reading']);
// "I'm Bob, 30 years old, from Shanghai, I like reading"

// bind: 返回新函数，不立即执行
const boundIntroduce = obj.introduce.bind(person, 'Guangzhou');
boundIntroduce('music');
// "I'm Bob, 30 years old, from Guangzhou, I like music"

// bind 可以分步传参（柯里化）
const partialBind = obj.introduce.bind(person);
partialBind('Shenzhen', 'sports');
```

#### 手动实现 call

```javascript
Function.prototype.myCall = function(context, ...args) {
  // 如果 context 为 null 或 undefined，指向全局对象
  context = context || window;

  // 创建唯一的属性名，避免覆盖原有属性
  const fnSymbol = Symbol();

  // 将函数作为 context 的方法
  context[fnSymbol] = this;

  // 调用函数
  const result = context[fnSymbol](...args);

  // 删除临时属性
  delete context[fnSymbol];

  return result;
};

// 测试
function greet(greeting) {
  console.log(`${greeting}, I'm ${this.name}`);
}

const person = { name: 'Alice' };
greet.myCall(person, 'Hello'); // "Hello, I'm Alice"
```

#### 手动实现 apply

```javascript
Function.prototype.myApply = function(context, args) {
  context = context || window;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;

  // apply 接收数组参数
  const result = args ? context[fnSymbol](...args) : context[fnSymbol]();

  delete context[fnSymbol];
  return result;
};
```

#### 手动实现 bind

```javascript
Function.prototype.myBind = function(context, ...args1) {
  const fn = this;

  return function(...args2) {
    // 合并参数
    return fn.apply(context, [...args1, ...args2]);
  };
};

// 测试
function introduce(city, hobby) {
  console.log(`I'm ${this.name}, from ${city}, I like ${hobby}`);
}

const person = { name: 'Alice' };
const boundIntroduce = introduce.myBind(person, 'Beijing');
boundIntroduce('coding'); // "I'm Alice, from Beijing, I like coding"
```

---

## 箭头函数

### 箭头函数的特点 ⭐

#### 1. 没有自己的 this

箭头函数不会创建自己的 `this`，它会捕获定义时所在上下文的 `this`。

```javascript
const obj = {
  name: 'Alice',

  // 普通函数
  regularFunc: function() {
    console.log('Regular:', this.name);
  },

  // 箭头函数
  arrowFunc: () => {
    console.log('Arrow:', this.name);
  },

  // 嵌套示例
  nested: function() {
    // 普通函数中的箭头函数
    setTimeout(() => {
      console.log('Nested arrow:', this.name); // this 指向 obj
    }, 100);

    // 普通函数中的普通函数
    setTimeout(function() {
      console.log('Nested regular:', this.name); // this 指向全局对象
    }, 100);
  }
};

obj.regularFunc(); // 'Regular: Alice'
obj.arrowFunc(); // 'Arrow: undefined' (this 指向全局对象)
obj.nested();
// 'Nested arrow: Alice'
// 'Nested regular: undefined'
```

#### 2. 不能使用 call、apply、bind 改变 this

```javascript
const obj = { name: 'Alice' };
const arrowFunc = () => {
  console.log(this.name);
};

arrowFunc.call(obj); // undefined (this 不会改变)
arrowFunc.apply(obj); // undefined
const boundFunc = arrowFunc.bind(obj);
boundFunc(); // undefined
```

#### 3. 不能作为构造函数

```javascript
const Person = (name) => {
  this.name = name;
};

// const alice = new Person('Alice'); // TypeError: Person is not a constructor
```

#### 4. 没有 prototype 属性

```javascript
const arrowFunc = () => {};
console.log(arrowFunc.prototype); // undefined

function regularFunc() {}
console.log(regularFunc.prototype); // { constructor: f }
```

#### 5. 没有 arguments 对象

```javascript
function regularFunc() {
  console.log(arguments); // [Arguments] { '0': 1, '1': 2 }

  const arrowFunc = () => {
    console.log(arguments); // 访问外层的 arguments
  };

  arrowFunc();
}

regularFunc(1, 2);

// 使用剩余参数代替
const arrowFunc = (...args) => {
  console.log(args); // [1, 2, 3]
};

arrowFunc(1, 2, 3);
```

#### 6. 不能用作 Generator 函数

```javascript
// 错误示例
// const generatorArrow = * () => {
//   yield 1;
// }; // SyntaxError

// 正确：使用普通函数
function* generator() {
  yield 1;
  yield 2;
}
```

### 箭头函数的适用场景

#### ✅ 适合使用箭头函数

```javascript
// 1. 数组方法回调
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);

// 2. 定时器回调
setTimeout(() => {
  console.log('Delayed execution');
}, 1000);

// 3. Promise 链
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));

// 4. 需要保持外层 this 的场景
class Counter {
  constructor() {
    this.count = 0;
  }

  start() {
    setInterval(() => {
      this.count++; // this 指向 Counter 实例
      console.log(this.count);
    }, 1000);
  }
}
```

#### ❌ 不适合使用箭头函数

```javascript
// 1. 对象方法（需要动态 this）
const obj = {
  name: 'Alice',
  greet: () => {
    console.log(`Hello, ${this.name}`); // this 不指向 obj
  }
};

// 2. 原型方法
Person.prototype.greet = () => {
  console.log(this.name); // this 不指向实例
};

// 3. 事件处理器（需要访问 event.target）
button.addEventListener('click', () => {
  console.log(this); // this 不指向 button
});

// 4. 需要使用 arguments 的场景
const sum = () => {
  // arguments 不可用
};
```

---

## 纯函数

### 什么是纯函数 ⭐

纯函数是函数式编程的核心概念，具有以下特性：

**1. 相同的输入永远产生相同的输出（确定性）**
**2. 不产生副作用（不修改外部状态）**

```javascript
// ✅ 纯函数
function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5 (相同输入，相同输出)

// ✅ 纯函数
function multiply(arr, factor) {
  return arr.map(item => item * factor);
}

const numbers = [1, 2, 3];
console.log(multiply(numbers, 2)); // [2, 4, 6]
console.log(numbers); // [1, 2, 3] (原数组未被修改)

// ❌ 非纯函数：依赖外部变量
let count = 0;
function increment() {
  return ++count; // 依赖外部状态
}

// ❌ 非纯函数：修改外部状态
function addToArray(arr, item) {
  arr.push(item); // 修改了传入的数组
  return arr;
}

// ❌ 非纯函数：不确定的输出
function getCurrentTime() {
  return new Date().getTime(); // 每次调用结果不同
}

// ❌ 非纯函数：产生副作用
function logAndReturn(value) {
  console.log(value); // 副作用：输出到控制台
  return value;
}
```

### 纯函数的优势

#### 1. 可测试性强

```javascript
// 纯函数易于测试
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// 测试简单直接
console.assert(calculateTotal([{ price: 10 }, { price: 20 }]) === 30);
console.assert(calculateTotal([]) === 0);
```

#### 2. 可缓存性（Memoization）

```javascript
// 纯函数的结果可以缓存
function memoize(fn) {
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache[key]) {
      console.log('From cache');
      return cache[key];
    }

    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

// 斐波那契数列（纯函数）
const fibonacci = memoize(function(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // 计算
console.log(fibonacci(10)); // From cache
```

#### 3. 可组合性

```javascript
// 纯函数易于组合
const double = x => x * 2;
const square = x => x * x;
const addOne = x => x + 1;

// 函数组合
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

const calculate = compose(addOne, square, double);
console.log(calculate(3)); // ((3 * 2) ^ 2) + 1 = 37
```

#### 4. 并行处理安全

```javascript
// 纯函数没有共享状态，可以安全地并行执行
const processData = data => data.map(item => item * 2);

// 可以安全地在多个线程中执行
// Worker 1: processData([1, 2, 3])
// Worker 2: processData([4, 5, 6])
// 不会互相干扰
```

### 副作用（Side Effects）

副作用是指函数在执行过程中对外部环境产生的影响。

**常见的副作用：**

- 修改全局变量或外部变量
- 修改传入的参数
- 发起 HTTP 请求
- 操作 DOM
- 打印日志
- 读写文件
- 修改数据库

```javascript
// 避免副作用的示例

// ❌ 有副作用
function updateUser(user) {
  user.lastUpdated = new Date();
  return user;
}

// ✅ 无副作用
function updateUser(user) {
  return {
    ...user,
    lastUpdated: new Date()
  };
}

// ❌ 有副作用
let total = 0;
function addToTotal(value) {
  total += value;
}

// ✅ 无副作用
function addToTotal(total, value) {
  return total + value;
}
```

---

## 函数式编程

### 函数柯里化（Currying）⭐

柯里化是把接受多个参数的函数转换成接受单一参数的函数，并返回接受余下参数且返回结果的新函数的技术。

#### 基本概念

```javascript
// 普通函数
function add(a, b, c) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6

// 柯里化后的函数
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curriedAdd(1)(2)(3)); // 6

// ES6 箭头函数写法
const curriedAdd = a => b => c => a + b + c;
```

#### 通用柯里化函数

```javascript
function curry(fn) {
  return function curried(...args) {
    // 如果参数够了，直接执行
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }

    // 参数不够，返回新函数继续收集参数
    return function(...moreArgs) {
      return curried.apply(this, args.concat(moreArgs));
    };
  };
}

// 使用示例
function sum(a, b, c, d) {
  return a + b + c + d;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)(4)); // 10
console.log(curriedSum(1, 2)(3, 4)); // 10
console.log(curriedSum(1)(2, 3, 4)); // 10
console.log(curriedSum(1, 2, 3, 4)); // 10
```

#### 柯里化的好处

**1. 参数复用**

```javascript
// 创建特定配置的函数
const multiply = curry((a, b) => a * b);

const double = multiply(2);
const triple = multiply(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15

// 实际应用：日志函数
const log = curry((level, time, message) => {
  console.log(`[${level}] ${time}: ${message}`);
});

const errorLog = log('ERROR');
const errorLogNow = errorLog(new Date().toISOString());

errorLogNow('Database connection failed');
errorLogNow('API timeout');
```

**2. 延迟执行**

```javascript
const calculate = curry((operation, a, b) => {
  switch(operation) {
    case 'add': return a + b;
    case 'subtract': return a - b;
    case 'multiply': return a * b;
    case 'divide': return a / b;
  }
});

// 延迟执行，先配置操作类型
const add = calculate('add');
const multiply = calculate('multiply');

// 需要时再传入具体数值
console.log(add(5, 3)); // 8
console.log(multiply(5, 3)); // 15
```

**3. 提前确认**

```javascript
const match = curry((regex, str) => regex.test(str));

const hasNumber = match(/[0-9]+/);
const hasLetter = match(/[a-zA-Z]+/);

console.log(hasNumber('abc123')); // true
console.log(hasLetter('123')); // false
```

### 函数组合（Function Composition）

函数组合是将多个函数组合成一个函数的过程。

```javascript
// 基础组合函数
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 或者使用 reduce
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// 示例函数
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

// compose: 从右到左执行
const calculate1 = compose(addOne, double, square);
console.log(calculate1(3)); // ((3^2) * 2) + 1 = 19

// pipe: 从左到右执行
const calculate2 = pipe(square, double, addOne);
console.log(calculate2(3)); // ((3^2) * 2) + 1 = 19

// 实际应用：数据处理管道
const users = [
  { name: 'Alice', age: 25, active: true },
  { name: 'Bob', age: 30, active: false },
  { name: 'Charlie', age: 35, active: true }
];

const getActiveUsers = users => users.filter(u => u.active);
const getUserNames = users => users.map(u => u.name);
const sortNames = names => names.sort();

const processUsers = pipe(
  getActiveUsers,
  getUserNames,
  sortNames
);

console.log(processUsers(users)); // ['Alice', 'Charlie']
```

### 偏函数（Partial Application）

偏函数是固定函数的部分参数，返回一个接受剩余参数的新函数。

```javascript
// 偏函数实现
function partial(fn, ...presetArgs) {
  return function(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

// 使用示例
function greet(greeting, name, punctuation) {
  return `${greeting}, ${name}${punctuation}`;
}

const sayHelloTo = partial(greet, 'Hello');
console.log(sayHelloTo('Alice', '!')); // "Hello, Alice!"
console.log(sayHelloTo('Bob', '.')); // "Hello, Bob."

const sayHelloToAlice = partial(greet, 'Hello', 'Alice');
console.log(sayHelloToAlice('!')); // "Hello, Alice!"
console.log(sayHelloToAlice('~')); // "Hello, Alice~"
```

**柯里化 vs 偏函数：**

```javascript
// 柯里化：每次只接受一个参数
const curriedAdd = a => b => c => a + b + c;
curriedAdd(1)(2)(3); // 6

// 偏函数：可以一次固定多个参数
const partialAdd = partial((a, b, c) => a + b + c, 1);
partialAdd(2, 3); // 6

// 柯里化更灵活，偏函数更直接
```

### 函数记忆化（Memoization）

记忆化是一种优化技术，通过缓存函数的计算结果来提高性能。

```javascript
// 通用记忆化函数
function memoize(fn) {
  const cache = new Map();

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log('Cache hit');
      return cache.get(key);
    }

    console.log('Computing...');
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 示例：计算斐波那契数列
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(10)); // Computing... 55
console.log(memoizedFib(10)); // Cache hit 55

// 实际应用：复杂计算
const expensiveOperation = memoize((x, y) => {
  // 模拟耗时操作
  let result = 0;
  for (let i = 0; i < 1000000; i++) {
    result += x * y;
  }
  return result;
});

console.time('First call');
expensiveOperation(5, 10);
console.timeEnd('First call');

console.time('Second call');
expensiveOperation(5, 10); // 从缓存读取，速度快
console.timeEnd('Second call');
```

### 惰性求值（Lazy Evaluation）

惰性求值是延迟计算直到真正需要结果时才执行。

```javascript
// 惰性函数示例
function createLazyValue(fn) {
  let cached = false;
  let value;

  return function() {
    if (!cached) {
      value = fn();
      cached = true;
    }
    return value;
  };
}

// 使用示例
const lazyExpensiveCalc = createLazyValue(() => {
  console.log('Computing expensive value...');
  return 42 * 1000;
});

console.log('Lazy value created');
console.log(lazyExpensiveCalc()); // Computing expensive value... 42000
console.log(lazyExpensiveCalc()); // 42000 (不再计算)

// 实际应用：惰性初始化
function createConnection() {
  let connection = null;

  return {
    getConnection() {
      if (!connection) {
        console.log('Establishing connection...');
        connection = { status: 'connected' };
      }
      return connection;
    }
  };
}

const db = createConnection();
console.log('DB object created');
console.log(db.getConnection()); // Establishing connection...
console.log(db.getConnection()); // 直接返回已建立的连接
```

---

## 高阶函数

### 什么是高阶函数

高阶函数是满足以下至少一个条件的函数：

1. 接受一个或多个函数作为参数
2. 返回一个函数作为结果

```javascript
// 1. 接受函数作为参数
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, console.log);
// 0
// 1
// 2

// 2. 返回函数
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

### 常见的高阶函数

#### 1. Array.prototype.map

```javascript
const numbers = [1, 2, 3, 4, 5];

// 使用 map
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 手动实现 map
Array.prototype.myMap = function(callback) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback(this[i], i, this));
  }
  return result;
};

const tripled = numbers.myMap(n => n * 3);
console.log(tripled); // [3, 6, 9, 12, 15]
```

#### 2. Array.prototype.filter

```javascript
const numbers = [1, 2, 3, 4, 5, 6];

// 使用 filter
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2, 4, 6]

// 手动实现 filter
Array.prototype.myFilter = function(callback) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      result.push(this[i]);
    }
  }
  return result;
};

const odds = numbers.myFilter(n => n % 2 !== 0);
console.log(odds); // [1, 3, 5]
```

#### 3. Array.prototype.reduce

```javascript
const numbers = [1, 2, 3, 4, 5];

// 使用 reduce 求和
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

// 使用 reduce 求最大值
const max = numbers.reduce((acc, n) => Math.max(acc, n));
console.log(max); // 5

// 手动实现 reduce
Array.prototype.myReduce = function(callback, initialValue) {
  let accumulator = initialValue;
  let startIndex = 0;

  if (initialValue === undefined) {
    accumulator = this[0];
    startIndex = 1;
  }

  for (let i = startIndex; i < this.length; i++) {
    accumulator = callback(accumulator, this[i], i, this);
  }

  return accumulator;
};

const product = numbers.myReduce((acc, n) => acc * n, 1);
console.log(product); // 120

// 复杂应用：数组转对象
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];

const userMap = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});

console.log(userMap);
// { '1': { id: 1, name: 'Alice' }, ... }
```

#### 4. Array.prototype.forEach

```javascript
const numbers = [1, 2, 3, 4, 5];

// 使用 forEach
numbers.forEach((n, index) => {
  console.log(`Index ${index}: ${n}`);
});

// 手动实现 forEach
Array.prototype.myForEach = function(callback) {
  for (let i = 0; i < this.length; i++) {
    callback(this[i], i, this);
  }
};

// 注意：forEach 不返回值，不能中断循环
```

#### 5. Array.prototype.some 和 every

```javascript
const numbers = [1, 2, 3, 4, 5];

// some: 至少有一个满足条件
const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven); // true

// every: 所有元素都满足条件
const allPositive = numbers.every(n => n > 0);
console.log(allPositive); // true

// 手动实现 some
Array.prototype.mySome = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (callback(this[i], i, this)) {
      return true;
    }
  }
  return false;
};

// 手动实现 every
Array.prototype.myEvery = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (!callback(this[i], i, this)) {
      return false;
    }
  }
  return true;
};
```

### 实用的高阶函数

#### 1. once - 只执行一次

```javascript
function once(fn) {
  let called = false;
  let result;

  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  };
}

// 使用示例
const initialize = once(() => {
  console.log('Initializing...');
  return { status: 'initialized' };
});

console.log(initialize()); // Initializing... { status: 'initialized' }
console.log(initialize()); // { status: 'initialized' } (不再打印)
```

#### 2. debounce - 防抖

```javascript
function debounce(fn, delay) {
  let timer = null;

  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用示例：搜索输入
const search = debounce((query) => {
  console.log('Searching for:', query);
}, 500);

// 用户快速输入时，只有最后一次会触发搜索
search('a');
search('ab');
search('abc'); // 只有这次会执行
```

#### 3. throttle - 节流

```javascript
function throttle(fn, delay) {
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用示例：滚动事件
const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 200);

// 无论滚动多快，每 200ms 最多执行一次
window.addEventListener('scroll', handleScroll);
```

#### 4. pipe - 管道函数

```javascript
function pipe(...fns) {
  return function(value) {
    return fns.reduce((acc, fn) => fn(acc), value);
  };
}

// 使用示例：数据处理流程
const processUser = pipe(
  user => ({ ...user, name: user.name.toUpperCase() }),
  user => ({ ...user, age: user.age + 1 }),
  user => ({ ...user, active: true })
);

const user = { name: 'alice', age: 25 };
console.log(processUser(user));
// { name: 'ALICE', age: 26, active: true }
```

#### 5. compose - 组合函数

```javascript
function compose(...fns) {
  return function(value) {
    return fns.reduceRight((acc, fn) => fn(acc), value);
  };
}

// 使用示例
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const calculate = compose(addOne, double, square);
console.log(calculate(3)); // ((3^2) * 2) + 1 = 19
```

---

## 递归函数

### 什么是递归

递归是函数调用自身的编程技巧。

**递归的两个要素：**

1. 基准条件（Base Case）：递归终止的条件
2. 递归条件（Recursive Case）：函数调用自身

```javascript
// 经典示例：阶乘
function factorial(n) {
  // 基准条件
  if (n <= 1) return 1;

  // 递归条件
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120 (5 * 4 * 3 * 2 * 1)

// 斐波那契数列
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(7)); // 13
```

### 尾递归优化 ⭐

尾递归是指递归调用是函数的最后一个操作，可以被优化为循环。

```javascript
// ❌ 非尾递归（会导致栈溢出）
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // 递归后还有乘法操作
}

// ✅ 尾递归优化
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc); // 递归是最后一个操作
}

console.log(factorial(5)); // 120

// 斐波那契的尾递归优化
function fibonacci(n, a = 0, b = 1) {
  if (n === 0) return a;
  return fibonacci(n - 1, b, a + b);
}

console.log(fibonacci(7)); // 13
```

### 递归的实际应用

#### 1. 深度遍历对象

```javascript
function deepClone(obj, hash = new WeakMap()) {
  // 处理 null 和非对象类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  // 处理循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }

  // 处理日期
  if (obj instanceof Date) {
    return new Date(obj);
  }

  // 处理正则
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }

  // 创建新对象
  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);

  // 递归复制属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }

  return cloneObj;
}

// 测试
const original = {
  name: 'Alice',
  age: 25,
  hobbies: ['reading', 'coding'],
  address: {
    city: 'Beijing',
    country: 'China'
  }
};

const cloned = deepClone(original);
cloned.address.city = 'Shanghai';

console.log(original.address.city); // 'Beijing'
console.log(cloned.address.city); // 'Shanghai'
```

#### 2. 树形结构遍历

```javascript
const tree = {
  value: 1,
  children: [
    {
      value: 2,
      children: [
        { value: 4, children: [] },
        { value: 5, children: [] }
      ]
    },
    {
      value: 3,
      children: [
        { value: 6, children: [] }
      ]
    }
  ]
};

// 深度优先遍历
function dfs(node, callback) {
  callback(node.value);
  node.children.forEach(child => dfs(child, callback));
}

dfs(tree, value => console.log(value));
// 输出: 1, 2, 4, 5, 3, 6

// 查找节点
function findNode(node, target) {
  if (node.value === target) return node;

  for (let child of node.children) {
    const found = findNode(child, target);
    if (found) return found;
  }

  return null;
}

console.log(findNode(tree, 5)); // { value: 5, children: [] }
```

#### 3. 扁平化数组

```javascript
// 递归扁平化
function flatten(arr) {
  const result = [];

  arr.forEach(item => {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  });

  return result;
}

const nested = [1, [2, [3, [4, 5]]], 6];
console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6]

// 使用 reduce
function flatten(arr) {
  return arr.reduce((acc, item) => {
    return acc.concat(Array.isArray(item) ? flatten(item) : item);
  }, []);
}
```

---

## 总结与最佳实践

### 关键要点

1. **函数定义**：理解函数声明、函数表达式、箭头函数的区别和适用场景
2. **this 绑定**：掌握 this 的四种绑定规则及其优先级
3. **箭头函数**：了解箭头函数的特点和限制，正确使用
4. **纯函数**：编写无副作用、可预测的纯函数
5. **函数式编程**：掌握柯里化、组合、高阶函数等技术
6. **递归**：理解递归原理，注意尾递归优化

### 最佳实践

1. **优先使用纯函数**，避免副作用
2. **使用箭头函数**处理回调和需要保持 this 的场景
3. **避免在对象方法中使用箭头函数**
4. **使用高阶函数**（map、filter、reduce）代替循环
5. **合理使用柯里化和偏函数**提高代码复用性
6. **注意递归的性能问题**，考虑尾递归优化或改用循环
7. **使用函数组合**构建复杂的数据处理流程
8. **理解 call、apply、bind 的区别**，正确改变 this 指向

### 常见陷阱

1. 箭头函数的 this 无法改变
2. 隐式绑定丢失导致 this 指向错误
3. 递归没有终止条件导致栈溢出
4. 闭包导致的内存泄漏
5. 修改函数参数导致副作用
6. 过度使用函数式编程导致代码难以理解
