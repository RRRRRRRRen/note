# JavaScript 模块化

## 目录

- [模块化概述](#模块化概述)
- [早期模块化方案](#早期模块化方案)
- [CommonJS 规范](#commonjs-规范)
- [ES Module 规范](#es-module-规范)
- [模块化对比](#模块化对比)
- [实际应用](#实际应用)

---

## 模块化概述

### 什么是模块化

模块化是指将一个复杂的程序按照一定的规则拆分成若干个独立的模块，每个模块负责特定的功能。模块之间通过接口进行通信。

### 模块化的优势

**1. 避免命名冲突**

- 每个模块有独立的作用域
- 不会污染全局命名空间

**2. 提高代码复用性**

- 模块可以在不同项目中复用
- 减少重复代码

**3. 提高可维护性**

- 代码结构清晰
- 便于定位和修复问题

**4. 管理依赖关系**

- 明确模块之间的依赖
- 便于管理和更新

**5. 按需加载**

- 提高首屏加载速度
- 优化性能

### 模块化的发展历程

```
无模块化 → IIFE → CommonJS → AMD → CMD → UMD → ES Module
```

---

## 早期模块化方案

### 问题：全局变量污染

没有使用模块化开发，会出现全局变量污染的问题，每个加载的 JS 文件都共享变量。

```html
<body>
  <script src="./index.js"></script>
  <script src="./home.js"></script>
  <script src="./list.js"></script>
</body>
```

```javascript
// index.js
var name = '不要秃头啊';
```

```javascript
// home.js
var name = [1, 2, 3]; // 覆盖了 index.js 中的 name
```

```javascript
// list.js
console.log(name); // [1, 2, 3] - 不是预期的值
```

### 解决方案 1：命名空间

使用对象来模拟命名空间。

```javascript
// moduleA.js
var moduleA = {
  name: 'Module A',
  sayHello: function() {
    console.log('Hello from ' + this.name);
  }
};

// moduleB.js
var moduleB = {
  name: 'Module B',
  sayHello: function() {
    console.log('Hello from ' + this.name);
  }
};

// 使用
moduleA.sayHello(); // 'Hello from Module A'
moduleB.sayHello(); // 'Hello from Module B'
```

**缺点：**

- 仍然会污染全局作用域
- 模块内部状态可以被外部修改
- 依赖关系不明确

### 解决方案 2：IIFE（立即执行函数）

使用 IIFE 创建独立的作用域。

```javascript
// module.js
(function() {
  var name = '私有变量';

  function privateMethod() {
    console.log('私有方法');
  }

  function publicMethod() {
    console.log('公共方法');
    privateMethod();
  }

  // 暴露公共接口
  window.myModule = {
    publicMethod: publicMethod
  };
})();

// 使用
myModule.publicMethod(); // '公共方法' '私有方法'
console.log(myModule.name); // undefined
```

**优点：**

- 创建独立作用域
- 可以实现私有变量和方法

**缺点：**

- 仍然污染全局作用域（window.myModule）
- 依赖关系不明确
- 难以管理模块间的依赖

### 解决方案 3：IIFE + 依赖注入

```javascript
// moduleA.js
var moduleA = (function() {
  var name = 'Module A';

  return {
    getName: function() {
      return name;
    }
  };
})();

// moduleB.js - 依赖 moduleA
var moduleB = (function(moduleA) {
  var name = 'Module B';

  return {
    getName: function() {
      return name + ' depends on ' + moduleA.getName();
    }
  };
})(moduleA);

// 使用
console.log(moduleB.getName()); // 'Module B depends on Module A'
```

**优点：**

- 明确了依赖关系
- 依赖通过参数传入

**缺点：**

- 需要手动管理依赖顺序
- 大型项目难以维护

---

## CommonJS 规范

### 概述

CommonJS 是一个模块化规范，最初是为服务器端 JavaScript（Node.js）设计的。

**特点：**

- 同步加载模块
- 模块输出的是值的拷贝
- 运行时加载
- 主要用于服务器端

### 基本语法

#### 导出模块

**方式 1：module.exports**

```javascript
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

// 导出单个值
module.exports = {
  add: add,
  subtract: subtract
};

// 或者导出函数
module.exports = function(x) {
  return x * x;
};
```

**方式 2：exports**

```javascript
// math.js
exports.add = function(a, b) {
  return a + b;
};

exports.subtract = function(a, b) {
  return a - b;
};
```

**exports vs module.exports ⭐**

```javascript
// exports 是 module.exports 的引用
var exports = module.exports;

// ✅ 正确：给 exports 添加属性
exports.add = function() {};

// ❌ 错误：直接赋值会切断引用
exports = function() {}; // 无效

// ✅ 正确：使用 module.exports
module.exports = function() {}; // 有效
```

#### 导入模块

```javascript
// main.js
const math = require('./math');

console.log(math.add(2, 3)); // 5
console.log(math.subtract(5, 2)); // 3

// 解构导入
const { add, subtract } = require('./math');
console.log(add(2, 3)); // 5
```

### module 对象

每个模块内部都有一个 `module` 对象，代表当前模块。

```javascript
console.log(module);
// {
//   id: '.',
//   exports: {},
//   parent: null,
//   filename: '/path/to/file.js',
//   loaded: false,
//   children: [],
//   paths: [...]
// }
```

**module 属性：**

- `module.id`：模块的标识符，通常是带有绝对路径的文件名
- `module.filename`：模块的文件名（绝对路径）
- `module.loaded`：布尔值，表示模块是否已加载完成
- `module.parent`：调用该模块的模块
- `module.children`：该模块依赖的其他模块
- `module.exports`：模块对外输出的接口

### require 加载规则

#### 1. 路径规则

```javascript
// 绝对路径
require('/home/user/module.js');

// 相对路径
require('./module.js');
require('../module.js');

// 核心模块或 node_modules
require('fs'); // Node.js 核心模块
require('lodash'); // node_modules 中的模块
```

#### 2. 文件扩展名

```javascript
// 以下三种写法等价
require('./module.js');
require('./module');
require('./module.json');

// 查找顺序：.js → .json → .node
```

#### 3. 目录加载

```javascript
// 加载目录时的查找顺序：
// 1. 查找 package.json 的 main 字段
// 2. 查找 index.js
// 3. 查找 index.json
// 4. 查找 index.node

require('./myModule'); // 加载 ./myModule 目录
```

#### 4. node_modules 查找

```javascript
// 从当前目录开始，逐级向上查找 node_modules
// /home/user/project/node_modules/lodash
// /home/user/node_modules/lodash
// /home/node_modules/lodash
// /node_modules/lodash

require('lodash');
```

### 模块缓存机制 ⭐

模块在第一次加载后会被缓存，后续加载直接从缓存读取。

```javascript
// counter.js
let count = 0;

module.exports = {
  increment: function() {
    count++;
  },
  getCount: function() {
    return count;
  }
};

// main.js
const counter1 = require('./counter');
const counter2 = require('./counter');

counter1.increment();
console.log(counter1.getCount()); // 1
console.log(counter2.getCount()); // 1 - 共享同一个实例

console.log(counter1 === counter2); // true
```

**查看和清除缓存：**

```javascript
// 查看缓存
console.log(require.cache);

// 清除指定模块的缓存
delete require.cache[require.resolve('./module')];

// 清除所有缓存
Object.keys(require.cache).forEach(key => {
  delete require.cache[key];
});
```

### 循环依赖 ⭐

当模块之间存在循环依赖时，CommonJS 会返回已执行部分的 exports。

```javascript
// a.js
exports.done = false;
const b = require('./b');
console.log('在 a.js 中，b.done =', b.done);
exports.done = true;
console.log('a.js 执行完毕');

// b.js
exports.done = false;
const a = require('./a');
console.log('在 b.js 中，a.done =', a.done);
exports.done = true;
console.log('b.js 执行完毕');

// main.js
const a = require('./a');
const b = require('./b');
console.log('在 main.js 中，a.done =', a.done, ', b.done =', b.done);

// 输出：
// 在 b.js 中，a.done = false
// b.js 执行完毕
// 在 a.js 中，b.done = true
// a.js 执行完毕
// 在 main.js 中，a.done = true , b.done = true
```

### CommonJS 的特点

**1. 同步加载**

- 适合服务器端（文件在本地）
- 不适合浏览器端（网络加载慢）

**2. 值的拷贝**

- 模块输出的是值的拷贝
- 模块内部变化不会影响已导出的值

```javascript
// lib.js
let counter = 0;

function increment() {
  counter++;
}

module.exports = {
  counter: counter,
  increment: increment
};

// main.js
const lib = require('./lib');

console.log(lib.counter); // 0
lib.increment();
console.log(lib.counter); // 0 - 仍然是 0（值的拷贝）
```

**3. 运行时加载**

- 在代码执行时才加载模块
- 可以动态加载

```javascript
// 动态加载
if (condition) {
  const module = require('./moduleA');
} else {
  const module = require('./moduleB');
}
```

---

## ES Module 规范

### 概述

ES Module（ESM）是 ECMAScript 6（ES6）引入的官方模块化规范。

**特点：**

- 静态加载（编译时加载）
- 输出的是值的引用
- 异步加载
- 浏览器和 Node.js 都支持

### 基本语法

#### 导出模块

**1. 命名导出（Named Exports）**

```javascript
// math.js

// 方式 1：直接导出
export const PI = 3.14159;

export function add(a, b) {
  return a + b;
}

export class Calculator {
  multiply(a, b) {
    return a * b;
  }
}

// 方式 2：统一导出
const PI = 3.14159;
function add(a, b) {
  return a + b;
}
class Calculator {
  multiply(a, b) {
    return a * b;
  }
}

export { PI, add, Calculator };

// 方式 3：重命名导出
export { add as sum, Calculator as Calc };
```

**2. 默认导出（Default Export）**

```javascript
// user.js

// 导出函数
export default function(name) {
  return `Hello, ${name}`;
}

// 导出类
export default class User {
  constructor(name) {
    this.name = name;
  }
}

// 导出对象
export default {
  name: 'Alice',
  age: 25
};
```

**3. 混合导出**

```javascript
// module.js
export const version = '1.0.0';

export function helper() {
  return 'helper';
}

export default class Main {
  constructor() {
    this.version = version;
  }
}
```

#### 导入模块

**1. 命名导入**

```javascript
// 导入指定成员
import { add, PI } from './math.js';

// 重命名导入
import { add as sum } from './math.js';

// 导入所有命名导出
import * as math from './math.js';
console.log(math.add(2, 3));
console.log(math.PI);
```

**2. 默认导入**

```javascript
// 导入默认导出（可以使用任意名称）
import User from './user.js';
import MyUser from './user.js'; // 名称可以不同

const user = new User('Alice');
```

**3. 混合导入**

```javascript
// 同时导入默认和命名导出
import Main, { version, helper } from './module.js';

// 或者
import Main from './module.js';
import { version, helper } from './module.js';
```

**4. 仅执行模块**

```javascript
// 只执行模块，不导入任何内容
import './init.js';
```

### 动态导入（import()）

ES2020 引入了动态导入，返回一个 Promise。

```javascript
// 动态导入
button.addEventListener('click', async () => {
  const module = await import('./module.js');
  module.doSomething();
});

// 条件导入
if (condition) {
  import('./moduleA.js').then(module => {
    module.init();
  });
} else {
  import('./moduleB.js').then(module => {
    module.init();
  });
}

// 按需加载
async function loadModule(moduleName) {
  try {
    const module = await import(`./modules/${moduleName}.js`);
    return module;
  } catch (error) {
    console.error('加载失败:', error);
  }
}
```

### 复合导出

可以在一个模块中导入并重新导出其他模块的内容。

```javascript
// 导出其他模块的内容
export { add, subtract } from './math.js';

// 重命名导出
export { add as sum } from './math.js';

// 导出所有
export * from './math.js';

// 导出默认
export { default } from './user.js';
export { default as User } from './user.js';
```

### import.meta

`import.meta` 对象包含当前模块的元信息。

```javascript
// 获取当前模块的 URL
console.log(import.meta.url);
// file:///path/to/module.js

// 在浏览器中
console.log(import.meta.url);
// http://localhost:3000/module.js

// 实际应用：加载相对资源
const imageUrl = new URL('./image.png', import.meta.url);
```

### ES Module 的特点 ⭐

#### 1. 静态加载（编译时加载）

```javascript
// ✅ 正确：静态导入
import { add } from './math.js';

// ❌ 错误：不能在条件语句中使用
if (condition) {
  import { add } from './math.js'; // SyntaxError
}

// ✅ 正确：使用动态导入
if (condition) {
  import('./math.js').then(({ add }) => {
    // 使用 add
  });
}
```

#### 2. 值的引用（实时绑定）

```javascript
// counter.js
export let counter = 0;

export function increment() {
  counter++;
}

// main.js
import { counter, increment } from './counter.js';

console.log(counter); // 0
increment();
console.log(counter); // 1 - 值更新了（引用）
```

#### 3. 导入的变量是只读的

```javascript
// module.js
export let value = 1;

// main.js
import { value } from './module.js';

value = 2; // TypeError: Assignment to constant variable
```

#### 4. 自动采用严格模式

```javascript
// ES Module 自动启用严格模式
// 无需 'use strict'

function test() {
  undeclaredVar = 1; // ReferenceError
}
```

#### 5. 顶层 this 是 undefined

```javascript
// CommonJS
console.log(this === exports); // true

// ES Module
console.log(this); // undefined
```

---

## 模块化对比

### CommonJS vs ES Module

| 特性 | CommonJS | ES Module |
|------|----------|-----------|
| 加载时机 | 运行时加载 | 编译时加载 |
| 加载方式 | 同步加载 | 异步加载 |
| 输出 | 值的拷贝 | 值的引用 |
| this 指向 | 当前模块 | undefined |
| 使用环境 | Node.js | 浏览器、Node.js |
| 动态导入 | 支持 | 支持（import()） |
| 循环依赖 | 返回已执行部分 | 动态引用 |
| Tree Shaking | 不支持 | 支持 |

### 详细对比

#### 1. 加载时机

```javascript
// CommonJS - 运行时加载
const math = require('./math'); // 运行时才加载
if (condition) {
  const utils = require('./utils'); // 可以条件加载
}

// ES Module - 编译时加载
import math from './math.js'; // 编译时就确定依赖
// if (condition) {
//   import utils from './utils.js'; // 语法错误
// }
```

#### 2. 值的拷贝 vs 值的引用

```javascript
// CommonJS - 值的拷贝
// lib.js
let counter = 0;
exports.counter = counter;
exports.increment = () => counter++;

// main.js
const lib = require('./lib');
console.log(lib.counter); // 0
lib.increment();
console.log(lib.counter); // 0 - 没有变化

// ES Module - 值的引用
// lib.js
export let counter = 0;
export function increment() {
  counter++;
}

// main.js
import { counter, increment } from './lib.js';
console.log(counter); // 0
increment();
console.log(counter); // 1 - 值更新了
```

#### 3. Tree Shaking

```javascript
// ES Module 支持 Tree Shaking
// utils.js
export function used() {
  return 'used';
}

export function unused() {
  return 'unused';
}

// main.js
import { used } from './utils.js';
// 打包时，unused 会被移除（Tree Shaking）

// CommonJS 不支持 Tree Shaking
const utils = require('./utils');
// 整个模块都会被打包
```

---

## 实际应用

### Node.js 中使用 ES Module

**方式 1：使用 .mjs 扩展名**

```javascript
// module.mjs
export function hello() {
  console.log('Hello');
}

// main.mjs
import { hello } from './module.mjs';
hello();
```

**方式 2：package.json 中设置 type**

```json
{
  "type": "module"
}
```

```javascript
// 现在 .js 文件默认是 ES Module
// module.js
export function hello() {
  console.log('Hello');
}

// main.js
import { hello } from './module.js';
hello();
```

### 浏览器中使用 ES Module

```html
<!DOCTYPE html>
<html>
<head>
  <title>ES Module Demo</title>
</head>
<body>
  <!-- type="module" 表示这是 ES Module -->
  <script type="module">
    import { add } from './math.js';
    console.log(add(2, 3));
  </script>

  <!-- 或者引入外部模块文件 -->
  <script type="module" src="./main.js"></script>
</body>
</html>
```

### 模块打包工具

现代前端开发通常使用打包工具来处理模块：

**Webpack**

```javascript
// webpack.config.js
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: __dirname + '/dist'
  }
};
```

**Vite**

```javascript
// vite.config.js
export default {
  build: {
    rollupOptions: {
      input: './src/main.js'
    }
  }
};
```

### 最佳实践

**1. 优先使用 ES Module**

- 现代浏览器和 Node.js 都支持
- 支持 Tree Shaking
- 更好的静态分析

**2. 明确导出接口**

```javascript
// ✅ 推荐：明确导出
export { add, subtract };

// ❌ 不推荐：导出整个对象
export default { add, subtract };
```

**3. 避免循环依赖**

```javascript
// 重构代码结构，避免循环依赖
// 或者将共享代码提取到第三个模块
```

**4. 使用命名导出而非默认导出**

```javascript
// ✅ 推荐：命名导出（便于重构和 IDE 支持）
export function add(a, b) {
  return a + b;
}

// ❌ 不推荐：默认导出（重命名困难）
export default function(a, b) {
  return a + b;
}
```

**5. 按需导入**

```javascript
// ✅ 推荐：只导入需要的
import { add } from './math.js';

// ❌ 不推荐：导入全部
import * as math from './math.js';
```

---

## 总结

### 关键要点

1. **模块化**是现代 JavaScript 开发的基础
2. **CommonJS** 主要用于 Node.js，同步加载，值的拷贝
3. **ES Module** 是官方标准，异步加载，值的引用
4. **动态导入** 可以实现按需加载和代码分割
5. **Tree Shaking** 只在 ES Module 中有效

### 选择建议

- **Node.js 项目**：优先使用 ES Module（Node.js 12+ 支持）
- **浏览器项目**：使用 ES Module + 打包工具
- **库开发**：同时提供 CommonJS 和 ES Module 版本
- **旧项目**：逐步迁移到 ES Module

### 常见陷阱

1. 混淆 `exports` 和 `module.exports`
2. 在 ES Module 中使用 `require`
3. 忘记在 HTML 中添加 `type="module"`
4. 循环依赖导致的问题
5. 动态导入路径必须是字符串字面量（不能是变量）
