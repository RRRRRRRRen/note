# JavaScript 设计模式

## 目录
- [设计模式概述](#设计模式概述)
- [创建型模式](#创建型模式)
- [结构型模式](#结构型模式)
- [行为型模式](#行为型模式)
- [设计原则](#设计原则)

---

## 设计模式概述

### 什么是设计模式

设计模式是软件开发中经过反复使用、多数人知晓、经过分类编目的代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

### 设计模式的分类

**1. 创建型模式（Creational Patterns）**
- 关注对象的创建过程
- 包括：单例、工厂、抽象工厂、建造者、原型

**2. 结构型模式（Structural Patterns）**
- 关注对象的组合和关系
- 包括：适配器、装饰器、代理、桥接、组合、外观、享元

**3. 行为型模式（Behavioral Patterns）**
- 关注对象之间的通信
- 包括：观察者、策略、命令、迭代器、职责链、模板方法、状态、访问者、中介者、备忘录、解释器

### 设计模式的优势

- **提高代码复用性**：避免重复造轮子
- **提高代码可读性**：统一的设计模式便于理解
- **提高代码可维护性**：结构清晰，易于修改
- **降低耦合度**：模块之间的依赖关系更清晰

---

## 创建型模式

### 1. 构造器模式（Constructor Pattern）

构造器模式是一种创建型设计模式，用于创建对象并初始化对象的属性和方法。

#### 基本实现

```javascript
// ES5 构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function() {
    console.log(`Hello, I'm ${this.name}`);
  };
}

const person1 = new Person('Alice', 25);
person1.sayHello(); // "Hello, I'm Alice"

// ES6 Class
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

const person2 = new Person('Bob', 30);
person2.sayHello(); // "Hello, I'm Bob"
```

#### 优缺点

**优点：**
- 简单直观，易于理解
- 可以创建多个实例

**缺点：**
- 每个实例都会创建方法的副本，浪费内存

#### 改进：使用原型

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// 方法定义在原型上，所有实例共享
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const person1 = new Person('Alice', 25);
const person2 = new Person('Bob', 30);

console.log(person1.sayHello === person2.sayHello); // true
```

### 2. 原型模式（Prototype Pattern）

原型模式通过复制（克隆）现有对象来创建新对象，而不是通过实例化类。

#### 使用 Object.create()

```javascript
// 原型对象
const carPrototype = {
  wheels: 4,
  engine: 'V6',
  color: 'white',

  start() {
    console.log('The car is starting...');
  },

  stop() {
    console.log('The car is stopping...');
  },

  getInfo() {
    return `Color: ${this.color}, Engine: ${this.engine}, Wheels: ${this.wheels}`;
  }
};

// 克隆原型对象
const myCar = Object.create(carPrototype);
myCar.color = 'blue';

const yourCar = Object.create(carPrototype);
yourCar.color = 'red';

console.log(myCar.getInfo()); // "Color: blue, Engine: V6, Wheels: 4"
console.log(yourCar.getInfo()); // "Color: red, Engine: V6, Wheels: 4"
```

#### 深拷贝实现

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (hash.has(obj)) return hash.get(obj);

  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }

  return cloneObj;
}

// 使用
const original = {
  name: 'Alice',
  hobbies: ['reading', 'coding'],
  address: { city: 'Beijing' }
};

const cloned = deepClone(original);
cloned.address.city = 'Shanghai';

console.log(original.address.city); // 'Beijing'
console.log(cloned.address.city); // 'Shanghai'
```

### 3. 工厂模式（Factory Pattern）

工厂模式通过一个工厂函数或类来封装对象的创建过程，避免直接使用构造函数。

#### 简单工厂

```javascript
// 产品类
class LineChart {
  render() {
    console.log('渲染折线图');
  }
}

class BarChart {
  render() {
    console.log('渲染柱状图');
  }
}

class PieChart {
  render() {
    console.log('渲染饼图');
  }
}

// 工厂类
class ChartFactory {
  static createChart(type) {
    switch (type) {
      case 'line':
        return new LineChart();
      case 'bar':
        return new BarChart();
      case 'pie':
        return new PieChart();
      default:
        throw new Error(`不支持的图表类型: ${type}`);
    }
  }
}

// 使用
const lineChart = ChartFactory.createChart('line');
lineChart.render(); // '渲染折线图'

const barChart = ChartFactory.createChart('bar');
barChart.render(); // '渲染柱状图'
```

#### 工厂方法模式

```javascript
// 抽象工厂类
class ChartFactory {
  createChart() {
    throw new Error('子类必须实现 createChart 方法');
  }
}

// 具体工厂类
class LineChartFactory extends ChartFactory {
  createChart() {
    return new LineChart();
  }
}

class BarChartFactory extends ChartFactory {
  createChart() {
    return new BarChart();
  }
}

// 使用
const lineFactory = new LineChartFactory();
const lineChart = lineFactory.createChart();
lineChart.render();
```

### 4. 抽象工厂模式（Abstract Factory Pattern）

抽象工厂模式提供一个接口，用于创建一系列相关或相互依赖的对象。

#### 完整示例

```javascript
// 抽象产品 - 按钮
class Button {
  render() {
    throw new Error('子类必须实现 render 方法');
  }
}

// 抽象产品 - 输入框
class Input {
  render() {
    throw new Error('子类必须实现 render 方法');
  }
}

// 具体产品 - Windows 按钮
class WindowsButton extends Button {
  render() {
    console.log('渲染 Windows 风格按钮');
  }
}

// 具体产品 - Windows 输入框
class WindowsInput extends Input {
  render() {
    console.log('渲染 Windows 风格输入框');
  }
}

// 具体产品 - Mac 按钮
class MacButton extends Button {
  render() {
    console.log('渲染 Mac 风格按钮');
  }
}

// 具体产品 - Mac 输入框
class MacInput extends Input {
  render() {
    console.log('渲染 Mac 风格输入框');
  }
}

// 抽象工厂
class UIFactory {
  createButton() {
    throw new Error('子类必须实现 createButton 方法');
  }

  createInput() {
    throw new Error('子类必须实现 createInput 方法');
  }
}

// 具体工厂 - Windows
class WindowsFactory extends UIFactory {
  createButton() {
    return new WindowsButton();
  }

  createInput() {
    return new WindowsInput();
  }
}

// 具体工厂 - Mac
class MacFactory extends UIFactory {
  createButton() {
    return new MacButton();
  }

  createInput() {
    return new MacInput();
  }
}

// 客户端代码
function renderUI(factory) {
  const button = factory.createButton();
  const input = factory.createInput();

  button.render();
  input.render();
}

// 使用
const windowsFactory = new WindowsFactory();
renderUI(windowsFactory);
// 渲染 Windows 风格按钮
// 渲染 Windows 风格输入框

const macFactory = new MacFactory();
renderUI(macFactory);
// 渲染 Mac 风格按钮
// 渲染 Mac 风格输入框
```

### 5. 建造者模式（Builder Pattern）

建造者模式用于创建复杂对象，将对象的构造过程拆分成多个步骤。

#### 基本实现

```javascript
// 产品类
class Computer {
  constructor() {
    this.cpu = '';
    this.memory = '';
    this.storage = '';
    this.gpu = '';
  }

  showSpecs() {
    console.log(`
      CPU: ${this.cpu}
      内存: ${this.memory}
      存储: ${this.storage}
      显卡: ${this.gpu}
    `);
  }
}

// 建造者类
class ComputerBuilder {
  constructor() {
    this.computer = new Computer();
  }

  setCPU(cpu) {
    this.computer.cpu = cpu;
    return this; // 支持链式调用
  }

  setMemory(memory) {
    this.computer.memory = memory;
    return this;
  }

  setStorage(storage) {
    this.computer.storage = storage;
    return this;
  }

  setGPU(gpu) {
    this.computer.gpu = gpu;
    return this;
  }

  build() {
    return this.computer;
  }
}

// 使用
const computer = new ComputerBuilder()
  .setCPU('Intel i7')
  .setMemory('16GB')
  .setStorage('512GB SSD')
  .setGPU('NVIDIA RTX 3060')
  .build();

computer.showSpecs();
```

#### 实际应用：HTML 构建器

```javascript
class HTMLBuilder {
  constructor() {
    this.html = '';
  }

  addTag(tag, content, attributes = {}) {
    const attrs = Object.entries(attributes)
      .map(([key, value]) => `${key}="${value}"`)
      .join(' ');

    this.html += `<${tag}${attrs ? ' ' + attrs : ''}>${content}</${tag}>`;
    return this;
  }

  addDiv(content, className) {
    return this.addTag('div', content, { class: className });
  }

  addParagraph(content) {
    return this.addTag('p', content);
  }

  addLink(text, href) {
    return this.addTag('a', text, { href });
  }

  build() {
    return this.html;
  }
}

// 使用
const html = new HTMLBuilder()
  .addDiv('标题', 'header')
  .addParagraph('这是一段文字')
  .addLink('点击这里', 'https://example.com')
  .build();

console.log(html);
```

### 6. 单例模式（Singleton Pattern）⭐

单例模式保证一个类只有一个实例，并提供一个全局访问点。

#### ES6 实现

```javascript
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }

    this.data = [];
    Singleton.instance = this;
  }

  addData(item) {
    this.data.push(item);
  }

  getData() {
    return this.data;
  }

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

// 使用
const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true

instance1.addData('item1');
console.log(instance2.getData()); // ['item1']
```

#### 闭包实现

```javascript
const Singleton = (function() {
  let instance;

  function createInstance() {
    return {
      data: [],
      addData(item) {
        this.data.push(item);
      },
      getData() {
        return this.data;
      }
    };
  }

  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// 使用
const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // true
```

#### 实际应用：全局状态管理

```javascript
class Store {
  constructor() {
    if (Store.instance) {
      return Store.instance;
    }

    this.state = {};
    this.listeners = [];
    Store.instance = this;
  }

  getState() {
    return this.state;
  }

  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.notify();
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notify() {
    this.listeners.forEach(listener => listener(this.state));
  }

  static getInstance() {
    if (!Store.instance) {
      Store.instance = new Store();
    }
    return Store.instance;
  }
}

// 使用
const store = Store.getInstance();

store.subscribe(state => {
  console.log('状态更新:', state);
});

store.setState({ user: 'Alice' });
store.setState({ count: 1 });
```

#### 实际应用：弹窗管理器

```javascript
class ModalManager {
  constructor() {
    if (ModalManager.instance) {
      return ModalManager.instance;
    }

    this.modals = [];
    this.currentModal = null;
    ModalManager.instance = this;
  }

  register(modal) {
    this.modals.push(modal);
  }

  show(modalId) {
    if (this.currentModal) {
      this.currentModal.hide();
    }

    const modal = this.modals.find(m => m.id === modalId);
    if (modal) {
      modal.show();
      this.currentModal = modal;
    }
  }

  hide() {
    if (this.currentModal) {
      this.currentModal.hide();
      this.currentModal = null;
    }
  }

  static getInstance() {
    if (!ModalManager.instance) {
      ModalManager.instance = new ModalManager();
    }
    return ModalManager.instance;
  }
}

// Modal 类
class Modal {
  constructor(id, content) {
    this.id = id;
    this.content = content;
    this.visible = false;
  }

  show() {
    this.visible = true;
    console.log(`显示弹窗: ${this.id}`);
  }

  hide() {
    this.visible = false;
    console.log(`隐藏弹窗: ${this.id}`);
  }
}

// 使用
const manager = ModalManager.getInstance();

const loginModal = new Modal('login', '登录表单');
const registerModal = new Modal('register', '注册表单');

manager.register(loginModal);
manager.register(registerModal);

manager.show('login'); // 显示弹窗: login
manager.show('register'); // 隐藏弹窗: login, 显示弹窗: register
```

---

## 结构型模式

### 1. 适配器模式（Adapter Pattern）

适配器模式用于将一个类的接口转换成客户端所期望的另一个接口。

#### 基本实现

```javascript
// 旧接口
class OldAPI {
  request() {
    return '旧接口返回的数据';
  }
}

// 新接口
class NewAPI {
  fetch() {
    return '新接口返回的数据';
  }
}

// 适配器
class APIAdapter {
  constructor(api) {
    this.api = api;
  }

  request() {
    // 将新接口的 fetch 方法适配为 request 方法
    return this.api.fetch();
  }
}

// 使用
const oldAPI = new OldAPI();
console.log(oldAPI.request()); // '旧接口返回的数据'

const newAPI = new NewAPI();
const adapter = new APIAdapter(newAPI);
console.log(adapter.request()); // '新接口返回的数据'
```

#### 实际应用：第三方库适配

```javascript
// 第三方日志库
class ThirdPartyLogger {
  logMessage(level, message) {
    console.log(`[${level.toUpperCase()}] ${message}`);
  }
}

// 我们的日志接口
class Logger {
  info(message) {
    throw new Error('子类必须实现 info 方法');
  }

  error(message) {
    throw new Error('子类必须实现 error 方法');
  }
}

// 适配器
class LoggerAdapter extends Logger {
  constructor() {
    super();
    this.thirdPartyLogger = new ThirdPartyLogger();
  }

  info(message) {
    this.thirdPartyLogger.logMessage('info', message);
  }

  error(message) {
    this.thirdPartyLogger.logMessage('error', message);
  }
}

// 使用
const logger = new LoggerAdapter();
logger.info('这是一条信息'); // [INFO] 这是一条信息
logger.error('这是一条错误'); // [ERROR] 这是一条错误
```

### 2. 装饰器模式（Decorator Pattern）

装饰器模式允许在不改变对象自身结构的情况下，动态地给对象添加额外的功能。

#### 基本实现

```javascript
// 基础组件
class Coffee {
  cost() {
    return 10;
  }

  description() {
    return '咖啡';
  }
}

// 装饰器基类
class CoffeeDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost();
  }

  description() {
    return this.coffee.description();
  }
}

// 具体装饰器 - 牛奶
class MilkDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 2;
  }

  description() {
    return this.coffee.description() + ' + 牛奶';
  }
}

// 具体装饰器 - 糖
class SugarDecorator extends CoffeeDecorator {
  cost() {
    return this.coffee.cost() + 1;
  }

  description() {
    return this.coffee.description() + ' + 糖';
  }
}

// 使用
let coffee = new Coffee();
console.log(coffee.description(), coffee.cost()); // '咖啡' 10

coffee = new MilkDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // '咖啡 + 牛奶' 12

coffee = new SugarDecorator(coffee);
console.log(coffee.description(), coffee.cost()); // '咖啡 + 牛奶 + 糖' 13
```

#### ES7 装饰器语法

```javascript
// 类装饰器
function readonly(target) {
  target.prototype.readonly = true;
  return target;
}

@readonly
class Person {
  constructor(name) {
    this.name = name;
  }
}

// 方法装饰器
function log(target, name, descriptor) {
  const original = descriptor.value;

  descriptor.value = function(...args) {
    console.log(`调用 ${name} 方法，参数:`, args);
    const result = original.apply(this, args);
    console.log(`${name} 方法返回:`, result);
    return result;
  };

  return descriptor;
}

class Calculator {
  @log
  add(a, b) {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3);
// 调用 add 方法，参数: [2, 3]
// add 方法返回: 5
```

### 3. 代理模式（Proxy Pattern）⭐

代理模式提供一个代理对象，用于控制对其他对象的访问。

#### 虚拟代理

```javascript
// 图片加载类
class Image {
  constructor(src) {
    this.src = src;
    this.load();
  }

  load() {
    console.log(`加载图片: ${this.src}`);
  }

  display() {
    console.log(`显示图片: ${this.src}`);
  }
}

// 图片代理类
class ImageProxy {
  constructor(src) {
    this.src = src;
    this.image = null;
  }

  display() {
    if (!this.image) {
      console.log('显示占位图');
      // 异步加载真实图片
      setTimeout(() => {
        this.image = new Image(this.src);
        this.image.display();
      }, 2000);
    } else {
      this.image.display();
    }
  }
}

// 使用
const imageProxy = new ImageProxy('https://example.com/image.jpg');
imageProxy.display(); // 显示占位图
// 2秒后: 加载图片: https://example.com/image.jpg
//        显示图片: https://example.com/image.jpg
```

#### 缓存代理

```javascript
// 计算函数
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// 缓存代理
function createCacheProxy(fn) {
  const cache = new Map();

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log('从缓存读取');
      return cache.get(key);
    }

    console.log('计算结果');
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 使用
const cachedFibonacci = createCacheProxy(fibonacci);

console.log(cachedFibonacci(10)); // 计算结果 55
console.log(cachedFibonacci(10)); // 从缓存读取 55
```

#### ES6 Proxy

```javascript
// 数据验证代理
const validator = {
  set(target, property, value) {
    if (property === 'age') {
      if (typeof value !== 'number' || value < 0 || value > 150) {
        throw new Error('年龄必须是 0-150 之间的数字');
      }
    }

    target[property] = value;
    return true;
  }
};

const person = new Proxy({}, validator);

person.age = 25; // 正常
console.log(person.age); // 25

// person.age = -1; // Error: 年龄必须是 0-150 之间的数字
// person.age = 'abc'; // Error: 年龄必须是 0-150 之间的数字
```

---

## 行为型模式

### 1. 观察者模式（Observer Pattern）⭐

观察者模式定义了对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知。

#### 基本实现

```javascript
// 主题（被观察者）
class Subject {
  constructor() {
    this.observers = [];
  }

  // 添加观察者
  attach(observer) {
    this.observers.push(observer);
  }

  // 移除观察者
  detach(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  // 通知所有观察者
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

// 观察者
class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} 收到通知:`, data);
  }
}

// 使用
const subject = new Subject();

const observer1 = new Observer('观察者1');
const observer2 = new Observer('观察者2');

subject.attach(observer1);
subject.attach(observer2);

subject.notify('状态改变了');
// 观察者1 收到通知: 状态改变了
// 观察者2 收到通知: 状态改变了
```

#### 实际应用：事件系统

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  off(event, listener) {
    if (!this.events[event]) return;

    this.events[event] = this.events[event].filter(l => l !== listener);
  }

  emit(event, ...args) {
    if (!this.events[event]) return;

    this.events[event].forEach(listener => {
      listener.apply(this, args);
    });
  }

  once(event, listener) {
    const wrapper = (...args) => {
      listener.apply(this, args);
      this.off(event, wrapper);
    };
    this.on(event, wrapper);
  }
}

// 使用
const emitter = new EventEmitter();

emitter.on('data', data => {
  console.log('收到数据:', data);
});

emitter.emit('data', { id: 1, name: 'Alice' });
// 收到数据: { id: 1, name: 'Alice' }
```

### 2. 发布-订阅模式（Pub-Sub Pattern）⭐

发布-订阅模式是观察者模式的一种变体，通过事件中心解耦发布者和订阅者。

#### 完整实现

```javascript
class PubSub {
  constructor() {
    this.events = {};
  }

  // 订阅
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }

    this.events[event].push(callback);

    // 返回取消订阅函数
    return () => {
      this.unsubscribe(event, callback);
    };
  }

  // 发布
  publish(event, ...args) {
    if (!this.events[event]) return;

    this.events[event].forEach(callback => {
      callback(...args);
    });
  }

  // 取消订阅
  unsubscribe(event, callback) {
    if (!this.events[event]) return;

    if (!callback) {
      // 取消该事件的所有订阅
      delete this.events[event];
    } else {
      // 取消特定回调
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

// 使用
const pubsub = new PubSub();

// 订阅
const unsubscribe1 = pubsub.subscribe('login', user => {
  console.log('用户登录:', user);
});

pubsub.subscribe('login', user => {
  console.log('记录日志:', user);
});

// 发布
pubsub.publish('login', { name: 'Alice' });
// 用户登录: { name: 'Alice' }
// 记录日志: { name: 'Alice' }

// 取消订阅
unsubscribe1();
pubsub.publish('login', { name: 'Bob' });
// 记录日志: { name: 'Bob' }
```

#### 观察者模式 vs 发布-订阅模式

| 特性 | 观察者模式 | 发布-订阅模式 |
|------|-----------|--------------|
| 耦合度 | 观察者和主题直接关联 | 通过事件中心解耦 |
| 灵活性 | 较低 | 较高 |
| 复杂度 | 简单 | 稍复杂 |
| 适用场景 | 对象间直接通信 | 跨模块通信 |

### 3. 策略模式（Strategy Pattern）

策略模式定义一系列算法，将每个算法封装起来，使它们可以相互替换。

#### 基本实现

```javascript
// 策略类
class DiscountStrategy {
  calculate(price) {
    throw new Error('子类必须实现 calculate 方法');
  }
}

class NoDiscount extends DiscountStrategy {
  calculate(price) {
    return price;
  }
}

class PercentDiscount extends DiscountStrategy {
  constructor(percent) {
    super();
    this.percent = percent;
  }

  calculate(price) {
    return price * (1 - this.percent);
  }
}

class FixedDiscount extends DiscountStrategy {
  constructor(amount) {
    super();
    this.amount = amount;
  }

  calculate(price) {
    return Math.max(0, price - this.amount);
  }
}

// 上下文类
class ShoppingCart {
  constructor(strategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy) {
    this.strategy = strategy;
  }

  checkout(price) {
    return this.strategy.calculate(price);
  }
}

// 使用
const cart = new ShoppingCart(new NoDiscount());
console.log(cart.checkout(100)); // 100

cart.setStrategy(new PercentDiscount(0.2));
console.log(cart.checkout(100)); // 80

cart.setStrategy(new FixedDiscount(15));
console.log(cart.checkout(100)); // 85
```

#### 简化版本

```javascript
// 策略对象
const strategies = {
  S: salary => salary * 6,
  A: salary => salary * 4,
  B: salary => salary * 3
};

// 计算奖金
function calculateBonus(level, salary) {
  return strategies[level](salary);
}

console.log(calculateBonus('S', 10000)); // 60000
console.log(calculateBonus('A', 10000)); // 40000
```

#### 实际应用：表单验证

```javascript
// 验证策略
const validators = {
  required: (value, errorMsg) => {
    if (!value) return errorMsg || '该字段不能为空';
    return '';
  },

  minLength: (value, length, errorMsg) => {
    if (value.length < length) {
      return errorMsg || `长度不能少于${length}个字符`;
    }
    return '';
  },

  email: (value, errorMsg) => {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!regex.test(value)) {
      return errorMsg || '邮箱格式不正确';
    }
    return '';
  },

  phone: (value, errorMsg) => {
    const regex = /^1[3-9]\d{9}$/;
    if (!regex.test(value)) {
      return errorMsg || '手机号格式不正确';
    }
    return '';
  }
};

// 验证器类
class Validator {
  constructor() {
    this.rules = [];
  }

  add(value, rules) {
    rules.forEach(rule => {
      const [strategy, ...args] = rule.split(':');
      this.rules.push(() => {
        return validators[strategy](value, ...args);
      });
    });
  }

  validate() {
    for (let rule of this.rules) {
      const error = rule();
      if (error) return error;
    }
    return '';
  }
}

// 使用
const validator = new Validator();
validator.add('', ['required:用户名不能为空', 'minLength:3:用户名至少3个字符']);

const error = validator.validate();
console.log(error); // '用户名不能为空'
```

### 4. 命令模式（Command Pattern）

命令模式将请求封装成对象，从而可以用不同的请求对客户进行参数化。

#### 基本实现

```javascript
// 接收者
class Light {
  on() {
    console.log('灯打开了');
  }

  off() {
    console.log('灯关闭了');
  }
}

// 命令接口
class Command {
  execute() {
    throw new Error('子类必须实现 execute 方法');
  }

  undo() {
    throw new Error('子类必须实现 undo 方法');
  }
}

// 具体命令
class LightOnCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }

  execute() {
    this.light.on();
  }

  undo() {
    this.light.off();
  }
}

class LightOffCommand extends Command {
  constructor(light) {
    super();
    this.light = light;
  }

  execute() {
    this.light.off();
  }

  undo() {
    this.light.on();
  }
}

// 调用者
class RemoteControl {
  constructor() {
    this.command = null;
    this.history = [];
  }

  setCommand(command) {
    this.command = command;
  }

  pressButton() {
    this.command.execute();
    this.history.push(this.command);
  }

  pressUndo() {
    if (this.history.length > 0) {
      const command = this.history.pop();
      command.undo();
    }
  }
}

// 使用
const light = new Light();
const lightOn = new LightOnCommand(light);
const lightOff = new LightOffCommand(light);

const remote = new RemoteControl();

remote.setCommand(lightOn);
remote.pressButton(); // 灯打开了

remote.setCommand(lightOff);
remote.pressButton(); // 灯关闭了

remote.pressUndo(); // 灯打开了
```

### 5. 迭代器模式（Iterator Pattern）

迭代器模式提供一种方法顺序访问聚合对象中的各个元素，而不暴露其内部表示。

#### 基本实现

```javascript
class Iterator {
  constructor(items) {
    this.items = items;
    this.index = 0;
  }

  hasNext() {
    return this.index < this.items.length;
  }

  next() {
    return this.items[this.index++];
  }

  reset() {
    this.index = 0;
  }
}

// 使用
const iterator = new Iterator([1, 2, 3, 4, 5]);

while (iterator.hasNext()) {
  console.log(iterator.next());
}
// 1 2 3 4 5
```

#### ES6 迭代器

```javascript
// 自定义可迭代对象
class Range {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }

  [Symbol.iterator]() {
    let current = this.start;
    const end = this.end;

    return {
      next() {
        if (current <= end) {
          return { value: current++, done: false };
        }
        return { done: true };
      }
    };
  }
}

// 使用
const range = new Range(1, 5);

for (let num of range) {
  console.log(num);
}
// 1 2 3 4 5

// 使用扩展运算符
console.log([...range]); // [1, 2, 3, 4, 5]
```

### 6. 职责链模式（Chain of Responsibility）

职责链模式使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。

#### 基本实现

```javascript
// 处理器基类
class Handler {
  constructor() {
    this.nextHandler = null;
  }

  setNext(handler) {
    this.nextHandler = handler;
    return handler; // 支持链式调用
  }

  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

// 具体处理器
class AuthHandler extends Handler {
  handle(request) {
    if (!request.isAuthenticated) {
      console.log('认证失败');
      return false;
    }
    console.log('认证通过');
    return super.handle(request);
  }
}

class ValidationHandler extends Handler {
  handle(request) {
    if (!request.isValid) {
      console.log('验证失败');
      return false;
    }
    console.log('验证通过');
    return super.handle(request);
  }
}

class ProcessHandler extends Handler {
  handle(request) {
    console.log('处理请求');
    return true;
  }
}

// 使用
const auth = new AuthHandler();
const validation = new ValidationHandler();
const process = new ProcessHandler();

auth.setNext(validation).setNext(process);

// 测试
auth.handle({ isAuthenticated: true, isValid: true });
// 认证通过
// 验证通过
// 处理请求
```

### 7. 模板方法模式（Template Method）

模板方法模式定义一个操作中的算法骨架，将一些步骤延迟到子类中。

#### 基本实现

```javascript
// 抽象类
class Beverage {
  // 模板方法
  prepare() {
    this.boilWater();
    this.brew();
    this.pourInCup();
    if (this.customerWantsCondiments()) {
      this.addCondiments();
    }
  }

  boilWater() {
    console.log('煮沸水');
  }

  brew() {
    throw new Error('子类必须实现 brew 方法');
  }

  pourInCup() {
    throw new Error('子类必须实现 pourInCup 方法');
  }

  addCondiments() {
    throw new Error('子类必须实现 addCondiments 方法');
  }

  // 钩子方法
  customerWantsCondiments() {
    return true;
  }
}

// 具体类 - 咖啡
class Coffee extends Beverage {
  brew() {
    console.log('用沸水冲泡咖啡');
  }

  pourInCup() {
    console.log('把咖啡倒进杯子');
  }

  addCondiments() {
    console.log('加糖和牛奶');
  }
}

// 具体类 - 茶
class Tea extends Beverage {
  brew() {
    console.log('用沸水浸泡茶叶');
  }

  pourInCup() {
    console.log('把茶倒进杯子');
  }

  addCondiments() {
    console.log('加柠檬');
  }

  customerWantsCondiments() {
    return false; // 不加调料
  }
}

// 使用
const coffee = new Coffee();
coffee.prepare();
// 煮沸水
// 用沸水冲泡咖啡
// 把咖啡倒进杯子
// 加糖和牛奶

const tea = new Tea();
tea.prepare();
// 煮沸水
// 用沸水浸泡茶叶
// 把茶倒进杯子
```

---

## 设计原则

### SOLID 原则

#### 1. 单一职责原则（Single Responsibility Principle）

一个类应该只有一个引起它变化的原因。

```javascript
// ❌ 违反单一职责
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  save() {
    // 保存到数据库
  }

  sendEmail() {
    // 发送邮件
  }
}

// ✅ 遵循单一职责
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
}

class UserRepository {
  save(user) {
    // 保存到数据库
  }
}

class EmailService {
  send(user, message) {
    // 发送邮件
  }
}
```

#### 2. 开放封闭原则（Open-Closed Principle）

软件实体应该对扩展开放，对修改封闭。

```javascript
// ❌ 违反开放封闭
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
}

class AreaCalculator {
  calculate(shapes) {
    let area = 0;
    shapes.forEach(shape => {
      if (shape instanceof Rectangle) {
        area += shape.width * shape.height;
      }
      // 添加新形状需要修改这里
    });
    return area;
  }
}

// ✅ 遵循开放封闭
class Shape {
  area() {
    throw new Error('子类必须实现 area 方法');
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius ** 2;
  }
}

class AreaCalculator {
  calculate(shapes) {
    return shapes.reduce((total, shape) => total + shape.area(), 0);
  }
}
```

#### 3. 里氏替换原则（Liskov Substitution Principle）

子类对象应该能够替换父类对象，而程序逻辑不变。

```javascript
// ✅ 遵循里氏替换
class Bird {
  fly() {
    console.log('飞行');
  }
}

class Sparrow extends Bird {
  fly() {
    console.log('麻雀飞行');
  }
}

function makeBirdFly(bird) {
  bird.fly();
}

makeBirdFly(new Bird()); // 飞行
makeBirdFly(new Sparrow()); // 麻雀飞行
```

#### 4. 接口隔离原则（Interface Segregation Principle）

客户端不应该依赖它不需要的接口。

```javascript
// ❌ 违反接口隔离
class Worker {
  work() {}
  eat() {}
  sleep() {}
}

class Robot extends Worker {
  work() {
    console.log('机器人工作');
  }
  eat() {
    // 机器人不需要吃饭
  }
  sleep() {
    // 机器人不需要睡觉
  }
}

// ✅ 遵循接口隔离
class Workable {
  work() {
    throw new Error('必须实现 work 方法');
  }
}

class Eatable {
  eat() {
    throw new Error('必须实现 eat 方法');
  }
}

class Human extends Workable {
  work() {
    console.log('人类工作');
  }
}

class Robot extends Workable {
  work() {
    console.log('机器人工作');
  }
}
```

#### 5. 依赖倒置原则（Dependency Inversion Principle）

高层模块不应该依赖低层模块，两者都应该依赖抽象。

```javascript
// ❌ 违反依赖倒置
class MySQLDatabase {
  save(data) {
    console.log('保存到 MySQL');
  }
}

class UserService {
  constructor() {
    this.database = new MySQLDatabase(); // 直接依赖具体实现
  }

  saveUser(user) {
    this.database.save(user);
  }
}

// ✅ 遵循依赖倒置
class Database {
  save(data) {
    throw new Error('必须实现 save 方法');
  }
}

class MySQLDatabase extends Database {
  save(data) {
    console.log('保存到 MySQL');
  }
}

class MongoDatabase extends Database {
  save(data) {
    console.log('保存到 MongoDB');
  }
}

class UserService {
  constructor(database) {
    this.database = database; // 依赖抽象
  }

  saveUser(user) {
    this.database.save(user);
  }
}

// 使用
const mysqlDB = new MySQLDatabase();
const userService = new UserService(mysqlDB);
```

### 其他重要原则

#### 1. 最少知识原则（迪米特法则）

一个对象应该对其他对象有最少的了解。

```javascript
// ❌ 违反最少知识原则
class Wallet {
  constructor(money) {
    this.money = money;
  }

  getMoney() {
    return this.money;
  }

  setMoney(money) {
    this.money = money;
  }
}

class Person {
  constructor(wallet) {
    this.wallet = wallet;
  }

  getWallet() {
    return this.wallet;
  }
}

// 客户端需要了解 Person 和 Wallet
const person = new Person(new Wallet(100));
const money = person.getWallet().getMoney();

// ✅ 遵循最少知识原则
class Person {
  constructor(wallet) {
    this.wallet = wallet;
  }

  getMoney() {
    return this.wallet.getMoney();
  }

  pay(amount) {
    const money = this.wallet.getMoney();
    if (money >= amount) {
      this.wallet.setMoney(money - amount);
      return true;
    }
    return false;
  }
}

// 客户端只需要了解 Person
const person = new Person(new Wallet(100));
person.pay(50);
```

#### 2. 合成复用原则

优先使用对象组合，而不是继承。

```javascript
// ❌ 使用继承
class Animal {
  eat() {
    console.log('吃东西');
  }
}

class FlyingAnimal extends Animal {
  fly() {
    console.log('飞行');
  }
}

// ✅ 使用组合
class Eatable {
  eat() {
    console.log('吃东西');
  }
}

class Flyable {
  fly() {
    console.log('飞行');
  }
}

class Bird {
  constructor() {
    this.eatable = new Eatable();
    this.flyable = new Flyable();
  }

  eat() {
    this.eatable.eat();
  }

  fly() {
    this.flyable.fly();
  }
}
```

---

## 总结

### 设计模式选择指南

| 场景 | 推荐模式 |
|------|---------|
| 需要全局唯一实例 | 单例模式 |
| 创建复杂对象 | 建造者模式、工厂模式 |
| 动态添加功能 | 装饰器模式 |
| 接口不兼容 | 适配器模式 |
| 控制对象访问 | 代理模式 |
| 对象间一对多依赖 | 观察者模式 |
| 算法可互换 | 策略模式 |
| 请求封装为对象 | 命令模式 |

### 最佳实践

1. **不要过度设计**：只在需要时使用设计模式
2. **理解问题本质**：选择合适的模式解决问题
3. **保持简单**：简单的解决方案往往更好
4. **遵循设计原则**：SOLID 原则是基础
5. **代码可读性**：设计模式应该提高而不是降低可读性

### 常见误区

1. 为了使用设计模式而使用
2. 过度抽象导致代码复杂
3. 忽视性能影响
4. 不考虑团队理解成本
5. 生搬硬套其他语言的实现
