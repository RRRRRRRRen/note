# 原型与继承

## 目录

- [面向对象编程](#面向对象编程)
- [对象的分类](#对象的分类)
- [原型基础](#原型基础)
- [原型链](#原型链)
- [继承](#继承)
- [ES6 Class](#es6-class)

---

## 面向对象编程

### 面向对象的三大特性

#### 1. 封装性

将数据和操作数据的方法封装在一起，隐藏内部实现细节，只暴露必要的接口。

```javascript
// 封装示例
function Person(name, age) {
  // 私有变量
  let _age = age;

  // 公共属性
  this.name = name;

  // 公共方法
  this.getName = function() {
    return this.name;
  };

  // 访问私有变量的方法
  this.getAge = function() {
    return _age;
  };

  this.setAge = function(newAge) {
    if (newAge > 0 && newAge < 150) {
      _age = newAge;
    }
  };
}

const person = new Person('Alice', 25);
console.log(person.name); // 'Alice'
console.log(person._age); // undefined (私有变量无法直接访问)
console.log(person.getAge()); // 25
```

#### 2. 继承性

子类可以继承父类的属性和方法，实现代码复用。

```javascript
// 继承示例
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

function Dog(name, breed) {
  Animal.call(this, name); // 继承属性
  this.breed = breed;
}

// 继承方法
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(`${this.name} is barking`);
};

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat(); // 'Buddy is eating' (继承自 Animal)
dog.bark(); // 'Buddy is barking'
```

#### 3. 多态性

同一个方法在不同对象中有不同的实现，允许不同类的对象对同一消息做出响应。

```javascript
// 多态示例
function Animal(name) {
  this.name = name;
}

Animal.prototype.makeSound = function() {
  console.log('Some sound');
};

function Dog(name) {
  Animal.call(this, name);
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.makeSound = function() {
  console.log(`${this.name}: Woof!`);
};

function Cat(name) {
  Animal.call(this, name);
}

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.makeSound = function() {
  console.log(`${this.name}: Meow!`);
};

// 多态体现
const animals = [
  new Dog('Buddy'),
  new Cat('Whiskers'),
  new Animal('Generic')
];

animals.forEach(animal => animal.makeSound());
// Buddy: Woof!
// Whiskers: Meow!
// Some sound
```

### 面向对象编程的优势

- **灵活性**：通过继承和多态实现代码的灵活扩展
- **可复用性**：通过继承避免重复代码
- **易维护**：封装使得代码结构清晰，便于维护
- **适合大型项目**：更适合多人协作的大型软件开发

---

## 对象的分类

### 原生对象（Native Objects）

由 ECMAScript 规范定义的对象，独立于宿主环境。

**包括：**

- `Object`、`Function`、`Array`、`String`、`Boolean`、`Number`
- `Date`、`RegExp`、`Error`
- `EvalError`、`RangeError`、`ReferenceError`、`SyntaxError`、`TypeError`、`URIError`

```javascript
// 原生对象示例
const obj = new Object();
const arr = new Array();
const str = new String('hello');
const num = new Number(42);
const date = new Date();
const regex = new RegExp('\\d+');
```

### 内置对象（Built-in Objects）

由 JavaScript 引擎内部实例化的对象，开发者无需显式创建。

**包括：**

- `Global`（在浏览器中是 `window`）
- `Math`
- `JSON`
- `Reflect`
- `Proxy`

```javascript
// 内置对象示例
console.log(Math.PI); // 3.141592653589793
console.log(Math.max(1, 2, 3)); // 3

const obj = { name: 'Alice' };
console.log(JSON.stringify(obj)); // '{"name":"Alice"}'
```

### 宿主对象（Host Objects）

由宿主环境（如浏览器、Node.js）提供的对象。

**浏览器环境：**

- BOM（Browser Object Model）：`window`、`navigator`、`location`、`history`、`screen`
- DOM（Document Object Model）：`document`、`Element`、`Node`

```javascript
// 宿主对象示例（浏览器环境）
console.log(window.innerWidth);
console.log(navigator.userAgent);
console.log(document.title);

const div = document.createElement('div');
```

---

## 原型基础

### 什么是原型对象 ⭐

**概念：**
每个函数都有一个 `prototype` 属性，这个属性指向一个对象，这个对象就是原型对象。原型对象包含了可以由该构造函数的所有实例共享的属性和方法。

**关键属性：**

- `prototype`：函数对象的原型对象
- `__proto__`：对象的原型指针（指向构造函数的 prototype）
- `constructor`：原型对象的构造函数引用

```javascript
function Person(name) {
  this.name = name;
}

// 在原型上添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const alice = new Person('Alice');
const bob = new Person('Bob');

// 实例共享原型上的方法
alice.sayHello(); // "Hello, I'm Alice"
bob.sayHello(); // "Hello, I'm Bob"

// 验证原型关系
console.log(alice.__proto__ === Person.prototype); // true
console.log(Person.prototype.constructor === Person); // true
```

### 原型的三个关键概念 ⭐

#### 1. prototype（原型对象）

- 每个**函数**都有 `prototype` 属性
- `prototype` 是一个对象，包含共享的属性和方法
- 实例对象可以访问原型对象上的属性和方法

```javascript
function Animal(name) {
  this.name = name;
}

// 在原型上添加方法
Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

console.log(typeof Animal.prototype); // 'object'
console.log(Animal.prototype.constructor === Animal); // true
```

#### 2. **proto**（原型指针）

- 每个**对象**都有 `__proto__` 属性
- `__proto__` 指向创建该对象的构造函数的 `prototype`
- `__proto__` 是原型链的关键

```javascript
const animal = new Animal('Dog');

console.log(animal.__proto__ === Animal.prototype); // true
console.log(animal.__proto__.constructor === Animal); // true

// 推荐使用 Object.getPrototypeOf() 代替 __proto__
console.log(Object.getPrototypeOf(animal) === Animal.prototype); // true
```

#### 3. constructor（构造函数）

- 原型对象的 `constructor` 属性指向构造函数本身
- 实例可以通过原型链访问 `constructor`

```javascript
console.log(Animal.prototype.constructor === Animal); // true
console.log(animal.constructor === Animal); // true

// 可以通过 constructor 创建新实例
const anotherAnimal = new animal.constructor('Cat');
console.log(anotherAnimal.name); // 'Cat'
```

### 原型关系图解

```javascript
function Person(name) {
  this.name = name;
}

const person = new Person('Alice');

// 关系链：
// person.__proto__ === Person.prototype
// Person.prototype.constructor === Person
// Person.__proto__ === Function.prototype
// Function.prototype.__proto__ === Object.prototype
// Object.prototype.__proto__ === null
```

**关系验证：**

```javascript
console.log(person.__proto__ === Person.prototype); // true
console.log(Person.prototype.constructor === Person); // true
console.log(Person.__proto__ === Function.prototype); // true
console.log(Function.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

### 函数对象 vs 普通对象

```javascript
// 函数对象：有 prototype 属性
function MyFunction() {}
console.log(typeof MyFunction.prototype); // 'object'
console.log(MyFunction.__proto__ === Function.prototype); // true

// 普通对象：没有 prototype 属性
const obj = {};
console.log(obj.prototype); // undefined
console.log(obj.__proto__ === Object.prototype); // true

// 特殊情况：箭头函数没有 prototype
const arrowFunc = () => {};
console.log(arrowFunc.prototype); // undefined
```

### 原型的动态性

原型上的属性和方法可以动态添加，所有实例都能立即访问。

```javascript
function Person(name) {
  this.name = name;
}

const alice = new Person('Alice');

// 动态添加方法
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

// 已创建的实例也能访问新添加的方法
alice.sayHello(); // "Hello, I'm Alice"

// 但是重写整个 prototype 会断开已有实例的连接
Person.prototype = {
  sayGoodbye: function() {
    console.log('Goodbye');
  }
};

const bob = new Person('Bob');
bob.sayGoodbye(); // 'Goodbye' (新实例可以访问)
alice.sayGoodbye(); // TypeError (旧实例无法访问)
```

---

## 原型链

### 什么是原型链 ⭐

**概念：**
原型链是 JavaScript 实现继承的主要机制。当访问一个对象的属性时，如果对象本身没有这个属性，JavaScript 会沿着原型链向上查找，直到找到该属性或到达原型链的终点（`null`）。

**查找规则：**

1. 首先在对象自身查找属性
2. 如果没有找到，在对象的原型（`__proto__`）中查找
3. 如果还没有找到，继续在原型的原型中查找
4. 一直查找到 `Object.prototype`
5. 如果还没有找到，返回 `undefined`

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.species = 'Human';

const alice = new Person('Alice');

// 属性查找过程
console.log(alice.name); // 'Alice' - 在实例自身找到
console.log(alice.species); // 'Human' - 在原型上找到
console.log(alice.toString()); // '[object Object]' - 在 Object.prototype 上找到
console.log(alice.notExist); // undefined - 原型链上都没有
```

### 原型链的终点

原型链的终点是 `null`，即 `Object.prototype.__proto__ === null`。

```javascript
console.log(Object.prototype.__proto__); // null

// 完整的原型链
function Person() {}
const person = new Person();

console.log(person.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

### 原型链示例

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

// 建立原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(`${this.name} is barking`);
};

const dog = new Dog('Buddy', 'Golden Retriever');

// 原型链查找
console.log(dog.name); // 'Buddy' - 实例属性
console.log(dog.breed); // 'Golden Retriever' - 实例属性
dog.bark(); // 'Buddy is barking' - Dog.prototype
dog.eat(); // 'Buddy is eating' - Animal.prototype
console.log(dog.toString()); // '[object Object]' - Object.prototype

// 原型链结构
console.log(dog.__proto__ === Dog.prototype); // true
console.log(Dog.prototype.__proto__ === Animal.prototype); // true
console.log(Animal.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

### 属性查找的性能考虑

原型链越长，属性查找的性能越差。

```javascript
// 检查属性是否在对象自身
console.log(dog.hasOwnProperty('name')); // true
console.log(dog.hasOwnProperty('eat')); // false

// 检查属性是否在原型链上
console.log('name' in dog); // true
console.log('eat' in dog); // true
console.log('toString' in dog); // true
```

### 原型链的应用

#### 1. 判断对象类型

```javascript
function Person() {}
const person = new Person();

// instanceof 检查原型链
console.log(person instanceof Person); // true
console.log(person instanceof Object); // true

// isPrototypeOf 检查原型关系
console.log(Person.prototype.isPrototypeOf(person)); // true
console.log(Object.prototype.isPrototypeOf(person)); // true
```

#### 2. 获取和设置原型

```javascript
const obj = { a: 1 };

// 获取原型
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// 设置原型
const proto = { b: 2 };
Object.setPrototypeOf(obj, proto);
console.log(obj.b); // 2

// 创建指定原型的对象
const newObj = Object.create(proto);
console.log(newObj.b); // 2
```

---

## 继承

### JavaScript 继承的方式

#### 1. 原型链继承

通过将子类的原型指向父类的实例来实现继承。

```javascript
function Parent() {
  this.name = 'Parent';
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child() {
  this.age = 18;
}

// 原型链继承
Child.prototype = new Parent();

const child1 = new Child();
const child2 = new Child();

console.log(child1.getName()); // 'Parent'

// ❌ 缺点 1：引用类型的属性被所有实例共享
child1.colors.push('yellow');
console.log(child2.colors); // ['red', 'blue', 'green', 'yellow']

// ❌ 缺点 2：创建子类实例时，无法向父类构造函数传参
```

**优点：**

- 简单易实现
- 可以继承父类原型上的方法

**缺点：**

- 引用类型的属性被所有实例共享
- 无法向父类构造函数传参

#### 2. 构造函数继承（经典继承）

在子类构造函数中调用父类构造函数。

```javascript
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 构造函数继承
  Parent.call(this, name);
  this.age = age;
}

const child1 = new Child('Alice', 18);
const child2 = new Child('Bob', 20);

// ✅ 优点 1：避免了引用类型的属性被所有实例共享
child1.colors.push('yellow');
console.log(child1.colors); // ['red', 'blue', 'green', 'yellow']
console.log(child2.colors); // ['red', 'blue', 'green']

// ✅ 优点 2：可以向父类传参
console.log(child1.name); // 'Alice'
console.log(child2.name); // 'Bob'

// ❌ 缺点：无法继承父类原型上的方法
console.log(child1.getName); // undefined
```

**优点：**

- 避免引用类型的属性被所有实例共享
- 可以向父类构造函数传参

**缺点：**

- 无法继承父类原型上的方法
- 每次创建实例都会创建一遍方法

#### 3. 组合继承（推荐）⭐

结合原型链继承和构造函数继承。

```javascript
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 构造函数继承：继承属性
  Parent.call(this, name);
  this.age = age;
}

// 原型链继承：继承方法
Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child('Alice', 18);
const child2 = new Child('Bob', 20);

// ✅ 避免引用类型共享
child1.colors.push('yellow');
console.log(child1.colors); // ['red', 'blue', 'green', 'yellow']
console.log(child2.colors); // ['red', 'blue', 'green']

// ✅ 可以传参
console.log(child1.name); // 'Alice'

// ✅ 可以继承原型方法
console.log(child1.getName()); // 'Alice'

// ❌ 缺点：调用了两次父类构造函数
```

**优点：**

- 结合了原型链继承和构造函数继承的优点
- 可以继承实例属性和原型方法
- 不存在引用属性共享问题
- 可以传参

**缺点：**

- 调用了两次父类构造函数（性能问题）

#### 4. 原型式继承

使用 `Object.create()` 创建新对象。

```javascript
const parent = {
  name: 'Parent',
  colors: ['red', 'blue', 'green'],
  getName: function() {
    return this.name;
  }
};

// 原型式继承
const child1 = Object.create(parent);
child1.name = 'Child1';

const child2 = Object.create(parent);
child2.name = 'Child2';

console.log(child1.getName()); // 'Child1'
console.log(child2.getName()); // 'Child2'

// ❌ 缺点：引用类型的属性被所有实例共享
child1.colors.push('yellow');
console.log(child2.colors); // ['red', 'blue', 'green', 'yellow']
```

**优点：**

- 简单，不需要构造函数

**缺点：**

- 引用类型的属性被所有实例共享
- 无法传参

#### 5. 寄生式继承

在原型式继承的基础上增强对象。

```javascript
function createChild(parent) {
  // 原型式继承
  const child = Object.create(parent);

  // 增强对象
  child.sayHello = function() {
    console.log('Hello');
  };

  return child;
}

const parent = {
  name: 'Parent',
  colors: ['red', 'blue', 'green']
};

const child1 = createChild(parent);
const child2 = createChild(parent);

child1.sayHello(); // 'Hello'

// ❌ 缺点：每次创建对象都会创建一遍方法
```

**优点：**

- 可以在继承的基础上增强对象

**缺点：**

- 每次创建对象都会创建一遍方法
- 引用类型的属性被所有实例共享

#### 6. 寄生组合式继承（最佳方式）⭐

解决组合继承调用两次父类构造函数的问题。

```javascript
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  // 继承属性
  Parent.call(this, name);
  this.age = age;
}

// 寄生组合式继承的核心
function inheritPrototype(child, parent) {
  // 创建父类原型的副本
  const prototype = Object.create(parent.prototype);
  // 修正 constructor
  prototype.constructor = child;
  // 设置子类原型
  child.prototype = prototype;
}

inheritPrototype(Child, Parent);

// 添加子类方法
Child.prototype.getAge = function() {
  return this.age;
};

const child1 = new Child('Alice', 18);
const child2 = new Child('Bob', 20);

// ✅ 所有优点
child1.colors.push('yellow');
console.log(child1.colors); // ['red', 'blue', 'green', 'yellow']
console.log(child2.colors); // ['red', 'blue', 'green']
console.log(child1.getName()); // 'Alice'
console.log(child1.getAge()); // 18

// ✅ 只调用了一次父类构造函数
```

**优点：**

- 只调用一次父类构造函数
- 避免在子类原型上创建不必要的属性
- 原型链保持不变
- 能够正常使用 `instanceof` 和 `isPrototypeOf()`

**这是最理想的继承方式！**

### 继承方式对比总结

| 继承方式 | 优点 | 缺点 | 推荐度 |
|---------|------|------|--------|
| 原型链继承 | 简单易实现 | 引用类型共享、无法传参 | ⭐ |
| 构造函数继承 | 避免引用共享、可传参 | 无法继承原型方法 | ⭐⭐ |
| 组合继承 | 结合两者优点 | 调用两次父类构造函数 | ⭐⭐⭐ |
| 原型式继承 | 简单 | 引用类型共享 | ⭐⭐ |
| 寄生式继承 | 可增强对象 | 方法重复创建 | ⭐⭐ |
| 寄生组合式继承 | 完美解决所有问题 | 实现稍复杂 | ⭐⭐⭐⭐⭐ |

---

## ES6 Class

### Class 基本语法

ES6 引入了 `class` 关键字，提供了更清晰的面向对象编程语法。

```javascript
class Person {
  // 构造函数
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // 实例方法
  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }

  // 静态方法
  static create(name, age) {
    return new Person(name, age);
  }

  // Getter
  get info() {
    return `${this.name}, ${this.age} years old`;
  }

  // Setter
  set info(value) {
    const [name, age] = value.split(',');
    this.name = name;
    this.age = parseInt(age);
  }
}

const person = new Person('Alice', 25);
person.sayHello(); // "Hello, I'm Alice"
console.log(person.info); // 'Alice, 25 years old'

const person2 = Person.create('Bob', 30);
console.log(person2.name); // 'Bob'
```

### Class 继承

使用 `extends` 关键字实现继承。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  eat() {
    console.log(`${this.name} is eating`);
  }

  static isAnimal(obj) {
    return obj instanceof Animal;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    // 必须先调用 super()
    super(name);
    this.breed = breed;
  }

  bark() {
    console.log(`${this.name} is barking`);
  }

  // 重写父类方法
  eat() {
    super.eat(); // 调用父类方法
    console.log('Dog is eating bones');
  }
}

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat();
// Buddy is eating
// Dog is eating bones

dog.bark(); // 'Buddy is barking'

console.log(Dog.isAnimal(dog)); // true
console.log(dog instanceof Dog); // true
console.log(dog instanceof Animal); // true
```

### Class 的特点

#### 1. 类声明不会提升

```javascript
// ❌ 错误：类声明不会提升
const person = new Person(); // ReferenceError

class Person {
  constructor(name) {
    this.name = name;
  }
}
```

#### 2. 类内部默认严格模式

```javascript
class Person {
  constructor() {
    // 严格模式下，this 不会指向全局对象
    function test() {
      console.log(this); // undefined
    }
    test();
  }
}
```

#### 3. 类的所有方法都是不可枚举的

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log('Hello');
  }
}

const person = new Person('Alice');

// 实例属性可枚举
console.log(Object.keys(person)); // ['name']

// 原型方法不可枚举
console.log(Object.keys(Person.prototype)); // []
console.log(Object.getOwnPropertyNames(Person.prototype)); // ['constructor', 'sayHello']
```

#### 4. 类必须使用 new 调用

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

// ❌ 错误：类必须使用 new 调用
const person = Person('Alice'); // TypeError
```

### 私有属性和方法（ES2022）

使用 `#` 定义私有属性和方法。

```javascript
class Person {
  // 私有属性
  #age;

  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  // 私有方法
  #validateAge(age) {
    return age > 0 && age < 150;
  }

  // 公共方法访问私有属性
  getAge() {
    return this.#age;
  }

  setAge(age) {
    if (this.#validateAge(age)) {
      this.#age = age;
    }
  }
}

const person = new Person('Alice', 25);
console.log(person.name); // 'Alice'
console.log(person.#age); // SyntaxError: 私有属性无法访问
console.log(person.getAge()); // 25
```

### 静态属性和方法

```javascript
class MathUtils {
  // 静态属性
  static PI = 3.14159;

  // 静态方法
  static add(a, b) {
    return a + b;
  }

  static multiply(a, b) {
    return a * b;
  }
}

// 静态成员通过类名访问
console.log(MathUtils.PI); // 3.14159
console.log(MathUtils.add(2, 3)); // 5

// 实例无法访问静态成员
const utils = new MathUtils();
console.log(utils.PI); // undefined
```

### Class vs 构造函数

```javascript
// ES5 构造函数
function PersonES5(name) {
  this.name = name;
}

PersonES5.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

// ES6 Class
class PersonES6 {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

// 本质上是一样的
console.log(typeof PersonES5); // 'function'
console.log(typeof PersonES6); // 'function'
console.log(PersonES6.prototype.constructor === PersonES6); // true
```

**Class 的优势：**

- 语法更清晰、更接近传统面向对象语言
- 支持 `extends` 继承，更简洁
- 支持 `super` 关键字
- 默认严格模式
- 方法不可枚举
- 支持私有属性和方法

### 实际应用示例

```javascript
// 用户管理系统
class User {
  #password;

  constructor(username, password, email) {
    this.username = username;
    this.#password = this.#hashPassword(password);
    this.email = email;
    this.createdAt = new Date();
  }

  #hashPassword(password) {
    // 简化的密码哈希
    return `hashed_${password}`;
  }

  validatePassword(password) {
    return this.#hashPassword(password) === this.#password;
  }

  get info() {
    return {
      username: this.username,
      email: this.email,
      createdAt: this.createdAt
    };
  }
}

class Admin extends User {
  constructor(username, password, email, permissions) {
    super(username, password, email);
    this.permissions = permissions;
  }

  hasPermission(permission) {
    return this.permissions.includes(permission);
  }

  get info() {
    return {
      ...super.info,
      role: 'admin',
      permissions: this.permissions
    };
  }
}

// 使用
const user = new User('alice', '123456', 'alice@example.com');
console.log(user.info);
console.log(user.validatePassword('123456')); // true

const admin = new Admin('bob', 'admin123', 'bob@example.com', ['read', 'write', 'delete']);
console.log(admin.info);
console.log(admin.hasPermission('write')); // true
```

---

## 常用内置对象方法

### Object 方法

```javascript
const obj = { a: 1, b: 2 };

// 创建对象
Object.create(proto); // 创建指定原型的对象
Object.assign(target, ...sources); // 合并对象

// 属性操作
Object.keys(obj); // ['a', 'b'] - 返回可枚举属性名
Object.values(obj); // [1, 2] - 返回可枚举属性值
Object.entries(obj); // [['a', 1], ['b', 2]] - 返回键值对数组

// 原型操作
Object.getPrototypeOf(obj); // 获取原型
Object.setPrototypeOf(obj, proto); // 设置原型

// 属性描述符
Object.defineProperty(obj, 'c', { value: 3, writable: false });
Object.getOwnPropertyDescriptor(obj, 'a');

// 对象状态
Object.freeze(obj); // 冻结对象（不可修改、添加、删除）
Object.seal(obj); // 密封对象（不可添加、删除，可修改）
Object.preventExtensions(obj); // 阻止扩展（不可添加）

// 检查对象状态
Object.isFrozen(obj);
Object.isSealed(obj);
Object.isExtensible(obj);
```

### Array 方法

```javascript
const arr = [1, 2, 3, 4, 5];

// 遍历方法
arr.forEach(item => console.log(item));
arr.map(item => item * 2); // [2, 4, 6, 8, 10]
arr.filter(item => item > 2); // [3, 4, 5]
arr.reduce((acc, item) => acc + item, 0); // 15

// 查找方法
arr.find(item => item > 2); // 3
arr.findIndex(item => item > 2); // 2
arr.includes(3); // true
arr.indexOf(3); // 2

// 修改方法
arr.push(6); // 添加到末尾
arr.pop(); // 删除末尾
arr.unshift(0); // 添加到开头
arr.shift(); // 删除开头
arr.splice(1, 2, 'a', 'b'); // 删除并插入

// 其他方法
arr.slice(1, 3); // [2, 3] - 截取
arr.concat([6, 7]); // [1, 2, 3, 4, 5, 6, 7] - 合并
arr.join('-'); // '1-2-3-4-5' - 转字符串
arr.reverse(); // [5, 4, 3, 2, 1] - 反转
arr.sort((a, b) => a - b); // 排序
arr.flat(2); // 扁平化
```

### String 方法

```javascript
const str = 'Hello World';

// 查找方法
str.indexOf('o'); // 4
str.lastIndexOf('o'); // 7
str.includes('World'); // true
str.startsWith('Hello'); // true
str.endsWith('World'); // true

// 提取方法
str.slice(0, 5); // 'Hello'
str.substring(0, 5); // 'Hello'
str.substr(0, 5); // 'Hello' (已废弃)

// 修改方法
str.replace('World', 'JavaScript'); // 'Hello JavaScript'
str.replaceAll('o', '0'); // 'Hell0 W0rld'
str.toUpperCase(); // 'HELLO WORLD'
str.toLowerCase(); // 'hello world'
str.trim(); // 去除两端空格
str.padStart(15, '*'); // '****Hello World'
str.padEnd(15, '*'); // 'Hello World****'

// 分割和连接
str.split(' '); // ['Hello', 'World']
str.repeat(2); // 'Hello WorldHello World'

// 匹配方法
str.match(/o/g); // ['o', 'o']
str.search(/World/); // 6
```

---

## 总结与最佳实践

### 关键要点

1. **原型**：理解 `prototype`、`__proto__`、`constructor` 三者关系
2. **原型链**：掌握属性查找机制和原型链的终点
3. **继承**：寄生组合式继承是最佳实践
4. **ES6 Class**：现代 JavaScript 推荐使用 Class 语法
5. **面向对象**：封装、继承、多态三大特性

### 最佳实践

1. **优先使用 ES6 Class** 语法，代码更清晰
2. **使用寄生组合式继承** 实现原型继承
3. **避免直接修改 `__proto__`**，使用 `Object.getPrototypeOf()` 和 `Object.setPrototypeOf()`
4. **使用 `hasOwnProperty()`** 检查自有属性
5. **合理使用静态方法** 组织工具函数
6. **使用私有属性** 保护内部状态
7. **注意原型链的性能** 影响

### 常见陷阱

1. 忘记在子类构造函数中调用 `super()`
2. 重写原型后忘记修正 `constructor`
3. 原型上的引用类型属性被所有实例共享
4. 混淆 `prototype` 和 `__proto__`
5. 在箭头函数中使用 `this`（箭头函数没有自己的 `this`）
6. 过长的原型链导致性能问题
