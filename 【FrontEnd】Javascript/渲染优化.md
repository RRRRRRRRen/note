# 避免强制同步布局

## 一、什么是强制同步布局

### 1. 浏览器的优化策略

现代浏览器会**批量处理 DOM 流的变更**，将读取和写入操作“合并处理”，以节省性能。

浏览器会：

- **延迟执行 layout（也就是 reflow）**
- 在一个批次内将样式和布局计算合并执行

### 2. 强制同步布局的触发方式

如果你在**写入 DOM 之后**立刻**读取 layout 属性**，浏览器**不得不立即执行 layout**，以返回准确的结果。

这种强制中断了它的优化流程就叫做：强制同步布局。

## 二、常见触发强制同步布局的属性和方法

这些都会触发浏览器强制执行 layout：

```js
element.offsetTop
element.offsetLeft
element.offsetWidth
element.offsetHeight
element.scrollTop
element.scrollHeight
element.clientTop
element.getBoundingClientRect()
getComputedStyle(element)
```

## 三、典型反面案例

### 1. 写后立即读取

```js
const el = document.getElementById("box");

// 修改样式（写操作）
el.style.width = "100px";

// 紧接着读取 layout 信息
const height = el.offsetHeight; // ❌ 强制同步 layout！
```

浏览器为了返回准确的 `offsetHeight`，必须马上重新计算所有样式和布局，引发 layout。

### 2. 循环读写

```js
// ❌ 坏模式：每次循环都触发 layout
for (const el of list) {
  el.style.width = "100px";             // 写
  const height = el.offsetHeight;       // 读 => 强制 layout
  el.style.height = height + 'px';      // 再写
}
```

## 四、优化策略

### 1. 合并写操作、批量读操作

```js
// 1. 批量读取
const heights = Array.from(list).map(el => el.offsetHeight);

// 2. 再批量写入
list.forEach((el, i) => {
  el.style.width = "100px";
  el.style.height = heights[i] + "px";
});
```

这就避免了反复触发 layout，只会在**第一次读取时触发一次 layout**，后续不会再强制同步。

### 2. 使用 requestAnimationFrame

```js
requestAnimationFrame(() => {
  // 所有 DOM 操作在下一帧统一执行
  const height = el.offsetHeight;
  el.style.height = height + 'px';
});
```

这样可避免连续帧间频繁回流导致的掉帧问题。

## 五、如何监测强制同步布局

### 1. DevTools 提示

打开 Chrome DevTools 的 Performance 面板：

- 勾选 `Enable advanced paint instrumentation`
- 录制交互操作
- 观察时间线中 `Recalculate Style` → `Layout` → `Paint` 顺序

如果你在 JS 中频繁看到这些步骤交错反复，就可能有强制同步。
