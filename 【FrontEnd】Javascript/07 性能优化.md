# 常见性能优化方案

## 一、调度类优化 API（控制执行时机）

| API                                                 | 作用          | 使用场景             |
| --------------------------------------------------- | ----------- | ---------------- |
| [`requestAnimationFrame`](#`requestAnimationFrame`) | 动画前执行，下一帧同步 | 动画、过渡            |
| [`requestIdleCallback`](#`requestIdleCallback`)     | 浏览器空闲时执行    | 弱优先级任务           |
| `setTimeout`（宏任务）                                   | 延后执行        | 一般性异步逻辑          |
| `queueMicrotask` / `Promise.then`                   | 微任务队列中执行    | 紧接同步逻辑后的异步       |
| [`IntersectionObserver`](#`IntersectionObserver`)   | 元素进入视口时触发   | 懒加载、懒渲染、曝光统计     |
| [`ResizeObserver`](#`ResizeObserver`)               | 元素尺寸变化时触发   | 响应式布局、Canvas 自适应 |
| [`MutationObserver `](#`MutationObserver%20`)       | DOM 结构变化时触发 | 数据绑定、组件系统底层      |

## 二、绘制和渲染相关优化

| 优化项                        | 作用 / 原理                | 应用举例                                   |
| -------------------------- | ---------------------- | -------------------------------------- |
| **`will-change`**          | 提示浏览器提前为动画元素分配层、GPU 合成 | `will-change: transform`               |
| **合成层（Compositing Layer）** | 将元素从主文档分离，提高重绘效率       | 使用 `transform: translateZ(0)`          |
| **CSS 硬件加速**               | GPU 渲染代替 CPU           | 使用 `transform`、`opacity` 替代 `top/left` |
| **避免 Layout Thrashing**    | 避免频繁读取写入 layout 属性     | 批量读写 DOM，如 `offsetHeight` 后再修改样式       |
| **虚拟滚动**                   | 只渲染可视区域的 DOM           | 大量列表渲染                                 |
| **延迟加载（Lazy Load）**        | 图片或组件进入视口再加载           | `loading="lazy"`、懒加载模块                 |

## 三、资源加载优化

|技术|说明|应用|
|---|---|---|
|**Tree-shaking**|移除未使用的代码（Webpack、Vite 支持）|精简产物|
|**Code Splitting**|按需加载模块|Vue 路由懒加载、React Lazy|
|**Preload / Prefetch**|提前加载关键资源| `<link rel="preload">` |
|**服务端压缩**|Gzip、Brotli 压缩资源体积|Nginx 配置|
|**使用缓存**|利用 HTTP 缓存头|静态资源加 hash|
|**懒加载资源**|图片、视频、第三方脚本懒加载| `loading="lazy"`、动态 import|

## 四、存储和后台任务优化

|技术|说明|应用|
|---|---|---|
|**Service Worker**|离线缓存、后台更新|PWA、离线访问|
|**Web Worker**|多线程处理重任务|解析大 JSON、图像处理|
|**IndexedDB / localStorage**|本地缓存数据|页面加速、表单中断续传|
|**requestIdleCallback**|弱优先任务调度|后台数据缓存、埋点上报|

## 五、调试与分析工具

|工具|用途|
|---|---|
|Chrome DevTools → Performance|逐帧分析、任务耗时|
|Chrome DevTools → Layers / Rendering|查看合成层、FPS、重绘|
|Lighthouse|性能评分与建议|
|Web Vitals（如 LCP、FID、CLS）|关键用户体验指标监测|

## 六、Vue/React 特有优化手段（扩展）

|技术|说明|框架|
|---|---|---|
| `v-show` vs `v-if` |控制是否渲染 vs 是否显示|Vue|
| `defineAsyncComponent` |懒加载组件|Vue 3|
| `Suspense` + Lazy|异步组件占位|React / Vue 3|
| `memo` / `PureComponent` |避免不必要重渲染|React|
| `shouldComponentUpdate` |控制更新粒度|React|
|虚拟 DOM diff 优化|提高效率|Vue、React|

# 帧回调： `requestAnimationFrame`

> `requestAnimationFrame()` 是浏览器提供的一个**异步 API**，用于在**下一个重绘周期**执行一个回调函数，通常用于实现高性能动画。

## 一、工作原理

- 浏览器每秒最多刷新 60 次（即 60 fps，≈16.67 ms 一帧）。
- `requestAnimationFrame(fn)` 会将 `fn` 注册在**下一帧渲染之前**执行。
- 浏览器会自动**节流**和**同步帧率**，在标签页不活跃时自动暂停调用，节省性能。

## 二、优点

| 优点    | 说明                                 |
| ----- | ---------------------------------- |
| ✔️ 高效 | 自动与浏览器刷新节奏同步，避免掉帧或冗余更新             |
| ✔️ 节能 | 页面不在前台时自动暂停，避免资源浪费                 |
| ✔️ 平滑 | 提供流畅动画体验，适合游戏、拖拽等场景                |
| ✔️ 简洁 | 替代 `setInterval/setTimeout` 做动画更直观 |

## 三、基本语法

```js
let animationId;

function animate() {
  // 更新动画逻辑
  drawSomething();

  // 继续下一帧
  animationId = requestAnimationFrame(animate);
}

// 启动动画
animate();

// 停止动画
cancelAnimationFrame(animationId);
```

## 四、案例代码

### 1. 节流 resize、scroll 事件

```js
let ticking = false;
window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(() => {
      // handleScroll
      ticking = false;
    });
    ticking = true;
  }
});
```

### 2. Vue 中使用

```js
import { onMounted, onBeforeUnmount } from 'vue';

let animationId;

onMounted(() => {
  function update() {
    // 更新数据或 DOM
    animationId = requestAnimationFrame(update);
  }
  update();
});

onBeforeUnmount(() => {
  cancelAnimationFrame(animationId);
});
```

## 五、实际用途场景

| 场景     | 示例                       |
| ------ | ------------------------ |
| ✅ 动画   | 位置、旋转、缩放、颜色变换等           |
| ✅ 拖拽   | 鼠标跟随、滑块、虚拟滚动             |
| ✅ 可视化  | 数据图表、粒子动画                |
| ✅ 游戏开发 | 游戏主循环、角色移动、碰撞检测          |
| ✅ 性能节流 | 替代 `mousemove` 高频触发，平滑处理 |

## 六、对比 `setTimeout / setInterval`

|特性| `requestAnimationFrame` | `setTimeout / setInterval` |
|---|---|---|
|帧同步|✅ 与浏览器刷新同步|❌ 不同步，可能掉帧或重绘重复|
|节流|✅ 不活跃时自动暂停|❌ 会持续执行|
|性能|✅ GPU 友好、少布局重排|❌ CPU 压力大|
|使用场景|动画、渲染相关|通用定时任务|

## 八、注意事项

- 每帧执行逻辑不要太重，否则会造成卡顿。
- 不适合用于非动画相关逻辑（用 `setTimeout` 更合适）。
- 动画粒度不要太小，避免频繁触发大量 DOM 操作。
- 需手动取消（组件销毁时取消，否则会内存泄漏）。

# 空闲回调： `requestIdleCallback`

> `requestIdleCallback(callback)` 是浏览器提供的一个异步 API，用于在**浏览器主线程空闲时**执行回调函数，适用于执行**非关键、低优先级任务**。
>
> 它的设计目标是让你「**趁浏览器有空时干点事**」。

## 一、工作原理

浏览器在执行完高优先级任务（如用户交互、布局、渲染等）之后，如果当前帧还有时间，就会调用 `requestIdleCallback` 注册的函数。

回调函数会接收一个 `IdleDeadline` 对象参数，用于判断当前空闲时间是否充足。

## 二、语法

```js
const handle = requestIdleCallback((deadline) => {
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    doNextTask();
  }
}, options);

// 取消
cancelIdleCallback(handle);
```

**`IdleDeadline` 对象结构**

| 属性 / 方法           | 含义                         |
| ----------------- | -------------------------- |
| `timeRemaining()` | 返回当前帧剩余的空闲毫秒数              |
| `didTimeout`      | 是否因为超时强制执行回调（见 timeout 参数） |

**`options` 参数对象结构**

| 属性        | 含义                                                                                |
| --------- | --------------------------------------------------------------------------------- |
| `timeout` | 如果指定了 timeout，并且有一个正值，而回调在 timeout 毫秒过后还没有被调用，那么回调任务将放入事件循环中排队，即使这样做有可能对性能产生负面影响。 |

**返回值**

一个 ID，可以把它传入 `Window.cancelIdleCallback(id)` 方法来结束回调。

## 三、使用场景

|场景|示例|
|---|---|
|✅ 异步预加载|懒加载模块、组件、图片等|
|✅ 缓存处理|本地缓存更新、预写入|
|✅ 非阻塞任务|日志上传、埋点、性能统计|
|✅ 虚拟 DOM diff 后清理|清理无关节点、维护缓存池|
|✅ UI 空闲优化|拖动结束后处理回弹动画、修复布局等|

## 四、和 `requestAnimationFrame` 的区别

| 对比项    | `requestAnimationFrame` | `requestIdleCallback` |
| ------ | ----------------------- | --------------------- |
| 执行时机   | 下一帧刷新前                  | 主线程空闲时                |
| 适用任务   | 动画、视觉相关更新               | 后台、非紧急任务              |
| 帧同步    | 是（~60 fps）              | 否（取决于系统负载）            |
| 是否保证执行 | 是（每帧都调）                 | 否（可能跳过）               |

## 五、示例代码

### 1. 空闲预加载模块

```js
requestIdleCallback(async () => {
  const { default: heavyModule } = await import('./heavy-module.js')
  heavyModule.init()
})
```

### 2. 延迟加载图片

```js
requestIdleCallback(() => {
  const img = new Image()
  img.src = 'https://example.com/slow-image.jpg'
})
```

## 六、Polyfill

requestIdleCallback ` 在 Safari 中尚未原生支持（截至 2025 年中）。你可以使用 Polyfill：

```js
window.requestIdleCallback = window.requestIdleCallback || function (cb) {
  return setTimeout(() => {
    const start = Date.now();
    cb({
      didTimeout: false,
      timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
    });
  }, 1);
};

window.cancelIdleCallback = window.cancelIdleCallback || clearTimeout;
```

# 监听元素交叉： `IntersectionObserver`

> `IntersectionObserver` 是浏览器提供的一个接口，用于**异步监听目标元素与祖先元素或视口（viewport）交叉状态的变化**。

## 一、核心原理

- 通过观察元素和根元素（默认为浏览器视口）交叉的情况，触发回调。
- 采用异步回调机制，不会阻塞主线程。
- 浏览器内部做了高度优化，避免了大量滚动监听带来的性能瓶颈。

## 二、语法

```js
const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('元素进入视口');
      // 可以取消监听
      observer.unobserve(entry.target);
    }
  });
}, {
  root: null,           // 监听相对于哪个元素，null 表示视口
  rootMargin: '0px',    // 触发的偏移范围，支持类似 CSS margin 语法
  threshold: 0.1        // 交叉比例，0~1 之间，可以是数组
});
```

## 三、参数说明

| 参数           | 说明                                  |
| ------------ | ----------------------------------- |
| `root`       | 作为基准的容器元素，默认是浏览器视口                  |
| `rootMargin` | 类似 CSS margin 的偏移量，可用于提前或延后触发       |
| `threshold`  | 交叉比例，0 表示元素一进入就触发，1 表示完全进入才触发，可以是数组 |

## 四、典型使用场景

|场景|说明|
|---|---|
|**图片懒加载**|图片进入视口时才加载真实资源，节省流量|
|**无限滚动加载**|列表滚动到底部时加载更多数据|
|**广告或内容曝光统计**|统计用户看到了哪些内容|
|**动画触发**|元素进入视口时播放动画|
|**停止视频播放**|元素离开视口时暂停视频|

## 五、示例

### 1. 图片懒加载

```js
const images = document.querySelectorAll('img[data-src]');

const lazyLoad = (entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
};

const observer = new IntersectionObserver(lazyLoad, {
  rootMargin: '100px',
  threshold: 0.1
});

images.forEach(img => observer.observe(img));
```

### 2. 参数组合建议

|使用场景|rootMargin|threshold|
|---|---|---|
|图片懒加载|`'200px'`|`0` or `0.1`|
|滚动加载更多|`'0px 0px 300px 0px'`|`0`|
|曝光统计|`0px`|`0.5` or `1`|
|动画触发|`'50px'`|`0.3`|

## 六、兼容性

 IE 不支持，需用 polyfill

## 七、性能优势

- 代替传统的滚动事件监听，无需自己写复杂的节流防抖。
- 浏览器底层实现高效调度，避免频繁 DOM 访问。
- 回调异步执行，不阻塞渲染。

# 监听大小变化： `ResizeObserver`

> `ResizeObserver` 用于**监听一个 DOM 元素尺寸的变化（宽度或高度）**，当尺寸发生变化时，回调函数会被异步调用。
>
> 它不会监听元素内容变化，只关注 **padding / border / size** 导致的 **布局尺寸** 变化。

## 一、使用场景

|场景|说明|
|---|---|
|响应式布局监听|元素大小变化后自动重新排版或计算|
|组件自适应调整|图表容器缩放，重新绘制|
|实现 container-query（容器查询）效果||
|虚拟滚动区域尺寸更新||
|富文本编辑器自动换行处理||
|游戏 / Canvas 自动缩放适配||

## 二、示例

### 1. 普通示例

```js
const box = document.querySelector('#box')

const resizeObserver = new ResizeObserver((entries) => {
  for (let entry of entries) {
    const { width, height } = entry.contentRect
    console.log(`尺寸变化：${width}px x ${height}px`)
  }
})

resizeObserver.observe(box)
```

### 2. Vue 3 示例

```vue
<template>
  <div ref="elRef" class="resize-box">
    当前宽度：{{ size.width }}，高度：{{ size.height }}
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const elRef = ref(null)
const size = ref({ width: 0, height: 0 })

let observer

onMounted(() => {
  observer = new ResizeObserver(([entry]) => {
    const { width, height } = entry.contentRect
    size.value = { width, height }
  })
  if (elRef.value) observer.observe(elRef.value)
})

onBeforeUnmount(() => {
  if (observer) observer.disconnect()
})
</script>

<style scoped>
.resize-box {
  resize: both;
  overflow: auto;
  border: 1px solid #ccc;
  padding: 10px;
  width: 200px;
  height: 150px;
}
</style>
```

### 3. 防抖建议

```js
let timer
const resizeObserver = new ResizeObserver(entries => {
  clearTimeout(timer)
  timer = setTimeout(() => {
    // 防抖逻辑
    for (const entry of entries) {
      console.log(entry.contentRect.width)
    }
  }, 100)
})
```

## 三、contentRect 说明

回调里的 `entry.contentRect` 包含如下尺寸信息：

|属性|含义|
|---|---|
|`width` / `height`|元素可见区域尺寸（不含滚动条）|
|`top` / `left`|相对于元素本身的位置（一般是 0）|
|`x` / `y`|同上（与 `top/left` 等价）|

## 四、注意事项

| 注意点                    | 说明                 |
| ---------------------- | ------------------ |
| 🔁 会触发多次               | 元素变化频繁时回调多次，建议防抖   |
| 🧱 监听 display: none 无效 | 元素隐藏时不触发           |
| 🔂 自身变动触发自身回调          | 注意避免死循环，比如监听后又修改宽高 |
| 🧼 使用 `.disconnect()`  | 组件卸载前断开监听，避免内存泄漏   |

# 监听节点变化： `MutationObserver `

> `MutationObserver` 是浏览器提供的**原生 API**，用于**监听 DOM 的结构变化或属性变化**。
>
> 它可以在不使用轮询的情况下，**高效地捕捉到某个节点的子节点、属性、文本内容等变更**。

## 一、监听范围

你可以监听以下几类 DOM 变化：

|类型|描述|
|---|---|
|`childList`|子元素新增或删除|
|`attributes`|属性变化|
|`characterData`|文本节点内容变化|
|`subtree`|是否观察所有后代节点|
|`attributeOldValue`|是否记录属性旧值|
|`characterDataOldValue`|是否记录文本旧值|

## 二、基本用法示例

### 1. 基本案例

```js
const target = document.getElementById('box')

const observer = new MutationObserver((mutationsList, observer) => {
  for (const mutation of mutationsList) {
    console.log('发生变化的类型:', mutation.type)
    if (mutation.type === 'childList') {
      console.log('子节点变化:', mutation.addedNodes, mutation.removedNodes)
    } else if (mutation.type === 'attributes') {
      console.log('属性变化:', mutation.attributeName)
    } else if (mutation.type === 'characterData') {
      console.log('文本变化:', mutation.target.data)
    }
  }
})

observer.observe(target, {
  childList: true,
  attributes: true,
  characterData: true,
  subtree: true,
})
```

### 2. Vue 案例

```vue
<template>
  <div ref="targetEl">内容</div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from 'vue'

const targetEl = ref(null)
let observer

onMounted(() => {
  observer = new MutationObserver((mutations) => {
    console.log('变化：', mutations)
  })

  observer.observe(targetEl.value, {
    childList: true,
    attributes: true,
    subtree: true
  })
})

onBeforeUnmount(() => {
  observer?.disconnect()
})
</script>
```

## 三、参数说明

**基本参数**

- `new MutationObserver(callback)`
    - `callback`：当监听到变化时执行，参数为变化记录数组（`MutationRecord[]`）和观察器对象。
- `observer.observe(targetNode, options)`
    - `targetNode`：要监听的目标节点
    - `options`：监听选项对象

**常见 `options` 配置**

```js
{
  childList: true,              // 监听子节点添加/删除
  attributes: true,             // 监听属性变化
  characterData: true,          // 监听文本变化
  subtree: true,                // 递归监听后代节点
  attributeOldValue: true,      // 记录旧属性值
  characterDataOldValue: true,  // 记录旧文本值
}
```

## 四、使用场景

|场景|说明|
|---|---|
|动态渲染检测|监听第三方组件或 iframe 插入的内容|
|自动表单校验|用户输入或属性变化时触发校验逻辑|
|DOM 元素出现或消失|比如弹窗、提示、广告位插入|
|页面数据注入监听|如 Chrome 插件修改页面时触发|
|防止 XSS 动态插入（安全层面）||

## 五、性能建议

| 方法              | 说明                              |
| --------------- | ------------------------------- |
| `disconnect()`  | 停止监听                            |
| `takeRecords()` | 立即获取但不触发回调                      |
| 节流/防抖处理         | 变化频繁时手动 debounce                |
| 精准目标            | 避免监听整个 `document.body`，选择具体容器即可 |

# 渲染优化

> 前端性能优化中，**渲染优化（Render Optimization）** 是至关重要的一环，它关注的是**如何让浏览器以最高效的方式绘制页面内容**。下面是一个系统化、实战导向的渲染优化笔记，包含原理、手段、常见场景与工具。

## 一、优化目标

- 减少**回流和重绘的频率与成本**
- 尽量减少**主线程阻塞**
- 利用硬件加速提高 FPS（保持流畅）

## 二、常见性能瓶颈行为

| 行为                         | 问题                      |
| -------------------------- | ----------------------- |
| 频繁操作 DOM                   | 每次操作可能触发 Layout & Paint |
| 不必要的动画或过度透明图层              | GPU 负担大，影响合成            |
| 同步 JavaScript 操作太重         | 阻塞渲染帧                   |
| 使用过多 `box-shadow`、`filter` | 影响绘制性能                  |
| 滚动中修改布局                    | 会掉帧                     |

## 三、常用渲染优化手段

### 1. **避免强制同步布局**

```js
// ❌ 不要先读再写再读，会强制同步刷新布局
const height = el.offsetHeight
el.style.height = height + 'px'
const newHeight = el.offsetHeight
```

✅ 优化：使用 `requestAnimationFrame` 合批 DOM 操作。

### 2. **减少回流和重绘**

- ✅ 批量修改 DOM（使用 Fragment、clone）
    
- ✅ 使用 `visibility: hidden` 替代 `display: none`（避免回流）
    
- ✅ 避免频繁读写 layout 属性（如 `offsetTop`）

### 3. **使用 will-change 优化预期动画**

```css
.button {
  will-change: transform, opacity;
}
```

提示浏览器提前为该元素准备合成层，提高动画流畅性，但不要滥用。

### 4. **硬件加速**

```css
transform: translateZ(0); /* 或 translate3d(0, 0, 0) */
```

- 触发 GPU 合成层，提升性能
    
- 适合动画元素、滚动区域

### 5. **用 transform/opacity 替代 top/left/width**

- `top/left/width` 修改 → 会引发 **回流**
    
- `transform` 修改 → 仅合成层重排，无 layout 代价

```css
/* ✅ 推荐 */
transform: translateX(100px);

/* ❌ 低性能 */
left: 100px;
```

### 6. **避免过度使用复杂 CSS 效果**

|属性|性能影响|
|---|---|
|`box-shadow`|中等到重|
|`filter: blur()`|非常重|
|`background-blend-mode`|重|
|`outline`, `border-radius`|中等|

### 7. **合理使用 requestAnimationFrame**

```js
function animate() {
  // 绘制逻辑
  requestAnimationFrame(animate)
}
requestAnimationFrame(animate)
```

- ✅ 保证动画同步于浏览器刷新频率（60fps）
    
- ✅ 避免 `setInterval`、`setTimeout` 的掉帧问题

### 8. **懒加载与虚拟列表**

- 避免一次性渲染大量 DOM 节点
    
- 虚拟滚动（如 `vue-virtual-scroll-list`）按需渲染可视内容
    
- 图片懒加载（使用 `loading="lazy"`、`IntersectionObserver`）

### 9. **合适粒度的组件更新（Vue/React）**

- Vue：使用 `v-show` 替代 `v-if` 频繁切换
    
- React：使用 `React.memo`, `shouldComponentUpdate` 控制更新
    
- 尽量减少 DOM diff 范围

## 五、示例对比

### 1. 动画卡顿 vs 平滑

```js
// ❌ 不推荐
element.style.left = x + 'px'

// ✅ 推荐（硬件加速 + 合成层）
element.style.transform = `translateX(${x}px)`
```

## 六、总结

|优化方向|方法|
|---|---|
|减少 layout 操作|批量 DOM 操作、避免同步读写|
|减少 repaint|使用 `transform` / `opacity`|
|减少合成负担|控制合成层数量、避免复杂样式|
|减少主线程阻塞|使用 `requestAnimationFrame`、异步任务|
|提前布局预告|使用 `will-change`|
|提前加载内容|懒加载、延迟加载、虚拟列表|
