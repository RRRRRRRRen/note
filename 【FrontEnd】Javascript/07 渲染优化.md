# 渲染优化

## 避免强制同步布局

### 浏览器的优化策略

现代浏览器会**批量处理 DOM 变更**，将样式和布局计算合并执行，延迟 reflow 以节省性能。

### 什么是强制同步布局

在**写入 DOM 之后**立刻**读取 layout 属性**，浏览器为了返回准确值，不得不立即执行 layout，中断批量优化流程。

会触发强制 layout 的属性/方法：

```js
element.offsetTop / offsetLeft / offsetWidth / offsetHeight
element.scrollTop / scrollHeight / clientTop
element.getBoundingClientRect()
getComputedStyle(element)
```

### 反面案例

写后立即读：

```js
el.style.width = '100px';          // 写
const height = el.offsetHeight;    // 强制 layout
```

循环读写（最危险）：

```js
for (const el of list) {
  el.style.width = '100px';        // 写
  const h = el.offsetHeight;       // 强制 layout
  el.style.height = h + 'px';      // 写
}
```

### 优化策略

先批量读，再批量写：

```js
// 1. 先读取所有值（只触发一次 layout）
const heights = Array.from(list).map(el => el.offsetHeight);

// 2. 再统一写入
list.forEach((el, i) => {
  el.style.width = '100px';
  el.style.height = heights[i] + 'px';
});
```

用 `requestAnimationFrame` 隔帧处理：

```js
requestAnimationFrame(() => {
  const height = el.offsetHeight;
  el.style.height = height + 'px';
});
```

### 如何检测

Chrome DevTools → Performance 面板 → 录制后观察时间线，若 `Recalculate Style → Layout → Paint` 频繁交错出现，说明存在强制同步布局。

---

## 减少回流和重绘

### 概念区分

| 类型 | 触发条件 | 代价 |
| --- | --- | --- |
| 回流（Reflow） | 几何属性变化（宽高、位置、结构） | 高，需重建渲染树 |
| 重绘（Repaint） | 外观变化但不影响布局（颜色、背景） | 较低，不重建渲染树 |

回流必然触发重绘，重绘不一定触发回流。

### 常见触发回流的操作

- 增删 DOM 节点
- 修改 `width`、`height`、`padding`、`margin`、`border`
- 读取 `offsetTop`、`clientHeight`、`getComputedStyle()` 等
- 改变窗口大小
- `display: none` 与可见切换
- 改变字体大小或字体系列

### 优化策略

合并样式修改：

```js
// 差：多次触发样式计算
element.style.width = '100px';
element.style.height = '100px';

// 好：一次性修改
element.style.cssText = 'width:100px;height:100px';

// 更好：切换 class，浏览器可批量优化
element.classList.add('highlight');
```

使用 `DocumentFragment` 批量插入：

```js
const frag = document.createDocumentFragment();
for (...) {
  const div = document.createElement('div');
  frag.appendChild(div);
}
container.appendChild(frag); // 只触发一次回流
```

隐藏元素时选择合适方式：

| 方式 | 效果 |
| --- | --- |
| `display: none` | 触发回流（元素脱离文档流） |
| `visibility: hidden` | 只触发重绘（元素仍占位） |

对动画使用 `transform` 和 `opacity`，只触发**合成层更新**，完全绕过回流和重绘：

```css
.card {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
```

---

## 触发浏览器硬件加速

> 通过特定 CSS 属性将元素提升为**合成层（Compositing Layer）**，由 GPU 负责绘制，绕过 CPU 的布局和渲染流程。

### 触发硬件加速的属性

| 属性 | 说明 |
| --- | --- |
| `transform` | `translate3d`、`scale`、`rotate`，3D 版本效果更强 |
| `will-change` | 提前告知浏览器该属性将变化，现代推荐写法 |
| `opacity` | 透明度变化不触发重排，GPU 优化重点 |
| `filter` | `blur`、`brightness` 等触发 GPU 合成 |
| `backface-visibility: hidden` | 配合 `transform` 触发加速 |

### 写法

```css
/* 方式一：translateZ(0) 强制触发 GPU 合成层 */
.accelerated {
  transform: translateZ(0);
}

/* 方式二：will-change（推荐，语义更明确） */
.animated {
  will-change: transform;
}

.fade {
  will-change: opacity;
}
```

`will-change` 不要滥用，过多会占用大量 GPU 内存，反而影响性能。仅对有动画/交互的元素使用。

### 适用场景

- 滑动、渐隐渐显、缩放动画
- 页面滚动卡顿优化
- 卡片拖拽交互
- Canvas、视频渲染区域

---

## 避免过度使用复杂 CSS 效果

### 高性能开销的 CSS 效果

| 类型 | 属性 | 原因 |
| --- | --- | --- |
| 滤镜/混合 | `filter`、`mix-blend-mode`、`backdrop-filter` | 每帧重新合成像素，GPU 压力大 |
| 阴影/半透明 | `box-shadow`、`text-shadow`、多层 `opacity` | 频繁重绘，动画中尤为明显 |
| 复杂路径 | `clip-path`（SVG 路径）、动态 `border-radius` | 计算量大 |
| 字体渲染 | 多个 web 字体、多级 fallback | 首屏加载慢，逐个回退开销大 |
| 复杂选择器 | `.a .b .c > .d + .e:not(.f)` | 样式匹配开销高 |

### 优化策略

动画中避免使用高开销属性：

```css
/* 不推荐：box-shadow 动画触发重绘 */
.card { transition: box-shadow 0.3s ease; }

/* 推荐：改用 transform */
.card {
  will-change: transform;
  transition: transform 0.3s ease;
}
```

简化动画，只用 `transform` 和 `opacity`：

```css
.card {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
```

静态化复杂效果：

- 毛玻璃背景用 `canvas` 预处理成图片，而非运行时 `backdrop-filter`
- 大量 `box-shadow` 改为背景图

限制滤镜叠加：

```css
/* 高开销 */
.heavy { filter: blur(5px) brightness(0.8) contrast(1.2); }

/* 轻量替代 */
.light { opacity: 0.8; background-color: rgba(0, 0, 0, 0.05); }
```

---

## 虚拟滚动

> 只渲染视口中可见的元素，其余不在 DOM 中，将 DOM 数量控制在固定范围（如 20~50 个），无论数据量多大性能都保持平稳。

### 为什么需要

渲染全量 DOM（万级数据）会导致：

- 初始渲染严重卡顿（移动端尤甚）
- 滚动不流畅
- 内存占用暴涨

### 核心原理

1. **固定容器高度**：维持滚动条逻辑
2. **计算可视范围**：根据 `scrollTop` 和 `itemHeight` 算出起止索引
3. **占位撑高**：用空白 padding 或 spacer 元素撑出完整滚动高度，欺骗浏览器

### 常见问题

| 问题 | 原因 | 解决方案 |
| --- | --- | --- |
| 高度计算出错 | 每行高度不一致 | 预先测量或使用动态高度虚拟滚动库 |
| 滚动白屏 | 滚动过快，新区域未及时渲染 | 增加上下缓冲区（多渲染几条） |
| SEO 不友好 | 只渲染部分内容，爬虫看不到全部 | 服务端渲染或静态生成 |

### 适用场景

- 聊天记录长列表
- 海量数据表格（日志、账单）
- 虚拟画廊、瀑布流
- 树形控件展开超多节点

实际项目推荐使用成熟库：Vue 用 `vue-virtual-scroller`，React 用 `react-window` 或 `react-virtual`。

---

## 延迟加载

> 延后非关键内容的渲染时机，优先渲染首屏内容，提升 FCP 和页面响应速度。

### 为什么需要

一次性全量渲染会导致：

- 首屏加载时间变长（FCP 变慢）
- DOM 节点过多，引发大量回流重绘
- 主线程阻塞，页面卡顿
- 渲染用户看不到的内容，浪费资源

### 常用策略

懒加载组件（Vue）：

```vue
<!-- 条件渲染，未激活时不创建组件 -->
<TabPane v-if="activeTab === 'profile'">
  <ProfileTab />
</TabPane>
```

懒加载组件（React）：

```jsx
const ProfileTab = React.lazy(() => import('./ProfileTab'));

{activeTab === 'profile' && (
  <Suspense fallback={<Spinner />}>
    <ProfileTab />
  </Suspense>
)}
```

图片懒加载：

```html
<!-- 原生支持，推荐优先使用 -->
<img src="image.jpg" loading="lazy" />
```

```js
// IntersectionObserver 方案，可控性更强
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src;
      observer.unobserve(entry.target);
    }
  });
});

document.querySelectorAll('img[data-src]').forEach(img => observer.observe(img));
```

首屏以外内容延迟加载：

```js
// 方式一：setTimeout 让出主线程
setTimeout(() => renderHeavyComponent(), 0);

// 方式二：空闲时加载（推荐）
requestIdleCallback(() => renderHeavyComponent());

// 方式三：滚动到位置时加载（配合 IntersectionObserver）
```

### 注意事项

- **避免内容闪现**：注意 `v-if` / `lazy` 的初始状态控制
- **SEO 影响**：爬虫无法抓取懒加载区域的内容，关键内容不要懒加载
- **可见性判断**：用 `IntersectionObserver` 替代手写 `scrollTop` 计算
