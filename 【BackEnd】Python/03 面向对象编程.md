# 面向对象编程

## 类与实例

### 类的定义

类是对象的蓝图，使用 `class` 关键字定义。

```python
class Dog:
    # 类属性：所有实例共享
    species = "Canis familiaris"

    def __init__(self, name: str, age: int):
        # 实例属性：每个实例独立拥有
        self.name = name
        self.age = age
```

### __init__ 构造方法

`__init__` 在实例创建后立即调用，用于初始化实例属性。

```python
class Person:
    def __init__(self, name: str, age: int):
        self.name = name  # 绑定实例属性
        self.age = age

p = Person("Alice", 30)
print(p.name)  # Alice
```

### 实例属性 vs 类属性

```python
class Counter:
    count = 0  # 类属性：所有实例共享，通过类名访问

    def __init__(self):
        Counter.count += 1
        self.id = Counter.count  # 实例属性：每个实例独立

c1 = Counter()
c2 = Counter()
print(Counter.count)  # 2（类属性）
print(c1.id, c2.id)   # 1 2（实例属性）

# 实例属性会遮蔽同名类属性
c1.count = 99         # 仅在 c1 上创建实例属性，不影响类属性
print(c1.count)       # 99
print(Counter.count)  # 2
```

### 实例方法、类方法、静态方法

```python
class MyClass:
    class_var = "class"

    def instance_method(self):
        # 实例方法：第一个参数为 self，可访问实例和类
        return f"instance, class_var={self.class_var}"

    @classmethod
    def class_method(cls):
        # 类方法：第一个参数为 cls，只能访问类属性
        return f"class, class_var={cls.class_var}"

    @staticmethod
    def static_method(x, y):
        # 静态方法：无隐式参数，与类无直接关联，仅作命名空间归类
        return x + y

obj = MyClass()
print(obj.instance_method())        # instance, class_var=class
print(MyClass.class_method())       # class, class_var=class
print(MyClass.static_method(1, 2))  # 3
```

## 魔术方法

### __str__ 与 __repr__

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        # 面向开发者，目标是"无歧义"，eval(repr(obj)) 应能重建对象
        return f"Point({self.x!r}, {self.y!r})"

    def __str__(self):
        # 面向用户，目标是"可读性"
        return f"({self.x}, {self.y})"

p = Point(1, 2)
print(repr(p))  # Point(1, 2)
print(str(p))   # (1, 2)
print(p)        # (1, 2)  —— print 调用 __str__
```

### __len__、__getitem__、__setitem__

```python
class Stack:
    def __init__(self):
        self._data = []

    def __len__(self):
        # 支持 len(stack)
        return len(self._data)

    def __getitem__(self, index):
        # 支持 stack[index]
        return self._data[index]

    def __setitem__(self, index, value):
        # 支持 stack[index] = value
        self._data[index] = value

    def push(self, item):
        self._data.append(item)

s = Stack()
s.push(10)
s.push(20)
print(len(s))  # 2
print(s[0])    # 10
s[0] = 99
print(s[0])    # 99
```

### __eq__、__lt__ 等比较方法

```python
from functools import total_ordering

# @total_ordering 只需实现 __eq__ 和一个比较方法，自动推导其余
@total_ordering
class Version:
    def __init__(self, major, minor):
        self.major = major
        self.minor = minor

    def __eq__(self, other):
        return (self.major, self.minor) == (other.major, other.minor)

    def __lt__(self, other):
        return (self.major, self.minor) < (other.major, other.minor)

v1 = Version(1, 0)
v2 = Version(2, 0)
print(v1 < v2)   # True
print(v1 > v2)   # False（由 total_ordering 推导）
print(v1 == v2)  # False
```

### __enter__ 与 __exit__（上下文管理器）

```python
class ManagedFile:
    def __init__(self, path, mode):
        self.path = path
        self.mode = mode

    def __enter__(self):
        # with 块开始时调用，返回值绑定到 as 子句
        self.file = open(self.path, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        # with 块结束时调用，无论是否发生异常
        self.file.close()
        # 返回 True 表示吞掉异常，False/None 表示继续传播
        return False

with ManagedFile("test.txt", "w") as f:
    f.write("hello")
# 离开 with 块后文件自动关闭
```

### __call__

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, value):
        # 使实例可以像函数一样被调用
        return value * self.factor

double = Multiplier(2)
triple = Multiplier(3)
print(double(5))        # 10
print(triple(5))        # 15
print(callable(double)) # True
```

### __slots__

```python
class Point:
    # 声明 __slots__ 后，实例不再有 __dict__
    # 节省内存，并防止动态添加未声明的属性
    __slots__ = ("x", "y")

    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(1, 2)
print(p.x)  # 1

# p.z = 3  # AttributeError: Point object has no attribute z
# 内存对比：有 __slots__ 的实例比普通实例节省约 40-50% 内存
```

## 继承与多态

### 单继承

```python
class Animal:
    def __init__(self, name: str):
        self.name = name

    def speak(self) -> str:
        raise NotImplementedError

class Dog(Animal):
    # Dog 继承 Animal 的所有属性和方法
    def speak(self) -> str:
        return f"{self.name} says Woof!"

d = Dog("Rex")
print(d.speak())             # Rex says Woof!
print(isinstance(d, Dog))    # True
print(isinstance(d, Animal)) # True
```

### 方法重写与 super()

```python
class Base:
    def __init__(self, x):
        self.x = x

    def describe(self):
        return f"Base: x={self.x}"

class Child(Base):
    def __init__(self, x, y):
        super().__init__(x)  # 调用父类 __init__，避免重复初始化逻辑
        self.y = y

    def describe(self):
        # super() 调用父类方法，在此基础上扩展
        base_desc = super().describe()
        return f"{base_desc}, y={self.y}"

c = Child(1, 2)
print(c.describe())  # Base: x=1, y=2
```

### 多态的实现

```python
class Shape:
    def area(self) -> float:
        raise NotImplementedError

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self) -> float:
        return 3.14159 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, w, h):
        self.w = w
        self.h = h

    def area(self) -> float:
        return self.w * self.h

def print_area(shape: Shape):
    # 多态：同一接口，不同实现，调用方无需关心具体类型
    print(f"Area: {shape.area():.2f}")

shapes = [Circle(5), Rectangle(3, 4)]
for s in shapes:
    print_area(s)
# Area: 78.54
# Area: 12.00
```

### 鸭子类型

```python
class Duck:
    def quack(self):
        return "Quack!"

class Person:
    def quack(self):
        return "I am quacking like a duck!"

def make_it_quack(obj):
    # 鸭子类型：不检查类型，只关心对象是否有所需方法
    # "如果它走路像鸭子，叫声像鸭子，那它就是鸭子"
    return obj.quack()

print(make_it_quack(Duck()))    # Quack!
print(make_it_quack(Person()))  # I am quacking like a duck!
```

## 多重继承与 MRO

### 多重继承语法

```python
class A:
    def hello(self):
        return "Hello from A"

class B:
    def world(self):
        return "World from B"

class C(A, B):
    # C 同时继承 A 和 B 的方法
    pass

c = C()
print(c.hello())  # Hello from A
print(c.world())  # World from B
```

### MRO（方法解析顺序）

```python
class A:
    def method(self):
        return "A"

class B(A):
    def method(self):
        return "B"

class C(A):
    def method(self):
        return "C"

class D(B, C):
    pass

# MRO 决定了方法查找的顺序
print(D.__mro__)
# (<class D>, <class B>, <class C>, <class A>, <class object>)

d = D()
print(d.method())  # B（按 MRO 顺序，B 在 C 之前）
```

### C3 线性化算法

```python
# C3 算法规则：
# L(C) = C + merge(L(B1), L(B2), ..., [B1, B2, ...])
# merge 每次取第一个序列的头部，条件：该头部不出现在其他序列的尾部

class O: pass
class A(O): pass
class B(O): pass
class C(O): pass
class D(A, B): pass
class E(B, C): pass
class F(D, E): pass

# F 的 MRO：F -> D -> A -> E -> B -> C -> O
print([cls.__name__ for cls in F.__mro__])
# [F, D, A, E, B, C, O]
```

### Mixin 模式

```python
class LogMixin:
    # Mixin：提供单一功能的小型类，不单独实例化
    # 命名惯例以 Mixin 结尾，表明其辅助性质
    def log(self, message: str):
        print(f"[{self.__class__.__name__}] {message}")

class SerializeMixin:
    def to_dict(self) -> dict:
        return self.__dict__.copy()

class User(LogMixin, SerializeMixin):
    def __init__(self, name, email):
        self.name = name
        self.email = email

u = User("Alice", "alice@example.com")
u.log("User created")   # [User] User created
print(u.to_dict())      # {name: Alice, email: alice@example.com}
```

## 抽象类

### abc 模块

```python
from abc import ABC, abstractmethod

# ABC 是 ABCMeta 的语法糖，继承 ABC 即可使用抽象类功能
class Shape(ABC):
    pass

# 抽象类不能直接实例化
# s = Shape()  # TypeError: Cannot instantiate abstract class Shape
```

### @abstractmethod

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self) -> str:
        # 抽象方法：子类必须实现，否则子类也无法实例化
        pass

    @abstractmethod
    def move(self) -> str:
        pass

    def breathe(self):
        # 非抽象方法：提供默认实现，子类可选择重写
        return "Breathing..."

class Cat(Animal):
    def speak(self) -> str:
        return "Meow"

    def move(self) -> str:
        return "Walking"

c = Cat()
print(c.speak())    # Meow
print(c.breathe())  # Breathing...
```

### 抽象类的应用场景

```python
from abc import ABC, abstractmethod

# 场景：定义插件/策略接口，强制实现者遵守契约
class DataExporter(ABC):
    @abstractmethod
    def export(self, data: list) -> str:
        pass

    @abstractmethod
    def get_format(self) -> str:
        pass

class CSVExporter(DataExporter):
    def export(self, data: list) -> str:
        return "
".join(",".join(str(v) for v in row) for row in data)

    def get_format(self) -> str:
        return "csv"

class JSONExporter(DataExporter):
    def export(self, data: list) -> str:
        import json
        return json.dumps(data)

    def get_format(self) -> str:
        return "json"

def run_export(exporter: DataExporter, data: list):
    # 依赖抽象而非具体实现（依赖倒置原则）
    print(f"Format: {exporter.get_format()}")
    print(exporter.export(data))

run_export(CSVExporter(), [[1, 2], [3, 4]])
```

## dataclass

### @dataclass 装饰器

```python
from dataclasses import dataclass

@dataclass
class Point:
    # @dataclass 自动生成 __init__、__repr__、__eq__
    x: float
    y: float
    z: float = 0.0  # 带默认值的字段必须在无默认值字段之后

p1 = Point(1.0, 2.0)
p2 = Point(1.0, 2.0)
print(p1)        # Point(x=1.0, y=2.0, z=0.0)
print(p1 == p2)  # True（自动生成 __eq__）
```

### field() 函数

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Student:
    name: str
    grades: List[float] = field(
        default_factory=list,  # 可变默认值必须用 default_factory，避免共享同一对象
        repr=False             # 不在 __repr__ 中显示此字段
    )
    _id: int = field(
        default=0,
        init=False,            # 不在 __init__ 中暴露此参数
        compare=False          # 不参与 __eq__ 比较
    )

s = Student("Alice")
s.grades.append(95.0)
print(s)  # Student(name=Alice)
```

### 与普通类的对比

```python
# 普通类：需要手动编写样板代码
class PointManual:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"PointManual(x={self.x}, y={self.y})"

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)

# dataclass：等价实现，代码量大幅减少
from dataclasses import dataclass

@dataclass
class PointDC:
    x: float
    y: float
# 自动生成 __init__、__repr__、__eq__，功能完全等价
```

### frozen dataclass

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class ImmutablePoint:
    # frozen=True：实例创建后属性不可修改，类似 namedtuple
    # 同时自动生成 __hash__，可用作字典键或集合元素
    x: float
    y: float

p = ImmutablePoint(1.0, 2.0)
# p.x = 3.0  # FrozenInstanceError: cannot assign to field x

# 可哈希，可用作字典键
d = {p: "origin area"}
print(d[ImmutablePoint(1.0, 2.0)])  # origin area
```

## 元类

### type 与元类

```python
# type 是所有类的元类（类的类）
# 动态创建类：type(name, bases, namespace)
Dog = type(
    "Dog",                           # 类名
    (object,),                       # 基类元组
    {"speak": lambda self: "Woof"}   # 类命名空间
)

d = Dog()
print(d.speak())   # Woof
print(type(Dog))   # <class type>
print(type(int))   # <class type>
print(type(type))  # <class type>  type 是自身的元类
```

### __new__ vs __init__

```python
class Meta(type):
    def __new__(mcs, name, bases, namespace):
        # __new__：创建并返回类对象本身
        # mcs 是元类，name/bases/namespace 描述被创建的类
        print(f"Creating class: {name}")
        cls = super().__new__(mcs, name, bases, namespace)
        return cls

    def __init__(cls, name, bases, namespace):
        # __init__：对已创建的类对象进行初始化
        # 此时 cls 已经是创建好的类
        super().__init__(name, bases, namespace)
        print(f"Initializing class: {name}")

class MyClass(metaclass=Meta):
    pass
# Creating class: MyClass
# Initializing class: MyClass
```

### 自定义元类的应用场景

```python
class SingletonMeta(type):
    # 场景：通过元类实现单例模式
    _instances = {}

    def __call__(cls, *args, **kwargs):
        # __call__ 在类被调用（即实例化）时触发
        if cls not in cls._instances:
            # 首次实例化：调用父元类的 __call__ 创建实例
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self, url: str):
        self.url = url

db1 = Database("postgresql://localhost/mydb")
db2 = Database("postgresql://localhost/other")
print(db1 is db2)  # True，始终返回同一实例
print(db1.url)     # postgresql://localhost/mydb


class RegistryMeta(type):
    # 场景：自动注册所有子类，用于插件系统
    registry = {}

    def __init__(cls, name, bases, namespace):
        super().__init__(name, bases, namespace)
        if bases:  # 跳过基类自身
            RegistryMeta.registry[name] = cls

class Plugin(metaclass=RegistryMeta):
    pass

class PluginA(Plugin):
    pass

class PluginB(Plugin):
    pass

print(RegistryMeta.registry)
# {PluginA: <class PluginA>, PluginB: <class PluginB>}
```
