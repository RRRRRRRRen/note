# 异常处理与调试

## 异常体系

### BaseException 与 Exception 的区别

`BaseException` 是所有异常的根类，`Exception` 是大多数常规异常的基类。

- `BaseException`：包含 `SystemExit`、`KeyboardInterrupt`、`GeneratorExit` 等系统级异常
- `Exception`：用于程序逻辑错误，自定义异常应继承此类
- 捕获 `Exception` 不会拦截用户中断（Ctrl+C）或解释器退出

```python
# 不推荐：捕获 BaseException 会拦截 KeyboardInterrupt 等系统信号
try:
    pass
except BaseException:
    pass

# 推荐：只捕获程序逻辑异常
try:
    pass
except Exception:
    pass
```

### 常见内置异常类型

| 异常类型 | 触发场景 |
|---|---|
| `ValueError` | 参数类型正确但值不合法 |
| `TypeError` | 操作或函数应用于不适当类型 |
| `KeyError` | 字典中不存在的键 |
| `IndexError` | 序列下标超出范围 |
| `AttributeError` | 对象没有该属性或方法 |
| `FileNotFoundError` | 文件或目录不存在 |
| `ImportError` | 导入模块失败 |
| `OSError` | 操作系统相关错误 |
| `RuntimeError` | 运行时检测到的错误 |
| `StopIteration` | 迭代器没有更多值 |
| `MemoryError` | 内存不足 |
| `RecursionError` | 超过最大递归深度 |

### 异常继承树

```text
BaseException
├── SystemExit              # sys.exit() 触发
├── KeyboardInterrupt       # Ctrl+C 触发
├── GeneratorExit           # 生成器关闭时触发
└── Exception               # 所有常规异常的基类
    ├── ArithmeticError
    │   ├── ZeroDivisionError
    │   └── OverflowError
    ├── LookupError
    │   ├── IndexError
    │   └── KeyError
    ├── OSError
    │   ├── FileNotFoundError
    │   ├── PermissionError
    │   └── TimeoutError
    ├── ValueError
    ├── TypeError
    ├── AttributeError
    ├── ImportError
    ├── RuntimeError
    │   └── RecursionError
    └── StopIteration
```
## try/except/finally

### 基本语法

```python
try:
    result = 10 / 0          # 可能抛出异常的代码
except ZeroDivisionError:
    print("除数不能为零")     # 捕获特定异常
```

### 捕获多个异常

```python
try:
    data = int(input("请输入数字: "))
    result = 100 / data
except ValueError:
    # 捕获 int() 转换失败
    print("输入的不是有效数字")
except ZeroDivisionError:
    # 捕获除以零
    print("不能输入 0")
except (TypeError, AttributeError):
    # 用元组同时捕获多种异常
    print("类型错误")
```

### as 关键字获取异常对象

```python
try:
    open("/nonexistent/path/file.txt")
except FileNotFoundError as e:
    # e 是异常实例，包含详细信息
    print(f"错误类型: {type(e).__name__}")   # FileNotFoundError
    print(f"错误信息: {e}")                  # [Errno 2] No such file...
    print(f"错误参数: {e.args}")             # (2, 'No such file or directory')
```

### else 子句

 块仅在  块没有抛出任何异常时执行，用于放置依赖  成功的逻辑。

```python
try:
    f = open("data.txt", "r")
except FileNotFoundError:
    print("文件不存在")
else:
    # 只有文件成功打开后才执行
    content = f.read()
    f.close()
    print(f"读取了 {len(content)} 个字符")
```

### finally 的执行时机

 块无论是否发生异常都会执行，常用于资源释放。

```python
conn = None
try:
    conn = open("data.txt", "r")
    data = conn.read()
    result = int(data)          # 可能抛出 ValueError
except ValueError as e:
    print(f"数据格式错误: {e}")
finally:
    # 无论是否异常，都会执行
    # 即使 try 中有 return，finally 也会先执行
    if conn:
        conn.close()
        print("文件已关闭")
```

### 异常链（raise from）

```python
def fetch_user(user_id):
    try:
        # 模拟数据库查询失败
        raise ConnectionError("数据库连接超时")
    except ConnectionError as e:
        # raise ... from e：显式链接原始异常
        # 保留原始异常上下文，便于调试
        raise RuntimeError(f"获取用户 {user_id} 失败") from e

try:
    fetch_user(42)
except RuntimeError as e:
    print(e)                    # 获取用户 42 失败
    print(e.__cause__)          # 数据库连接超时（原始异常）

# raise ... from None：隐藏原始异常链
def parse_config(raw):
    try:
        return int(raw)
    except ValueError:
        raise ValueError(f"配置值 {raw!r} 必须是整数") from None
```
## 自定义异常

### 继承 Exception

```python
# 自定义异常应继承 Exception，而非 BaseException
class AppError(Exception):
    """应用程序基础异常，所有自定义异常的父类"""
    pass

class ValidationError(AppError):
    """数据验证失败异常"""
    pass

class NetworkError(AppError):
    """网络请求失败异常"""
    pass

def validate_age(age):
    if not isinstance(age, int):
        raise TypeError(f"age 必须是整数，得到 {type(age).__name__}")
    if age < 0 or age > 150:
        raise ValidationError(f"年龄 {age} 超出合法范围 [0, 150]")
    return age
```

### 添加自定义属性

```python
class APIError(Exception):
    """API 请求异常，携带状态码和响应体"""

    def __init__(self, message, status_code, response=None):
        # 调用父类 __init__，确保 args 正确设置
        super().__init__(message)
        self.status_code = status_code
        self.response = response

    def __str__(self):
        return f"[{self.status_code}] {self.args[0]}"

try:
    raise APIError("未授权访问", status_code=401, response={"error": "Unauthorized"})
except APIError as e:
    print(e)                    # [401] 未授权访问
    print(e.status_code)        # 401
    print(e.response)           # {'error': 'Unauthorized'}
```

### 异常的最佳实践

```python
# 1. 只捕获你能处理的异常，不要吞掉异常
# 错误示范
try:
    risky_operation()
except Exception:
    pass  # 静默忽略所有错误，难以排查问题

# 正确示范
try:
    risky_operation()
except SpecificError as e:
    logger.error(f"操作失败: {e}")
    raise  # 重新抛出，让上层决定如何处理

# 2. 不要用异常控制正常流程
# 错误示范
def get_value_bad(d, key):
    try:
        return d[key]
    except KeyError:
        return None

# 正确示范：用 .get() 处理预期缺失
def get_value(d, key):
    return d.get(key)

# 3. 自定义异常要有清晰的层级
class ProjectBaseError(Exception):
    """项目所有异常的基类，方便统一捕获"""
    pass
```
## 上下文管理器

### with 语句原理

`with` 语句保证代码块执行完毕后（无论是否异常）自动执行清理操作。

```python
# with 语句等价于以下 try/finally 结构
f = open("file.txt")
try:
    data = f.read()
finally:
    f.close()

# 使用 with 语句更简洁
with open("file.txt") as f:
    data = f.read()
# 离开 with 块后，f.close() 自动调用
```

### __enter__ 与 __exit__

```python
class DatabaseConnection:
    """实现上下文管理器协议的数据库连接类"""

    def __init__(self, host):
        self.host = host
        self.conn = None

    def __enter__(self):
        # 进入 with 块时调用，返回值赋给 as 后的变量
        print(f"连接到 {self.host}")
        self.conn = f"<Connection to {self.host}>"
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        # 离开 with 块时调用
        # exc_type: 异常类型，无异常则为 None
        # exc_val:  异常实例
        # exc_tb:   traceback 对象
        print("关闭连接")
        self.conn = None
        # 返回 True 表示异常已处理，不再向上传播
        # 返回 False 或 None 表示异常继续传播
        if exc_type is ValueError:
            print(f"捕获到 ValueError: {exc_val}，已处理")
            return True  # 抑制 ValueError
        return False     # 其他异常继续传播

with DatabaseConnection("localhost") as conn:
    print(f"使用连接: {conn}")
```

### contextlib.contextmanager

使用生成器函数创建上下文管理器，比实现类更简洁。

```python
from contextlib import contextmanager

@contextmanager
def managed_resource(name):
    # yield 之前的代码相当于 __enter__
    print(f"获取资源: {name}")
    resource = {"name": name, "active": True}
    try:
        yield resource          # yield 的值赋给 as 后的变量
    except ValueError as e:
        print(f"资源使用出错: {e}")
    finally:
        # finally 相当于 __exit__ 的清理逻辑
        resource["active"] = False
        print(f"释放资源: {name}")

with managed_resource("cache") as res:
    print(f"资源状态: {res}")
```

### 常见使用场景

```python
import threading
from contextlib import suppress

# 1. 文件操作
with open("output.txt", "w", encoding="utf-8") as f:
    f.write("Hello, World!")

# 2. 线程锁
lock = threading.Lock()
with lock:
    # 临界区代码，自动加锁和释放锁
    shared_data = []

# 3. 同时管理多个上下文（Python 3.10+ 支持括号语法）
with (open("input.txt") as fin, open("output.txt", "w") as fout):
    fout.write(fin.read())

# 4. suppress：忽略特定异常
with suppress(FileNotFoundError):
    # 文件不存在时静默跳过，无需 try/except
    import os
    os.remove("temp_file.txt")
```
## logging 模块

### 日志级别

| 级别 | 数值 | 使用场景 |
|---|---|---|
| `DEBUG` | 10 | 详细调试信息，仅开发时使用 |
| `INFO` | 20 | 程序正常运行的关键节点 |
| `WARNING` | 30 | 潜在问题，程序仍可运行（默认级别） |
| `ERROR` | 40 | 发生错误，部分功能失败 |
| `CRITICAL` | 50 | 严重错误，程序可能无法继续运行 |

### 基本配置

```python
import logging

# basicConfig 只在 root logger 没有 handler 时生效
# 通常在程序入口处调用一次
logging.basicConfig(
    level=logging.DEBUG,                        # 最低记录级别
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

logging.debug("调试信息")
logging.info("程序启动")
logging.warning("磁盘空间不足")
logging.error("数据库连接失败")
logging.critical("系统崩溃")
```

### Logger、Handler、Formatter

```python
import logging

# 1. 创建 Logger（推荐用模块名，形成层级结构）
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)      # Logger 自身的过滤级别

# 2. 创建 Formatter（定义日志格式）
formatter = logging.Formatter(
    fmt="%(asctime)s [%(levelname)-8s] %(name)s:%(lineno)d - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

# 3. 创建 Handler（决定日志输出到哪里）
console_handler = logging.StreamHandler()       # 输出到控制台
console_handler.setLevel(logging.INFO)          # Handler 的过滤级别
console_handler.setFormatter(formatter)

# 4. 将 Handler 添加到 Logger
logger.addHandler(console_handler)

# 使用
logger.info("服务启动，端口: %d", 8080)         # 推荐用 % 格式，避免不必要的字符串拼接
logger.error("请求失败", exc_info=True)         # exc_info=True 自动附加异常堆栈
```

### 日志到文件

```python
import logging
from logging.handlers import RotatingFileHandler

logger = logging.getLogger("myapp")
logger.setLevel(logging.DEBUG)

formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")

# RotatingFileHandler：按文件大小轮转，避免日志文件无限增长
file_handler = RotatingFileHandler(
    filename="app.log",
    maxBytes=5 * 1024 * 1024,   # 单个文件最大 5MB
    backupCount=3,               # 保留 3 个备份文件（app.log.1, .2, .3）
    encoding="utf-8"
)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

# 控制台只输出 WARNING 及以上
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.WARNING)
console_handler.setFormatter(formatter)

logger.addHandler(file_handler)
logger.addHandler(console_handler)
```

### 最佳实践

```python
import logging

# 1. 每个模块使用独立 logger，不要直接用 root logger
logger = logging.getLogger(__name__)

# 2. 在库代码中添加 NullHandler，避免 "No handlers" 警告
# 让使用库的应用决定日志配置
logging.getLogger("mylib").addHandler(logging.NullHandler())

# 3. 记录异常时使用 exception()，自动包含堆栈信息
def process_data(data):
    try:
        return int(data)
    except ValueError:
        logger.exception("数据转换失败，data=%r", data)
        # 等价于 logger.error(..., exc_info=True)
        raise

# 4. 使用结构化的日志消息，便于后续解析
# logger.info("用户登录成功 user_id=%s ip=%s", user_id, ip_address)

# 5. 避免在日志消息中做昂贵的字符串操作
# 错误示范：即使日志级别不够，字符串也会被拼接
# logger.debug("数据: " + str(large_object))

# 正确示范：只有实际记录时才格式化
# logger.debug("数据: %s", large_object)
```
## 调试技巧

### print 调试 vs 断点调试

```python
# print 调试：简单快速，适合快速定位问题
def calculate(a, b):
    print(f"[DEBUG] a={a}, b={b}, type(a)={type(a)}")  # 临时调试输出
    result = a + b
    print(f"[DEBUG] result={result}")
    return result

# 断点调试优势：
# - 可以在运行时检查任意变量
# - 可以单步执行，观察程序流程
# - 不需要修改代码，调试完无需清理
# - 支持条件断点，只在特定条件下暂停
```

### pdb 基本命令

```python
import pdb

def buggy_function(items):
    total = 0
    for i, item in enumerate(items):
        pdb.set_trace()         # 在此处设置断点，程序暂停进入交互模式
        total += item
    return total

# Python 3.7+ 可以直接用内置 breakpoint()
def buggy_function_v2(items):
    total = 0
    for item in items:
        breakpoint()            # 等价于 pdb.set_trace()，更简洁
        total += item
    return total
```

```text
pdb 常用命令：
  n (next)          执行下一行（不进入函数内部）
  s (step)          单步执行（进入函数内部）
  c (continue)      继续执行直到下一个断点
  q (quit)          退出调试器
  p <expr>          打印表达式的值，如 p total
  pp <expr>         格式化打印，如 pp locals()
  l (list)          显示当前位置附近的源代码
  w (where)         显示当前调用栈
  b <line>          在指定行设置断点，如 b 10
  b <line>, <cond>  条件断点，如 b 10, x > 5
  u / d             在调用栈中上移/下移一帧
  h (help)          显示帮助
```

### assert 断言

```python
def divide(a, b):
    # assert 用于检查程序内部不变量（invariant）
    # 格式：assert <条件>, <失败时的错误信息>
    assert isinstance(a, (int, float)), f"a 必须是数字，得到 {type(a)}"
    assert isinstance(b, (int, float)), f"b 必须是数字，得到 {type(b)}"
    assert b != 0, "除数不能为零"
    return a / b

# 注意：assert 可以被 python -O（优化模式）禁用
# 因此不要用 assert 做安全检查或输入验证，只用于调试期的内部检查
# 安全检查应使用 if ... raise ...
def safe_divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")    # 生产代码用 raise
    return a / b
```

### traceback 模块

```python
import traceback
import sys

def level3():
    raise ValueError("最底层的错误")

def level2():
    level3()

def level1():
    level2()

# 1. 捕获并格式化异常堆栈为字符串
try:
    level1()
except ValueError:
    # format_exc() 返回当前异常的完整堆栈字符串
    tb_str = traceback.format_exc()
    print("捕获到异常堆栈:")
    print(tb_str)

# 2. 打印异常堆栈到标准错误
try:
    level1()
except ValueError:
    traceback.print_exc(file=sys.stderr)    # 默认输出到 stderr

# 3. 获取结构化的堆栈信息
try:
    level1()
except ValueError as e:
    # extract_tb 返回 StackSummary，可以遍历每一帧
    tb = traceback.extract_tb(e.__traceback__)
    for frame in tb:
        print(f"文件: {frame.filename}, 行: {frame.lineno}, 函数: {frame.name}")
        print(f"  代码: {frame.line}")
```
