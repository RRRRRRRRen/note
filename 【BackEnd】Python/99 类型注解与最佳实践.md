# 类型注解与最佳实践

## 类型注解语法

### 变量注解

```python
# 基本变量注解语法：变量名: 类型 = 值
name: str = "Alice"
age: int = 30
score: float = 9.5
is_active: bool = True

# 仅声明类型，不赋值（常用于类属性声明）
nickname: str  # 声明但未赋值，运行时不会创建该变量

# 复合类型注解
from typing import List, Dict, Tuple, Set, Optional

names: List[str] = ["Alice", "Bob"]
scores: Dict[str, int] = {"Alice": 90, "Bob": 85}
point: Tuple[int, int] = (10, 20)
unique_ids: Set[int] = {1, 2, 3}

# Python 3.10+ 可直接使用内置类型（无需 from typing import）
names_new: list[str] = ["Alice", "Bob"]
scores_new: dict[str, int] = {"Alice": 90}

# Optional[X] 等价于 Union[X, None]，表示可能为 None
maybe_name: Optional[str] = None
```

### 函数参数与返回值注解

```python
from typing import Optional, Union, List

# 基本函数注解：参数类型 + 返回值类型
def greet(name: str) -> str:
    return f"Hello, {name}"

# 多参数注解
def add(a: int, b: int) -> int:
    return a + b

# 可选参数（有默认值）
def connect(host: str, port: int = 8080, timeout: Optional[float] = None) -> bool:
    return True

# Union 表示多种可能类型（Python 3.10+ 可用 X | Y 语法）
def parse_id(value: Union[str, int]) -> int:
    return int(value)

# Python 3.10+ 新语法
def parse_id_new(value: str | int) -> int:
    return int(value)

# 无返回值用 None
def log(message: str) -> None:
    print(message)

# 返回多个值（实际是 Tuple）
def min_max(nums: List[int]) -> tuple[int, int]:
    return min(nums), max(nums)

# *args 和 **kwargs 的注解
def variadic(*args: int, **kwargs: str) -> None:
    # args 类型为 tuple[int, ...]
    # kwargs 类型为 dict[str, str]
    pass
```

### 类属性注解

```python
from typing import ClassVar, Optional
from dataclasses import dataclass

class User:
    # 类变量注解（所有实例共享）
    count: ClassVar[int] = 0

    # 实例变量注解（在 __init__ 中赋值）
    def __init__(self, name: str, age: int) -> None:
        self.name: str = name          # 实例属性注解
        self.age: int = age
        self.email: Optional[str] = None  # 可能为 None 的属性

    def birthday(self) -> None:
        self.age += 1

# 使用 dataclass 自动生成 __init__，注解即属性声明
@dataclass
class Point:
    x: float          # 必填字段
    y: float          # 必填字段
    label: str = ""   # 有默认值的字段
```

### 注解的运行时行为

```python
# 类型注解在运行时不强制检查，仅供静态分析工具使用
def add(a: int, b: int) -> int:
    return a + b

# 以下调用在运行时不会报错，但静态检查工具会警告
result = add("hello", "world")  # 运行时返回 "helloworld"，不报错

# 通过 __annotations__ 可在运行时访问注解信息
print(add.__annotations__)
# 输出: {'a': <class 'int'>, 'b': <class 'int'>, 'return': <class 'int'>}

class Foo:
    x: int = 1
    y: str

print(Foo.__annotations__)  # {'x': <class 'int'>, 'y': <class 'str'>}

# from __future__ import annotations 使注解变为字符串（延迟求值）
# 可避免前向引用问题，Python 3.10+ 推荐使用
from __future__ import annotations

class Node:
    def __init__(self, next: Node) -> None:  # Node 此时尚未定义完，但不报错
        self.next = next
```

## 泛型

### TypeVar 的定义与使用

```python
from typing import TypeVar, List

# TypeVar 定义类型变量，T 是约定俗成的名称
T = TypeVar("T")           # 无约束，可以是任意类型
S = TypeVar("S", str, bytes)  # 约束为 str 或 bytes
N = TypeVar("N", int, float)  # 约束为数值类型

# bound 参数：T 必须是指定类型或其子类
from typing import Sized
TS = TypeVar("TS", bound=Sized)  # T 必须实现 __len__

# 泛型函数：返回类型与输入类型一致
def first(items: List[T]) -> T:
    return items[0]

result_int: int = first([1, 2, 3])      # T 推断为 int
result_str: str = first(["a", "b"])     # T 推断为 str

# 使用约束的 TypeVar
def double(value: N) -> N:
    return value * 2  # type: ignore

print(double(3))    # 6
print(double(3.14)) # 6.28
```

### Generic 类

```python
from typing import TypeVar, Generic, Optional

T = TypeVar("T")

# 继承 Generic[T] 创建泛型类
class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []

    def push(self, item: T) -> None:
        self._items.append(item)

    def pop(self) -> T:
        return self._items.pop()

    def peek(self) -> Optional[T]:
        return self._items[-1] if self._items else None

    def is_empty(self) -> bool:
        return len(self._items) == 0

# 使用时指定具体类型
int_stack: Stack[int] = Stack()
int_stack.push(1)
int_stack.push(2)
top: int = int_stack.pop()  # 静态分析知道返回 int

# 多类型参数的泛型类
K = TypeVar("K")
V = TypeVar("V")

class Pair(Generic[K, V]):
    def __init__(self, key: K, value: V) -> None:
        self.key = key
        self.value = value

    def swap(self) -> "Pair[V, K]":
        return Pair(self.value, self.key)

p: Pair[str, int] = Pair("age", 30)
swapped: Pair[int, str] = p.swap()
```

### 泛型函数

```python
from typing import TypeVar, Callable, Iterable

T = TypeVar("T")
R = TypeVar("R")

# 泛型函数：接受任意类型的列表，返回同类型元素
def last(items: list[T]) -> T:
    return items[-1]

# 高阶泛型函数：map 的类型安全版本
def transform(items: list[T], func: Callable[[T], R]) -> list[R]:
    return [func(item) for item in items]

# 使用示例
nums = [1, 2, 3, 4]
strs: list[str] = transform(nums, str)   # T=int, R=str
lens: list[int] = transform(["ab", "cde"], len)  # T=str, R=int

# 泛型与 Iterable
def to_list(iterable: Iterable[T]) -> list[T]:
    return list(iterable)

result: list[int] = to_list(range(5))
```

## Protocol

### Protocol 的定义

```python
from typing import Protocol

# Protocol 定义结构化接口，无需显式继承
class Drawable(Protocol):
    def draw(self) -> None:
        ...  # 使用 ... 表示抽象方法体

class Resizable(Protocol):
    def resize(self, factor: float) -> None:
        ...

# 任何实现了 draw 方法的类都满足 Drawable 协议
class Circle:
    def draw(self) -> None:
        print("Drawing circle")

class Square:
    def draw(self) -> None:
        print("Drawing square")

# 函数接受满足协议的任意对象
def render(shape: Drawable) -> None:
    shape.draw()

render(Circle())  # OK，Circle 有 draw 方法
render(Square())  # OK，Square 有 draw 方法

# 组合多个 Protocol
class DrawableResizable(Drawable, Resizable, Protocol):
    pass
```

### 结构子类型（鸭子类型的静态版本）

```python
from typing import Protocol

# 传统鸭子类型：运行时检查，无静态分析支持
# Protocol：编译期/静态分析时检查，保留鸭子类型的灵活性

class Closeable(Protocol):
    def close(self) -> None:
        ...

class FileWrapper:
    def close(self) -> None:
        print("File closed")

class DatabaseConnection:
    def close(self) -> None:
        print("DB connection closed")

# 两个类都没有继承 Closeable，但都满足协议
def cleanup(resource: Closeable) -> None:
    resource.close()

cleanup(FileWrapper())          # OK
cleanup(DatabaseConnection())   # OK

# Protocol 支持属性检查
class HasName(Protocol):
    name: str  # 要求对象有 name 属性

class Person:
    def __init__(self, name: str) -> None:
        self.name = name

def greet(obj: HasName) -> str:
    return f"Hello, {obj.name}"

greet(Person("Alice"))  # OK
```

### runtime_checkable

```python
from typing import Protocol, runtime_checkable

# 加上 @runtime_checkable 后可在运行时用 isinstance 检查
@runtime_checkable
class Drawable(Protocol):
    def draw(self) -> None:
        ...

class Circle:
    def draw(self) -> None:
        print("Drawing circle")

class Triangle:
    pass  # 没有 draw 方法

c = Circle()
t = Triangle()

# 运行时检查（只检查方法是否存在，不检查签名）
print(isinstance(c, Drawable))  # True
print(isinstance(t, Drawable))  # False

# 注意：没有 @runtime_checkable 时使用 isinstance 会抛出 TypeError
@runtime_checkable
class Sized(Protocol):
    def __len__(self) -> int:
        ...

print(isinstance([1, 2, 3], Sized))  # True
print(isinstance("hello", Sized))    # True
print(isinstance(42, Sized))         # False
```

## 高级类型

### Literal 类型

```python
from typing import Literal

# Literal 限制变量只能取特定值
Direction = Literal["north", "south", "east", "west"]
StatusCode = Literal[200, 404, 500]

def move(direction: Direction) -> None:
    print(f"Moving {direction}")

move("north")   # OK
move("up")      # 静态检查报错：不在 Literal 范围内

# 函数返回 Literal 类型
def get_status() -> Literal["ok", "error"]:
    return "ok"

# Literal 与 Union 结合
from typing import Union
Result = Union[Literal["success"], Literal["failure"], int]

# 常用于区分函数行为的标志参数
def open_file(path: str, mode: Literal["r", "w", "a", "rb", "wb"]) -> None:
    pass
```

### TypedDict

```python
from typing import TypedDict, Required, NotRequired

# TypedDict 为字典定义精确的键值类型
class UserInfo(TypedDict):
    name: str       # 必填键
    age: int        # 必填键
    email: str      # 必填键

user: UserInfo = {"name": "Alice", "age": 30, "email": "alice@example.com"}

# total=False 使所有键变为可选
class PartialConfig(TypedDict, total=False):
    host: str
    port: int
    debug: bool

config: PartialConfig = {"host": "localhost"}  # OK，其他键可省略

# Python 3.11+ 混合必填和可选键
class Config(TypedDict):
    host: str                        # 必填
    port: int                        # 必填
    debug: NotRequired[bool]         # 可选
    timeout: NotRequired[float]      # 可选

# 继承 TypedDict
class AdminInfo(UserInfo):
    role: str       # 在 UserInfo 基础上增加 role 键

admin: AdminInfo = {"name": "Bob", "age": 25, "email": "bob@example.com", "role": "admin"}
```

### Final

```python
from typing import Final

# Final 声明常量，不允许重新赋值
MAX_SIZE: Final = 100
PI: Final[float] = 3.14159
APP_NAME: Final = "MyApp"

# 静态检查工具会阻止以下操作
# MAX_SIZE = 200  # 错误：不能重新赋值 Final 变量

class Config:
    # 类中的 Final 属性
    VERSION: Final = "1.0.0"
    DEBUG: Final[bool] = False

    def __init__(self) -> None:
        self.max_retries: Final = 3  # 实例级 Final，只能在 __init__ 中赋值

# Final 与继承：子类不能覆盖 Final 方法或属性
class Base:
    def method(self) -> None: ...

from typing import final

@final  # 标记类不可被继承
class Singleton:
    pass

class Base2:
    @final  # 标记方法不可被子类覆盖
    def important(self) -> None:
        pass
```

### ClassVar

```python
from typing import ClassVar

# ClassVar 明确标注类变量（区别于实例变量）
class Counter:
    # ClassVar 表示这是类级别的变量，不属于实例
    count: ClassVar[int] = 0
    instances: ClassVar[list["Counter"]] = []

    def __init__(self, name: str) -> None:
        self.name: str = name          # 实例变量
        Counter.count += 1
        Counter.instances.append(self)

c1 = Counter("first")
c2 = Counter("second")
print(Counter.count)  # 2

# dataclass 中 ClassVar 字段不会被包含在 __init__ 中
from dataclasses import dataclass

@dataclass
class Config:
    default_timeout: ClassVar[int] = 30  # 不在 __init__ 参数中
    host: str = "localhost"              # 在 __init__ 参数中
    port: int = 8080                     # 在 __init__ 参数中
```

### Annotated

```python
from typing import Annotated

# Annotated[T, metadata] 在类型上附加额外元数据
# 元数据对运行时无影响，供第三方工具（如 FastAPI、Pydantic）使用

# 附加验证约束（配合 Pydantic 使用）
PositiveInt = Annotated[int, "must be positive"]
Email = Annotated[str, "must be valid email format"]

# FastAPI 中的典型用法
from typing import Annotated

# 模拟 FastAPI 的 Query 注解
class Query:
    def __init__(self, description: str = "", ge: int = 0) -> None:
        self.description = description
        self.ge = ge

def get_items(
    skip: Annotated[int, Query(description="跳过的条数", ge=0)] = 0,
    limit: Annotated[int, Query(description="返回的最大条数", ge=1)] = 10,
) -> list:
    return []

# 自定义元数据
from dataclasses import dataclass

@dataclass
class Gt:
    value: float

@dataclass
class Lt:
    value: float

# 附加范围约束元数据
Percentage = Annotated[float, Gt(0.0), Lt(100.0)]

def set_discount(rate: Percentage) -> None:
    pass
```

### ParamSpec 与 Concatenate

```python
from typing import ParamSpec, Callable, TypeVar, Concatenate
import functools

# ParamSpec 捕获函数的参数规格，用于装饰器类型注解
P = ParamSpec("P")  # 捕获参数列表
R = TypeVar("R")    # 捕获返回值类型

# 类型安全的装饰器：保留被装饰函数的参数类型信息
def log_call(func: Callable[P, R]) -> Callable[P, R]:
    @functools.wraps(func)
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Done {func.__name__}")
        return result
    return wrapper

@log_call
def add(a: int, b: int) -> int:
    return a + b

# 静态分析知道 add 仍然接受 (int, int) -> int
result: int = add(1, 2)

# Concatenate 在参数列表前插入额外参数
# 常用于给函数添加第一个固定参数（如 request 对象）
def with_user(func: Callable[Concatenate[str, P], R]) -> Callable[P, R]:
    """自动注入 user 参数的装饰器"""
    @functools.wraps(func)
    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
        return func("current_user", *args, **kwargs)
    return wrapper

@with_user
def get_profile(user: str, profile_id: int) -> dict:
    return {"user": user, "id": profile_id}

# 调用时不需要传 user 参数
profile = get_profile(42)  # 自动注入 user="current_user"
```

## 类型检查工具

### mypy 基本使用

```bash
# 安装 mypy
pip install mypy

# 检查单个文件
mypy script.py

# 检查整个包
mypy my_package/

# 常用选项
mypy --strict script.py              # 开启所有严格检查
mypy --ignore-missing-imports script.py  # 忽略缺少类型存根的第三方库
mypy --disallow-untyped-defs script.py   # 要求所有函数都有类型注解
mypy --show-error-codes script.py        # 显示错误代码，便于针对性忽略
```

```ini
# mypy.ini 或 pyproject.toml 中的配置
[mypy]
python_version = 3.11
strict = true
ignore_missing_imports = true
disallow_untyped_defs = true
warn_return_any = true
warn_unused_ignores = true

# 对特定模块放宽检查
[mypy-third_party_lib.*]
ignore_missing_imports = true
```

```python
# mypy 常见错误示例与修复

# 错误：Argument 1 to "greet" has incompatible type "int"; expected "str"
def greet(name: str) -> str:
    return f"Hello, {name}"

greet(42)  # mypy 报错

# 修复：传入正确类型
greet(str(42))  # OK

# 错误：Item "None" of "Optional[str]" has no attribute "upper"
def process(value: str | None) -> str:
    return value.upper()  # mypy 报错：value 可能为 None

# 修复：先做 None 检查
def process_safe(value: str | None) -> str:
    if value is None:
        return ""
    return value.upper()  # OK，此处 value 已确定为 str
```

### pyright 简介

```bash
# 安装 pyright（微软出品，VS Code Pylance 的底层）
pip install pyright
# 或通过 npm 安装
npm install -g pyright

# 基本使用
pyright script.py
pyright my_package/

# 生成配置文件
pyright --createstub requests  # 为第三方库生成类型存根
```

```json
// pyrightconfig.json 配置示例
{
  "pythonVersion": "3.11",
  "typeCheckingMode": "strict",  // off | basic | standard | strict
  "include": ["src"],
  "exclude": ["**/node_modules", "**/__pycache__"],
  "reportMissingImports": true,
  "reportMissingTypeStubs": false,
  "reportUnknownVariableType": true
}
```

```text
mypy vs pyright 对比：

- mypy：Python 官方推荐，社区最广泛，插件生态丰富
- pyright：微软出品，速度更快，VS Code 集成更好（Pylance）
- 两者规则略有差异，大型项目可同时使用
```

### 类型忽略注释

```python
# type: ignore 告诉 mypy/pyright 忽略该行的类型错误
result = some_dynamic_function()  # type: ignore

# 指定忽略的错误代码（推荐，更精确）
x: int = "hello"  # type: ignore[assignment]

# 忽略整个文件（放在文件顶部）
# mypy: ignore-errors

# pyright 的忽略注释
result = dynamic()  # pyright: ignore[reportUnknownVariableType]

# noqa 用于 linter（如 flake8、ruff），与类型检查无关
import os  # noqa: F401  # 忽略"未使用的导入"警告

# 最佳实践：尽量少用 type: ignore，优先修复类型问题
# 必须使用时，加上注释说明原因
legacy_data = get_legacy_data()  # type: ignore[return-value]  # 旧接口无类型注解
```

## 代码风格（PEP 8）

### 命名规范

```python
# 变量：小写字母 + 下划线（snake_case）
user_name = "Alice"
max_retry_count = 3
is_valid = True

# 函数：小写字母 + 下划线（snake_case）
def calculate_total_price(items: list) -> float:
    pass

def get_user_by_id(user_id: int) -> dict:
    pass

# 类：首字母大写（PascalCase / UpperCamelCase）
class UserProfile:
    pass

class HttpRequestHandler:
    pass

# 常量：全大写 + 下划线（SCREAMING_SNAKE_CASE）
MAX_CONNECTIONS = 100
DEFAULT_TIMEOUT = 30.0
BASE_URL = "https://api.example.com"

# 私有变量/方法：单下划线前缀（约定私有，不强制）
class MyClass:
    def __init__(self) -> None:
        self._internal_state = 0  # 约定私有

    def _helper(self) -> None:   # 约定私有方法
        pass

# 名称修饰：双下划线前缀（触发 name mangling，真正私有）
class Base:
    def __init__(self) -> None:
        self.__secret = "hidden"  # 外部访问需用 _Base__secret

# 特殊方法：双下划线前后（dunder methods）
class Vector:
    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other: "Vector") -> "Vector":
        return Vector(self.x + other.x, self.y + other.y)
```

### 缩进与行长

```python
# 缩进：4 个空格（不使用 Tab）
def function():
    if True:
        for i in range(10):
            print(i)  # 每层缩进 4 空格

# 行长：最大 79 字符（PEP 8），实践中常放宽到 88（black 默认）或 120

# 长函数调用的换行：使用括号隐式续行
result = some_function(
    argument_one,
    argument_two,
    argument_three,
    keyword_arg=value,
)

# 长条件判断的换行
if (
    condition_one
    and condition_two
    and condition_three
):
    do_something()

# 长字符串的换行
message = (
    "This is a very long message that "
    "spans multiple lines using "
    "implicit string concatenation."
)

# 链式方法调用的换行
result = (
    some_object
    .method_one()
    .method_two()
    .method_three()
)
```

### 空行规范

```python
# 顶层定义之间：2 个空行
import os


MAX_SIZE = 100  # 常量


def top_level_function():  # 顶层函数前 2 个空行
    pass


class MyClass:  # 顶层类前 2 个空行

    # 类内方法之间：1 个空行
    def method_one(self) -> None:
        pass

    def method_two(self) -> None:
        pass

    # 类内逻辑分组：1 个空行
    def complex_method(self) -> None:
        # 第一步：初始化
        data = []
        count = 0

        # 第二步：处理
        for i in range(10):
            data.append(i)

        # 第三步：返回
        return data
```

### 导入顺序（isort）

```python
# PEP 8 规定导入分三组，组间空一行：
# 1. 标准库
# 2. 第三方库
# 3. 本地模块

# 标准库
import os
import sys
from pathlib import Path
from typing import Optional, List

# 第三方库
import requests
import numpy as np
from fastapi import FastAPI

# 本地模块
from myapp.models import User
from myapp.utils import helper

# isort 自动排序导入
# pip install isort
# isort script.py
# isort --check-only script.py  # 仅检查，不修改
```

```ini
# pyproject.toml 中的 isort 配置
[tool.isort]
profile = "black"          # 与 black 兼容的配置
line_length = 88
multi_line_output = 3
include_trailing_comma = true
```

### 代码格式化工具

```bash
# black：不妥协的代码格式化工具，几乎无配置项
pip install black

black script.py              # 格式化单个文件
black my_package/            # 格式化整个目录
black --check script.py      # 仅检查，不修改
black --diff script.py       # 显示差异
black --line-length 88 .     # 指定行长（默认 88）
```

```bash
# ruff：极速 linter + formatter（Rust 实现，替代 flake8 + black + isort）
pip install ruff

ruff check script.py         # 检查代码问题
ruff check --fix script.py   # 自动修复可修复的问题
ruff format script.py        # 格式化代码（类似 black）
ruff check .                 # 检查整个项目
```

```toml
# pyproject.toml 中的 ruff 配置
[tool.ruff]
line-length = 88
target-version = "py311"

[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "UP",  # pyupgrade
]
ignore = ["E501"]  # 忽略行长检查（由 formatter 处理）

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

## 性能优化技巧

### 避免不必要的全局变量查找

```python
import math
import timeit

# 慢：每次循环都查找全局变量 math.sqrt
def slow_sqrt_sum(n: int) -> float:
    total = 0.0
    for i in range(n):
        total += math.sqrt(i)  # 每次都要查找 math -> sqrt
    return total

# 快：将全局变量缓存为局部变量
def fast_sqrt_sum(n: int) -> float:
    sqrt = math.sqrt  # 一次查找，缓存为局部变量
    total = 0.0
    for i in range(n):
        total += sqrt(i)  # 局部变量查找比全局快
    return total

# 同理，避免在循环中重复访问模块属性
import os.path

# 慢
def slow_check(paths: list[str]) -> list[bool]:
    return [os.path.exists(p) for p in paths]  # 每次查找 os.path.exists

# 快
def fast_check(paths: list[str]) -> list[bool]:
    exists = os.path.exists  # 缓存函数引用
    return [exists(p) for p in paths]
```

### 使用局部变量缓存

```python
# 在循环中缓存重复计算的结果
def process_data(data: list[dict]) -> list[str]:
    result = []
    append = result.append  # 缓存 list.append 方法，避免每次属性查找

    for item in data:
        name = item["name"]          # 缓存字典查找结果
        processed = name.strip().lower()  # 避免重复访问 item["name"]
        append(processed)

    return result

# 缓存属性访问
class DataProcessor:
    def __init__(self, config: dict) -> None:
        self.config = config

    def run(self, items: list) -> list:
        # 缓存 self.config 避免在循环中重复属性查找
        config = self.config
        threshold = config.get("threshold", 0)
        multiplier = config.get("multiplier", 1)

        return [
            item * multiplier
            for item in items
            if item > threshold
        ]
```

### 列表推导式 vs 循环

```python
import timeit

data = list(range(10000))

# 普通 for 循环（最慢）
def loop_square(nums: list[int]) -> list[int]:
    result = []
    for n in nums:
        result.append(n ** 2)
    return result

# 列表推导式（比 for 循环快约 30-50%）
def comprehension_square(nums: list[int]) -> list[int]:
    return [n ** 2 for n in nums]

# map + lambda（与列表推导式相近，lambda 有额外开销）
def map_lambda_square(nums: list[int]) -> list[int]:
    return list(map(lambda n: n ** 2, nums))

# map + 内置函数（最快，避免了 lambda 开销）
def map_builtin(nums: list[int]) -> list[int]:
    return list(map(abs, nums))  # 使用内置函数时 map 最快

# 生成器表达式：内存友好，适合一次性消费
def gen_square(nums: list[int]):
    return (n ** 2 for n in nums)  # 惰性求值，不立即创建列表

# 大数据集求和时，生成器比列表推导式更省内存
total = sum(n ** 2 for n in range(1_000_000))  # 不创建中间列表
```

### __slots__ 减少内存占用

```python
import sys

# 普通类：每个实例有 __dict__，占用较多内存
class PointDict:
    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

# 使用 __slots__：禁用 __dict__，用固定内存布局存储属性
class PointSlots:
    __slots__ = ("x", "y")  # 声明允许的属性名

    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

p1 = PointDict(1.0, 2.0)
p2 = PointSlots(1.0, 2.0)

print(sys.getsizeof(p1))  # 约 48 bytes（不含 __dict__）
print(sys.getsizeof(p2))  # 约 56 bytes，但无 __dict__ 开销

# 大量实例时内存差异显著
points_dict = [PointDict(i, i) for i in range(100_000)]
points_slots = [PointSlots(i, i) for i in range(100_000)]
# slots 版本内存占用约少 30-50%

# __slots__ 的限制
class SlottedClass:
    __slots__ = ("x", "y")

obj = SlottedClass()
obj.x = 1
# obj.z = 3  # AttributeError：不能添加 __slots__ 之外的属性

# 继承时需注意：子类也需声明 __slots__，否则仍有 __dict__
class Point3D(PointSlots):
    __slots__ = ("z",)  # 只需声明新增属性

    def __init__(self, x: float, y: float, z: float) -> None:
        super().__init__(x, y)
        self.z = z
```

### 使用 collections 替代手动实现

```python
from collections import defaultdict, Counter, deque, OrderedDict, namedtuple
from collections import ChainMap

# defaultdict：避免手动检查键是否存在
# 手动实现（慢且冗余）
word_count_manual: dict[str, int] = {}
for word in ["a", "b", "a", "c", "b", "a"]:
    if word not in word_count_manual:
        word_count_manual[word] = 0
    word_count_manual[word] += 1

# defaultdict（简洁高效）
word_count = defaultdict(int)
for word in ["a", "b", "a", "c", "b", "a"]:
    word_count[word] += 1  # 键不存在时自动初始化为 0

# Counter：专为计数设计
from collections import Counter
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
counter = Counter(words)
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]

# deque：双端队列，O(1) 的头尾操作（list 头部操作是 O(n)）
queue = deque(maxlen=5)  # 固定大小，超出时自动丢弃旧元素
queue.append(1)          # 右端添加 O(1)
queue.appendleft(0)      # 左端添加 O(1)
queue.popleft()          # 左端删除 O(1)，比 list.pop(0) 快得多

# namedtuple：轻量级不可变数据类，比 dict 更省内存
Point = namedtuple("Point", ["x", "y"])
p = Point(1.0, 2.0)
print(p.x, p.y)   # 通过名称访问
print(p[0], p[1]) # 也支持索引访问

# ChainMap：多个字典的逻辑合并（不复制数据）
defaults = {"color": "red", "size": 10}
overrides = {"color": "blue"}
config = ChainMap(overrides, defaults)
print(config["color"])  # "blue"（优先使用 overrides）
print(config["size"])   # 10（从 defaults 获取）
```

### 性能分析工具

```bash
# cProfile：标准库内置，函数级别性能分析
python -m cProfile -s cumulative script.py

# 输出到文件，再用 pstats 分析
python -m cProfile -o output.prof script.py
python -m pstats output.prof
```

```python
import cProfile
import pstats
import io

# 在代码中使用 cProfile
def slow_function():
    return sum(i ** 2 for i in range(100_000))

# 方式一：直接运行
cProfile.run("slow_function()", sort="cumulative")

# 方式二：使用 Profile 对象，获取更多控制
profiler = cProfile.Profile()
profiler.enable()

slow_function()  # 被分析的代码

profiler.disable()

# 格式化输出
stream = io.StringIO()
stats = pstats.Stats(profiler, stream=stream)
stats.sort_stats("cumulative")
stats.print_stats(10)  # 只显示前 10 行
print(stream.getvalue())

# 使用 contextmanager 封装
from contextlib import contextmanager

@contextmanager
def profile_block(sort_by: str = "cumulative", lines: int = 20):
    """方便地对代码块进行性能分析"""
    pr = cProfile.Profile()
    pr.enable()
    yield
    pr.disable()
    ps = pstats.Stats(pr).sort_stats(sort_by)
    ps.print_stats(lines)

with profile_block():
    result = slow_function()
```

```bash
# line_profiler：行级别性能分析（需要安装）
pip install line-profiler
```

```python
# line_profiler 使用方式
# 在需要分析的函数上加 @profile 装饰器（运行时由 kernprof 注入）

@profile  # type: ignore  # kernprof 运行时注入，IDE 会报未定义
def matrix_multiply(a: list, b: list) -> list:
    n = len(a)
    result = [[0] * n for _ in range(n)]
    for i in range(n):           # 这行耗时多少？
        for j in range(n):       # 这行耗时多少？
            for k in range(n):   # 这行耗时多少？
                result[i][j] += a[i][k] * b[k][j]
    return result
```

```bash
# 运行 line_profiler
kernprof -l -v script.py

# 输出示例：
# Line #  Hits    Time  Per Hit  % Time  Line Contents
# =====================================================
#      6   100   1234.0    12.3     45.2  for i in range(n):
#      7  1000   2345.0     2.3     85.6  for j in range(n):
```
