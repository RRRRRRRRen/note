# 标准库与常用工具

## collections

### Counter（计数器）

Counter 用于统计可迭代对象中各元素的出现次数，返回一个字典子类。

```python
from collections import Counter

# 统计字符串中每个字符的频次
c = Counter("abracadabra")
print(c)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

# 统计列表元素频次
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
wc = Counter(words)
print(wc.most_common(2))  # [('apple', 3), ('banana', 2)]

# Counter 支持算术运算
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)  # Counter({'a': 4, 'b': 3})
print(c1 - c2)  # Counter({'a': 2})  负数结果被丢弃

# 更新计数
c1.update(["a", "a", "c"])
print(c1)  # Counter({'a': 5, 'c': 1, 'b': 1})
```

### defaultdict（默认字典）

defaultdict 在访问不存在的键时，自动调用工厂函数生成默认值，避免 KeyError。

```python
from collections import defaultdict

# 工厂函数为 list，缺失键自动初始化为空列表
dd = defaultdict(list)
for word in ["apple", "banana", "avocado", "blueberry"]:
    dd[word[0]].append(word)  # 按首字母分组
print(dict(dd))  # {'a': ['apple', 'avocado'], 'b': ['banana', 'blueberry']}

# 工厂函数为 int，缺失键自动初始化为 0
counter = defaultdict(int)
for ch in "hello world":
    counter[ch] += 1
print(dict(counter))

# 工厂函数为 set
graph = defaultdict(set)
graph["a"].add("b")
graph["a"].add("c")
graph["b"].add("a")
print(dict(graph))  # {'a': {'b', 'c'}, 'b': {'a'}}
```

### OrderedDict（有序字典）

Python 3.7+ 普通 dict 已保持插入顺序，但 OrderedDict 提供额外的顺序操作方法。

```python
from collections import OrderedDict

od = OrderedDict()
od["one"] = 1
od["two"] = 2
od["three"] = 3

# move_to_end 将指定键移到末尾或开头
od.move_to_end("one")         # 移到末尾
od.move_to_end("three", last=False)  # 移到开头
print(list(od.keys()))  # ['three', 'two', 'one']

# popitem 默认弹出最后插入的项，last=False 弹出最早插入的项
od.popitem(last=False)  # 弹出 ('three', 3)

# OrderedDict 的相等比较考虑顺序
od1 = OrderedDict([("a", 1), ("b", 2)])
od2 = OrderedDict([("b", 2), ("a", 1)])
print(od1 == od2)   # False（顺序不同）
print(dict(od1) == dict(od2))  # True（普通字典不考虑顺序）
```

### deque（双端队列）

deque 支持从两端 O(1) 时间复杂度的插入和删除，适合实现队列和栈。

```python
from collections import deque

dq = deque([1, 2, 3])

# 两端添加元素
dq.append(4)        # 右端添加：[1, 2, 3, 4]
dq.appendleft(0)    # 左端添加：[0, 1, 2, 3, 4]

# 两端弹出元素
dq.pop()            # 右端弹出 4：[0, 1, 2, 3]
dq.popleft()        # 左端弹出 0：[1, 2, 3]

# 旋转：正数向右旋转，负数向左旋转
dq.rotate(1)   # [3, 1, 2]
dq.rotate(-1)  # [1, 2, 3]

# maxlen 限制最大长度，超出时自动从另一端丢弃
dq_fixed = deque(maxlen=3)
for i in range(5):
    dq_fixed.append(i)
print(dq_fixed)  # deque([2, 3, 4], maxlen=3)

# 批量扩展
dq.extend([4, 5])       # 右端扩展
dq.extendleft([0, -1])  # 左端逐个添加（注意顺序反转）
```

### namedtuple（命名元组）

namedtuple 创建带字段名的元组子类，兼具元组的不可变性和字典的可读性。

```python
from collections import namedtuple

# 定义命名元组类型
Point = namedtuple("Point", ["x", "y"])
p = Point(3, 4)

# 支持按名称和索引访问
print(p.x, p.y)   # 3 4
print(p[0], p[1]) # 3 4

# _asdict 转为 OrderedDict
print(p._asdict())  # {'x': 3, 'y': 4}

# _replace 返回替换指定字段后的新实例（原实例不变）
p2 = p._replace(x=10)
print(p2)  # Point(x=10, y=4)

# 实际应用：表示数据库记录
Employee = namedtuple("Employee", ["name", "dept", "salary"])
emp = Employee("Alice", "Engineering", 90000)
print(f"{emp.name} works in {emp.dept}, earns {emp.salary}")
```

### ChainMap

ChainMap 将多个字典链接为一个逻辑视图，查找时按顺序搜索各字典，写操作只作用于第一个字典。

```python
from collections import ChainMap

defaults = {"color": "red", "user": "guest", "timeout": 30}
env_vars = {"user": "admin", "debug": True}
cli_args = {"color": "blue"}

# 优先级：cli_args > env_vars > defaults
config = ChainMap(cli_args, env_vars, defaults)
print(config["color"])    # blue（来自 cli_args）
print(config["user"])     # admin（来自 env_vars）
print(config["timeout"])  # 30（来自 defaults）

# 写操作只修改第一个字典
config["color"] = "green"
print(cli_args)  # {'color': 'green'}

# maps 属性访问底层字典列表
print(config.maps)

# new_child 创建新的子映射（常用于作用域模拟）
child = config.new_child({"color": "yellow"})
print(child["color"])  # yellow
```

## itertools

### chain、chain.from_iterable

chain 将多个可迭代对象串联为一个迭代器，不创建中间列表。

```python
import itertools

# chain 串联多个可迭代对象
result = list(itertools.chain([1, 2], [3, 4], [5]))
print(result)  # [1, 2, 3, 4, 5]

# chain.from_iterable 接受一个嵌套可迭代对象并展平一层
nested = [[1, 2], [3, 4], [5, 6]]
result = list(itertools.chain.from_iterable(nested))
print(result)  # [1, 2, 3, 4, 5, 6]

# 实际应用：合并多个文件的行
import io
files = [io.StringIO("line1\nline2\n"), io.StringIO("line3\nline4\n")]
all_lines = list(itertools.chain.from_iterable(files))
print(all_lines)
```

### product、permutations、combinations

```python
import itertools

# product：笛卡尔积，等价于嵌套 for 循环
print(list(itertools.product([1, 2], ["a", "b"])))
# [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]

# repeat 参数：自身的笛卡尔积
print(list(itertools.product([0, 1], repeat=3)))
# 生成所有 3 位二进制数

# permutations：全排列（有序，不重复取）
print(list(itertools.permutations("ABC", 2)))
# [('A','B'), ('A','C'), ('B','A'), ('B','C'), ('C','A'), ('C','B')]

# combinations：组合（无序，不重复取）
print(list(itertools.combinations("ABC", 2)))
# [('A','B'), ('A','C'), ('B','C')]

# combinations_with_replacement：组合（允许重复取）
print(list(itertools.combinations_with_replacement("AB", 2)))
# [('A','A'), ('A','B'), ('B','B')]
```

### groupby

groupby 对连续相同键的元素进行分组，使用前需先排序。

```python
import itertools

data = [
    {"name": "Alice", "dept": "Engineering"},
    {"name": "Bob",   "dept": "Engineering"},
    {"name": "Carol", "dept": "Marketing"},
    {"name": "Dave",  "dept": "Marketing"},
    {"name": "Eve",   "dept": "Engineering"},  # 注意：未排序时会产生多个 Engineering 组
]

# 必须先按分组键排序
data.sort(key=lambda x: x["dept"])

for dept, members in itertools.groupby(data, key=lambda x: x["dept"]):
    names = [m["name"] for m in members]
    print(f"{dept}: {names}")
# Engineering: ['Alice', 'Bob', 'Eve']
# Marketing: ['Carol', 'Dave']
```

### islice、takewhile、dropwhile

```python
import itertools

# islice：对迭代器切片（不支持负索引）
gen = (x ** 2 for x in range(100))
print(list(itertools.islice(gen, 5)))       # [0, 1, 4, 9, 16]
print(list(itertools.islice(range(20), 5, 15, 2)))  # [5, 7, 9, 11, 13]

# takewhile：条件为真时持续取值，一旦为假立即停止
data = [1, 3, 5, 2, 7, 9]
print(list(itertools.takewhile(lambda x: x < 6, data)))  # [1, 3, 5]

# dropwhile：条件为真时跳过，一旦为假开始取剩余所有值
print(list(itertools.dropwhile(lambda x: x < 6, data)))  # [2, 7, 9]
# 注意：dropwhile 不会过滤后续元素，只跳过开头满足条件的部分
```

### cycle、repeat、count

```python
import itertools

# cycle：无限循环迭代一个序列
colors = itertools.cycle(["red", "green", "blue"])
for _ in range(6):
    print(next(colors), end=" ")  # red green blue red green blue

# repeat：重复一个值，可指定次数
print(list(itertools.repeat(0, 5)))  # [0, 0, 0, 0, 0]
# 不指定次数则无限重复，常与 map/zip 配合使用
print(list(map(pow, range(5), itertools.repeat(2))))  # [0, 1, 4, 9, 16]

# count：从起始值无限计数，可指定步长
counter = itertools.count(start=10, step=2)
print(list(itertools.islice(counter, 5)))  # [10, 12, 14, 16, 18]
```

## datetime

### date、time、datetime 对象

```python
from datetime import date, time, datetime

# date 对象：仅表示日期
d = date(2026, 2, 25)
print(d.year, d.month, d.day)  # 2026 2 25
print(date.today())            # 当前本地日期

# time 对象：仅表示时间（不含日期）
t = time(14, 30, 0)
print(t.hour, t.minute, t.second)  # 14 30 0

# datetime 对象：日期 + 时间
dt = datetime(2026, 2, 25, 14, 30, 0)
print(dt)  # 2026-02-25 14:30:00

# 获取当前时间
now = datetime.now()    # 本地时间
utc = datetime.utcnow() # UTC 时间（无时区信息，已不推荐）

# date 与 datetime 互转
print(dt.date())              # 提取 date 部分
print(dt.time())              # 提取 time 部分
print(datetime.combine(d, t)) # 合并 date 和 time
```

### timedelta 时间差

```python
from datetime import datetime, timedelta

now = datetime(2026, 2, 25, 12, 0, 0)

# 创建时间差
delta = timedelta(days=7, hours=3, minutes=30)

# 时间加减
future = now + delta
past   = now - timedelta(days=30)
print(future)  # 2026-03-04 15:30:00
print(past)    # 2026-01-26 12:00:00

# 两个 datetime 相减得到 timedelta
dt1 = datetime(2026, 1, 1)
dt2 = datetime(2026, 2, 25)
diff = dt2 - dt1
print(diff.days)         # 55
print(diff.total_seconds())  # 4752000.0
```

### 格式化与解析（strftime/strptime）

```python
from datetime import datetime

dt = datetime(2026, 2, 25, 14, 30, 45)

# strftime：datetime -> 字符串
print(dt.strftime("%Y-%m-%d"))           # 2026-02-25
print(dt.strftime("%Y/%m/%d %H:%M:%S"))  # 2026/02/25 14:30:45
print(dt.strftime("%A, %B %d, %Y"))      # Tuesday, February 25, 2026

# strptime：字符串 -> datetime
s = "2026-02-25 14:30:45"
parsed = datetime.strptime(s, "%Y-%m-%d %H:%M:%S")
print(parsed)  # 2026-02-25 14:30:45

# 常用格式符
# %Y 四位年  %m 月  %d 日
# %H 24小时  %M 分  %S 秒
# %A 星期全称  %B 月份全称  %p AM/PM
```

### 时区处理（timezone）

```python
from datetime import datetime, timezone, timedelta

# UTC 时区
utc = timezone.utc
dt_utc = datetime(2026, 2, 25, 6, 0, 0, tzinfo=utc)
print(dt_utc)  # 2026-02-25 06:00:00+00:00

# 自定义时区（东八区 UTC+8）
cst = timezone(timedelta(hours=8))
dt_cst = dt_utc.astimezone(cst)
print(dt_cst)  # 2026-02-25 14:00:00+08:00

# 获取带时区的当前时间（推荐方式）
now_utc = datetime.now(tz=timezone.utc)
print(now_utc)

# 去除时区信息（转为 naive datetime）
naive = dt_cst.replace(tzinfo=None)
print(naive)  # 2026-02-25 14:00:00
```

## re 正则表达式

### 常用元字符

```text
.       匹配任意单个字符（除换行符）
^       匹配字符串开头
$       匹配字符串结尾
*       前一个字符重复 0 次或多次（贪婪）
+       前一个字符重复 1 次或多次（贪婪）
?       前一个字符重复 0 次或 1 次；或使量词变为非贪婪
{n,m}   前一个字符重复 n 到 m 次
[]      字符集，匹配其中任意一个字符
[^]     否定字符集，匹配不在其中的字符
|       或运算
()      分组，捕获匹配内容
\d      数字，等价于 [0-9]
\D      非数字
\w      单词字符，等价于 [a-zA-Z0-9_]
\W      非单词字符
\s      空白字符（空格、制表符、换行等）
\S      非空白字符
\b      单词边界
```

### re.match vs re.search vs re.findall

```python
import re

text = "Hello, my phone is 138-1234-5678 and backup is 010-87654321"

# re.match：只匹配字符串开头，返回 Match 对象或 None
m = re.match(r"\d+", "123abc")
print(m.group())  # 123

m = re.match(r"\d+", "abc123")
print(m)  # None（开头不是数字）

# re.search：搜索整个字符串，返回第一个匹配
m = re.search(r"\d{3}-\d{4}-\d{4}", text)
print(m.group())  # 138-1234-5678

# re.findall：返回所有匹配的列表
phones = re.findall(r"\d[\d-]+\d", text)
print(phones)  # ['138-1234-5678', '010-87654321']

# re.finditer：返回所有匹配的迭代器（Match 对象）
for m in re.finditer(r"\d[\d-]+\d", text):
    print(m.group(), m.start(), m.end())
```

### 分组与命名分组

```python
import re

# 普通分组：用 () 捕获，通过 group(n) 访问
m = re.search(r"(\d{4})-(\d{2})-(\d{2})", "Today is 2026-02-25")
if m:
    print(m.group(0))  # 2026-02-25（完整匹配）
    print(m.group(1))  # 2026（第一组）
    print(m.group(2))  # 02
    print(m.group(3))  # 25
    print(m.groups())  # ('2026', '02', '25')

# 命名分组：(?P<name>...) 通过名称访问
m = re.search(r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})", "2026-02-25")
if m:
    print(m.group("year"))   # 2026
    print(m.group("month"))  # 02
    print(m.groupdict())     # {'year': '2026', 'month': '02', 'day': '25'}

# 非捕获分组：(?:...) 分组但不捕获
m = re.search(r"(?:https?|ftp)://([\w.]+)", "Visit https://example.com today")
if m:
    print(m.group(1))  # example.com（只捕获域名，不捕获协议）
```

### re.sub 替换

```python
import re

text = "Hello   World,  this  is   Python"

# 基本替换：将多个空格替换为单个空格
result = re.sub(r"\s+", " ", text)
print(result)  # Hello World, this is Python

# 使用分组引用：\1 引用第一个捕获组
# 将日期格式从 YYYY-MM-DD 转为 DD/MM/YYYY
date_str = "Date: 2026-02-25"
result = re.sub(r"(\d{4})-(\d{2})-(\d{2})", r"\3/\2/\1", date_str)
print(result)  # Date: 25/02/2026

# 使用函数作为替换参数
def double_number(m):
    return str(int(m.group()) * 2)

result = re.sub(r"\d+", double_number, "I have 3 cats and 5 dogs")
print(result)  # I have 6 cats and 10 dogs

# count 参数限制替换次数
result = re.sub(r"\s+", "-", "a b c d e", count=2)
print(result)  # a-b-c d e
```

### 编译正则（re.compile）

```python
import re

# 编译正则表达式，适合在循环中复用同一模式
pattern = re.compile(r"\b[A-Z][a-z]+\b")  # 匹配首字母大写的单词

texts = ["Hello World", "python Programming", "Alice and Bob"]
for text in texts:
    matches = pattern.findall(text)
    print(matches)
# ['Hello', 'World']
# ['Programming']
# ['Alice', 'Bob']

# 编译时可指定标志
pattern_ci = re.compile(r"python", re.IGNORECASE)  # 忽略大小写
print(pattern_ci.findall("Python PYTHON python"))  # ['Python', 'PYTHON', 'python']

# 多行模式：^ 和 $ 匹配每行的开头和结尾
pattern_ml = re.compile(r"^\d+", re.MULTILINE)
text = "1 first\n2 second\n3 third"
print(pattern_ml.findall(text))  # ['1', '2', '3']
```

### 常用正则模式示例

```python
import re

# 邮箱地址
email_pattern = re.compile(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}")
print(email_pattern.findall("Contact us at info@example.com or support@test.org"))

# 手机号（中国大陆）
phone_pattern = re.compile(r"1[3-9]\d{9}")
print(phone_pattern.findall("Phone: 13812345678 or 18987654321"))

# URL
url_pattern = re.compile(r"https?://[^\s]+")
print(url_pattern.findall("Visit https://example.com or http://test.org/path?q=1"))

# IP 地址
ip_pattern = re.compile(r"\b(?:\d{1,3}\.){3}\d{1,3}\b")
print(ip_pattern.findall("Server at 192.168.1.1 and 10.0.0.255"))

# 中文字符
chinese_pattern = re.compile(r"[\u4e00-\u9fff]+")
print(chinese_pattern.findall("Hello 你好 World 世界"))
```

## typing 模块

### 基本类型注解

```python
# 变量注解
name: str = "Alice"
age: int = 30
score: float = 95.5
active: bool = True

# 函数参数与返回值注解
def greet(name: str, times: int = 1) -> str:
    return (f"Hello, {name}! " * times).strip()

# 注解不强制类型检查，仅作为文档和静态分析工具的提示
# 运行时可通过 __annotations__ 查看
print(greet.__annotations__)
# {'name': <class 'str'>, 'times': <class 'int'>, 'return': <class 'str'>}
```

### List、Dict、Tuple、Optional、Union

```python
from typing import List, Dict, Tuple, Optional, Union

# List：指定元素类型的列表
def sum_numbers(nums: List[int]) -> int:
    return sum(nums)

# Dict：指定键值类型的字典
def get_user(users: Dict[str, int], name: str) -> int:
    return users.get(name, -1)

# Tuple：固定长度和类型的元组
def get_point() -> Tuple[int, int]:
    return (3, 4)

# Tuple 可变长度：Tuple[int, ...] 表示任意数量的 int
def process_coords(coords: Tuple[float, ...]) -> None:
    for c in coords:
        print(c)

# Optional[X] 等价于 Union[X, None]，表示可能为 None
def find_user(user_id: int) -> Optional[str]:
    users = {1: "Alice", 2: "Bob"}
    return users.get(user_id)  # 可能返回 None

# Union：多种类型之一（Python 3.10+ 可用 X | Y 语法）
def parse_input(value: Union[str, int]) -> str:
    return str(value)

# Python 3.10+ 新语法
def parse_input_new(value: str | int) -> str:
    return str(value)
```

### Callable、TypeVar

```python
from typing import Callable, TypeVar

# Callable[[参数类型列表], 返回类型]
def apply(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)

print(apply(lambda x, y: x + y, 3, 4))  # 7

# 无参数的 Callable
def run(callback: Callable[[], None]) -> None:
    callback()

# TypeVar：定义泛型类型变量
T = TypeVar("T")

def first(items: list[T]) -> T:
    """返回列表第一个元素，保持类型信息"""
    return items[0]

# 调用时类型推断正确
x: int = first([1, 2, 3])
s: str = first(["a", "b", "c"])

# 带约束的 TypeVar
from typing import TypeVar
Numeric = TypeVar("Numeric", int, float)

def double(x: Numeric) -> Numeric:
    return x * 2
```

### Protocol

Protocol 用于定义结构化子类型（鸭子类型的静态检查版本），无需显式继承。

```python
from typing import Protocol, runtime_checkable

# 定义 Protocol：任何实现了 draw 方法的类都满足此协议
class Drawable(Protocol):
    def draw(self) -> None:
        ...

class Circle:
    def draw(self) -> None:
        print("Drawing circle")

class Square:
    def draw(self) -> None:
        print("Drawing square")

def render(shape: Drawable) -> None:
    shape.draw()

# Circle 和 Square 无需继承 Drawable，只要实现了 draw 方法即可
render(Circle())  # Drawing circle
render(Square())  # Drawing square

# runtime_checkable 允许在运行时使用 isinstance 检查
@runtime_checkable
class Sizeable(Protocol):
    def __len__(self) -> int:
        ...

print(isinstance([1, 2, 3], Sizeable))  # True
print(isinstance("hello", Sizeable))    # True
print(isinstance(42, Sizeable))         # False
```

## 其他常用模块

### copy（浅拷贝 vs 深拷贝）

```python
import copy

# 浅拷贝：复制对象本身，但内部嵌套对象仍共享引用
original = {"name": "Alice", "scores": [90, 85, 92]}
shallow = copy.copy(original)

shallow["name"] = "Bob"          # 修改顶层不影响原对象
shallow["scores"].append(88)     # 修改嵌套列表会影响原对象！

print(original["name"])    # Alice（未受影响）
print(original["scores"])  # [90, 85, 92, 88]（受影响）

# 深拷贝：递归复制所有嵌套对象，完全独立
original2 = {"name": "Alice", "scores": [90, 85, 92]}
deep = copy.deepcopy(original2)

deep["scores"].append(88)
print(original2["scores"])  # [90, 85, 92]（未受影响）

# 列表的浅拷贝方式对比
lst = [[1, 2], [3, 4]]
shallow_lst = lst[:]          # 切片浅拷贝
shallow_lst2 = lst.copy()     # list.copy() 浅拷贝
deep_lst = copy.deepcopy(lst) # 深拷贝
```

### hashlib（哈希计算）

```python
import hashlib

# MD5（不推荐用于安全场景，仅用于校验）
md5 = hashlib.md5("hello world".encode()).hexdigest()
print(md5)  # 5eb63bbbe01eeed093cb22bb8f5acdc3

# SHA-256（推荐用于安全场景）
sha256 = hashlib.sha256("hello world".encode()).hexdigest()
print(sha256)

# SHA-512
sha512 = hashlib.sha512(b"hello world").hexdigest()
print(sha512[:32], "...")  # 截断显示

# 对大文件分块计算哈希（避免一次性读入内存）
def file_hash(filepath: str, algorithm: str = "sha256") -> str:
    h = hashlib.new(algorithm)
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

# 查看所有支持的算法
print(hashlib.algorithms_guaranteed)
```

### uuid（唯一标识符）

```python
import uuid

# UUID4：基于随机数，最常用
uid = uuid.uuid4()
print(uid)          # e.g. 550e8400-e29b-41d4-a716-446655440000
print(str(uid))     # 字符串形式
print(uid.hex)      # 不含连字符的十六进制字符串

# UUID1：基于时间戳和 MAC 地址（包含机器信息，注意隐私）
uid1 = uuid.uuid1()
print(uid1)

# UUID3/UUID5：基于命名空间和名称的确定性 UUID
# UUID3 使用 MD5，UUID5 使用 SHA-1（推荐 UUID5）
uid5 = uuid.uuid5(uuid.NAMESPACE_DNS, "example.com")
print(uid5)  # 相同输入始终产生相同 UUID

# 从字符串解析 UUID
parsed = uuid.UUID("550e8400-e29b-41d4-a716-446655440000")
print(parsed.version)  # None（UUID4 的 version 字段）
```

### random（随机数）

```python
import random

# 基本随机数
print(random.random())          # [0.0, 1.0) 的浮点数
print(random.uniform(1, 10))    # [1, 10] 的浮点数
print(random.randint(1, 6))     # [1, 6] 的整数（含两端）
print(random.randrange(0, 10, 2))  # 0,2,4,6,8 中随机取一个

# 序列操作
items = [1, 2, 3, 4, 5]
print(random.choice(items))         # 随机取一个元素
print(random.choices(items, k=3))   # 有放回随机取 3 个
print(random.sample(items, k=3))    # 无放回随机取 3 个

random.shuffle(items)               # 原地打乱（修改原列表）
print(items)

# 设置随机种子（保证可复现）
random.seed(42)
print(random.random())  # 每次运行结果相同

# 安全随机数（用于密码学场景）
import secrets
print(secrets.token_hex(16))      # 32 位十六进制字符串
print(secrets.token_urlsafe(16))  # URL 安全的 base64 字符串
print(secrets.randbelow(100))     # [0, 100) 的安全随机整数
```

### time 与 timeit（性能测量）

```python
import time
import timeit

# time.time()：返回 Unix 时间戳（浮点秒）
start = time.time()
time.sleep(0.1)  # 暂停 0.1 秒
end = time.time()
print(f"Elapsed: {end - start:.4f}s")

# time.perf_counter()：高精度计时器，推荐用于性能测量
start = time.perf_counter()
result = sum(range(1_000_000))
elapsed = time.perf_counter() - start
print(f"sum took {elapsed:.6f}s")

# time.monotonic()：单调时钟，不受系统时间调整影响
t = time.monotonic()

# timeit：精确测量小段代码的执行时间
# number 指定执行次数，返回总耗时（秒）
t = timeit.timeit("sum(range(1000))", number=10000)
print(f"Total: {t:.4f}s, Per call: {t/10000*1e6:.2f}µs")

# 使用 setup 参数导入依赖
t = timeit.timeit(
    stmt="sorted(data)",
    setup="data = list(range(1000, 0, -1))",
    number=1000
)
print(f"sorted 1000 items: {t/1000*1e6:.2f}µs per call")

# timeit.repeat：多次测量取最小值（排除偶发干扰）
results = timeit.repeat("'-'.join(str(n) for n in range(100))", repeat=5, number=1000)
print(f"Best: {min(results):.4f}s")
```
