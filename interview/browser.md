# 一、HTTP

## 1.GET和POST请求的区别

| 请求         | GET                   | POST                           |
| ------------ | --------------------- | ------------------------------ |
| **应用场景** | 幂等请求[1]           | 非幂等请求                     |
| **是否缓存** | 缓存                  | 一般不缓存                     |
| **传参方式** | 查询字符串            | 请求体                         |
| **安全性**   | 相对不安全            | 相对安全                       |
| **请求长度** | 浏览器对url长度有限制 | 可借助请求体传参，相对限制较少 |
| **参数类型** | 只允许ASCII字符       | 可以支持更多二进制类型         |

[1]幂等：指一个请求多次执行和仅执行一次的效果完全相同



## 2.POST和PUT请求的区别

PUT请求一般用于**更新数据**，而POST一般用于**创建数据**



## 3.为什么POST会发出两次请求

简介

第一次发送的是OPTIONS预检请求，状态码为204，用于询问服务器是否支持修改的请求头，如果支持，则在第二次请求中发送真正的请求。

主要用途

- 获取服务器所支持的HTTP请求方法
- 用来检查访问权限。例如，在进行CORS跨域资源共享时，对于发杂请求，就是使用OPTIONS方法发送嗅探请求，用来判断是否有对指定资源的访问权限



## 4.常见的HTTP请求头和响应头

HTTP Request Header

- Accept：浏览器能够处理的内容类型
- Accept-Charset：浏览器能够显示的字符集
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookies：当前页面设置的任何Cookies
- Host：发出请求的页面所在域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

HTTP Responses Header

- Date：表示消息发送的时间
- server：服务器名称
- Connection：浏览器与服务器之间的连接类型
- Cache-Control：空置HTTP缓存
- Content-Type：表示文档的MIME类型



## 5.常见的Content-Type

- application/x-www-form-urlencoded：浏览器原生form表单，这种方式提交的数据放在`body`中，数据按照`key1=val1&key2=val2`的方式进行编码，key和val都会进行`URL转码`
- multipart/form-data：通常用在表单上传文件的时候使用
- application/json：JSON字符串格式
- text/xml：主要用来提交XML数据



## 6.HTTP状态码 304

产生的原理：

客户端在请求一个文件的时候，发现自己缓存的文件有 `Last Modified`，那么在请求中会包含`If Modified Since`，这个时间是缓存文件的`Last Modified`。如果请求中包含`If Modified Since`，就说明已经有缓存在客户端，服务端只需要判断修改时间就可以返回304还是200了

产生的不良影响：

- 网站快照停止
- 收录减少
- 权重下降



## 7.常见的HTTP请求方法

- GET：获取数据
- POST：发送数据给服务器，一般会造成服务器资源的新增
- PUT：用于全量修改目标资源
- PATCH：用于对资源的部分修改
- DELETE：用于删除指定资源
- HEAD：获取报文首部，但是不返回报文主体内容，例如下载大文件前用于先获取文件大小，再来决定是否下载文件。
- OPTIONS：浏览器自动执行的，用来询问支持的请求方法，判断跨域请求、预检请求、目标是否安全



## 8.`HTTP1.0`和`HTTP1.1 `之间的区别

| 协议     | HTTP1.0                                | HTTP1.1                                                     |
| -------- | -------------------------------------- | ----------------------------------------------------------- |
| 链接模式 | 短链接，每次请求都需要重新建立         | 默认使用长连接                                              |
| 请求资源 | 一次性获取所有响应，不支持断点续传     | 请求头加入range头域，允许只请求一部分资源，返回码是206      |
| 缓存     | If-Modified-Since Expires 控制缓存策略 | 增加 Unmodified-Since If-Match if-None-Match 来控制缓存策略 |
| host     | 认为每台服务器都只绑定一个IP地址       | 增加host字段，这样九可以将请求发送到同一服务器上的不同网站  |
| 请求方法 | GET、POST                              | 怎加了 PUT、HEAD、OPTIONS                                   |



## 9.`HTTP1.1 `和 `HTTP2.0`的却别

| 协议       | HTTP1.1                                  | HTTP2.0                                                      |
| ---------- | ---------------------------------------- | ------------------------------------------------------------ |
| 二进制协议 | 报文头信息必须为文本，数据体可以为二进制 | 头信息和提信息都为二进制，同意称为“帧”                       |
| 多路复用   | 只能复用TCP，但是得排队请求              | 复用TCP的同时，可以不按顺序的同时发送多个请求                |
| 数据流     | -                                        | 每个数据流都有独一无二的编号，数据包发送时用来区分他属于哪个请求 |
| 头信息压缩 | -                                        | 头信息可以压缩，获知使用索引方式                             |
| 服务器推送 | -                                        | 可以主动推送静态资源                                         |



## 10.队头堵塞

简介

HTTP规定报文必须是“一发一收”，这就形成了先进先出的“串行"队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被优先处理。如果队首的请求太慢，那么队列后面的请求就不得不一起等待，结果就是他的请求承担了不应承担的事件成本，造成队头堵塞的现象。

解决方案

- 并发链接：对于一个域名允许分配多个长连接，那么相当于怎加了任务队列，不至于一个对的任务阻塞其他所有任务。
- 域名分片：将域名分出很多二级域名，他们呢都指向同样一台服务器，并能够让并发的链接变多，解决了队头堵塞问题。



## 11.`HTTP`和`HTTPS`协议的区别

- HTTPS需要CA证书，费用较贵。HTTP则不需要。
- HTTP是明文传输，HTTPS具有SSL加密
- 端口号不同，HTTP协议的端口是80，HTTPS是443



## 12.输入URL到页面完成加载的过程

1. **解析URL**：分析所需要使用的传输协议和请求资源的路径，URL不合法则转发给搜索引擎，合法则检查是否有非法字符然后进行转义。
2. **缓存判断**：浏览器判断请求的资源是否存在缓存，如果存在且未失效则直接使用，否则向服务器发送请求。
3. **DNS解析**：首先判断本地是否存在该域名IP地址的缓存，没有则请求本地DNS服务器=》根域名服务器=》顶级域名服务器=》权威域名服务器
4. **TCP三次握手**：确认客户端与服务端接收与发送的能力。
5. **发送HTTP请求**：服务器处理请求，返回HTTP报文
6. **页面渲染**：并行生成DOM树和CSS树，再通过这两个树构建渲染树，再计算元素的大小和位置，最后还是绘制。
7. **TCP四次挥手**：断开链接的过程



## 13.HTTP请求和响应报文的结构

请求体

- 请求行：请求方法、URL、HTTP协议版本号，例如`GET index/html HTTP1.1`
- 请求头：关键字+值的键值对，例如 `accept:application/json, text/plain` 
- 空行
- 请求体：例如post携带的请求数据

响应体

- 响应行：网路协议版本、状态码、状态码原因短语。例如： `HTTP/1.1 200 OK`
- 响应头：同上
- 空行
- 响应体：服务器返回的数据



## 14.URL的组成部分

- 协议：例如HTTP、FTP
- 域名：`www.baidu.com`
- 端口：如果省略则使用默认端口，HTTP：80，HTTPS：443
- 虚拟目录：从域名的第一个”/“开始到最后一个”/“结束
- 文件名：如果省略则使用默认文件名
- 参数：例如`username=123&password=123`
- 锚部分：#后面的部分

例如：`www.aspxfans.com:8080/news/index?ID=246188&name=123#name`



## 15.强缓存与协商缓存

强缓存

- 简介：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台中可以看到200返回码，size显示 from disk cache 或者 from memory cache（灰色表示缓存）
- 相关请求头：Expires、Cache-Control

协商缓存

- 简介：向服务器发送请求，服务器根据请求头的一些参数判断是否命中协商缓存，如果命中这返回304状态码，并且带上新的响应头通知浏览器读取缓存
- 相关请求头：Etag、If-None-Match、Last-Modified、If-Modified-Since



## 16.HTTP的keep-alive的作用

- 开启状态：HTTP1.0默认关闭，需要手动开启，HTTP1.1默认开启
- 作用：使客户端到服务端的链接持续有效（长连接，用于复用TCP链接），当出现对服务器的后续请求时，keep-alive功能可以避免重新建立链接
- 使用方法：请求头中添加`Connection: keep-alive`
- 优点：
  - 减少CPU和内存的占用（应为打开的连接数变少，复用了链接）
  - 减少了后续请求的延迟（无需再次握手）
- 缺点：本可以释放的资源被占用，有的请求已经结束了，但是还在链接。
- 解决方法：服务器设置过期事件和请求次数，超过事件或者次数直接断开链接。

```http
HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache
```



## 17.常见的HTTP状态码

| 类别 | 原因                          | 描述                     |
| ---- | ----------------------------- | ------------------------ |
| 1xx  | Informational 信息性状态码    | 请求正在处理             |
| 2xx  | Success 成功状态码            | 请求正常处理完毕         |
| 3xx  | Redirection 重定向状态码      | 需要进行附加操作完成请求 |
| 4xx  | Client Error 客户端错误状态码 | 服务器无法处理请求       |
| 5xx  | Server Error 服务器错误状态码 | 服务器处理请求出错       |

**2xx**

- 200 OK：表示从客户端发来的请求在服务端被正确处理
- 201 Created：请求已被实现，而且有一个新的资源已经依据请求的需要而建立。
- 202 Accepted：请求服务器已经接受，但是尚未处理，不保证完成请求，一般用于异步情况，防止HTTP一直被占用。
- 204 Not Content：请求成功，但响应报文不含实体的主体信息。
- 205 Rest Content：同204，但是要求请求方重置请求。
- 206 Partial Content：表示服务器已经成功处理了部分GET请求，响应头中会包含获取的内容范围，一般用于分段下载。

**3xx**

- 301 Moved Permanently：永久性重定向，表示资源已经被分配了新的URL。
- 302 Found：临时性重定向，表示资源被临时分配了新的URL。
- 303 See Other：表示资源存在着另一个URL，应该使用GET方法获取。
- 304 Not Modified：自从上次请求后，请求的网页内容未修改，服务器响应时，不会返回网页内容（协商缓存）
- 307 Temporary Redirect：同302 ，但是希望客户端保持请求方法不变向新的地址请求。

**4xx**

- 400 Bad Request：请求报文存在语法错误，例如传参格式不正确。
- 401 Unauthorized： 无权限
- 403 Forbidden：对请求的资源被服务器拒绝
- 403 Not Found：表示服务器上没有找到请求的资源。
- 408 Request Timeout：客户端请求超时
- 409 Confict：请求的资源可能引发冲突

**5xx**

- 500 Internal Sever Error：表示服务器在执行请求时发生了错误。
- 501 Not Implemented：表示服务器不支持当前请求所需要的某个功能。
- 503 Service Unavailable：服务器处于超负载或者停机维护状态，无法处理请求。



## 18.同样时重定向302和303、307的区别

302是http1.0的协议状态码，在http1.1版本的时候细化出303和307。303会把POST方法改为GET方法重定向请求，307则是直接保持原样重定向请求



## 19.304的过程

1. 浏览器请求资源时首先命中资源的Expires和Cache-Control强缓存头，Expies受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control：max-age指定最大神明周期。如果成功状态码仍然返回200，但是不会去请求数据，在浏览器中能明显看到from cache字样。
2. 强缓存头失效，进入协商缓存阶段，首先验证ETag，ETag可以保证每一个资源时唯一的，资源变化会导致ETag变化。服务器根据客户端上送来的If-None-Match值来判断是否命中缓存。
3. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务器返回的header中会加上Last-Modify，Last-Modify时一个时间标志该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之间的Last-Modify。服务器收到If-Modify-Since后，根据时间判断是否命中缓存。命中则返回304



## 20.DNS协议

**概念**

DNS是域名系统的缩写，提供的是一种主机名到IP地址的转换服务。他是一个有分层的DNS服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不是记住能够被机器直接读取的IP数字串。

**作用**

将域名解析为IP地址，客户端向DNS服务器发送域名查询服务，DNS服务器告知客户端Web服务器的IP地址。

**查询过程**

1. 在浏览器的缓存中查找对应的IP地址 =》
2. 将请求发送给本地DNS服务器，在本地域名服务器缓存中查找 =》
3. 向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存 =》 
4. 向权威域名服务器发送请求，域名服务器返回对应的结果 =》 
5. 本地DNS服务器将结果保存在本地缓存中 =》
6. 本地DNS服务器将结果返回给浏览器



## 21.token是什么

**简介**

token也可以称为令牌，一般由`uid + time + sign + payload`组成

```markdown
uid: 用户唯一身份标识
time：当前时间戳
sign：签名，使用hash/encrypt压缩成定长的十六进制字符串，防止第三方恶意拼接
固定参数（可选）：将一些常用的固定参数加入到token中，一般为了避免重复查库
```

**存放**

token在客户端一般存放与LocalStorage、cookie、sessionStorage中。在服务端一般存于数据库中。

session是有状态的，一般存于服务器内存或者硬盘中，当服务器采用分布式或者集群式时，session就会面对负载均衡问题。负载均衡多服务器的请客，不好确认当前用户是否登录，应为多服务器不共享session。

使用token时，客户端登录传递信息给服务端，服务端收到后，把用户信息加密传给客户端，客户端将token存放于localStorage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu界面就不需要存储session，解决负载均衡多服务器的问题。这个方法叫JWT（JSON Web Token）

**认证过程**

1. 用户登录。成功后服务器返回Token给客户端
2. 客户端收到数据后保存在客户端
3. 客户端再次访问服务器，将token放在headers中，或者其他方式传递给服务端
4. 服务端采用filter过滤器校验。校验成功返回请求的数据，校验失败返回错误码。

**加密过程**

- 需要一个随机数secret
- 后端利用secret和加密算法对payload（如账号密码）生成一个字符串（token），返回给前端
- 前端每次请求都在header中带上token
- 后端用同样的算法解密

**CSRF（Cross-site request forgery）跨站请求伪造**

token可以抵挡csrf，cookie+session不可以。

cookie：登陆后后端生成一个sessionid放在cookie中返回给客户端, 并且服务端一直记录着这个 sessionid, 客户端以后每次请求都会带上这个sessionid, 服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie就相当于拿到了sessionid ,就可以完全替代你。同时浏览器会自动携带cookie

token：同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token 进行身份的校验。浏览器不会自动携带token，所以不会劫持 token。



## 22.token过期后，页面如何实现无感刷新

**无感刷新**

本质是为了提升用户体验，当token过期时不需要用户跳回登录页重新登录，而是当token过期后，进行拦截，发送刷新token的ajax，获取新的token并进行覆盖，让用户感觉不到token已经过期。

**实现方法**

- 后端返回过期时间，前端判断，主动调用刷新。缺点：本地时间容易篡改
- 写个定时器，自动刷新。缺点：浪费资源。
- 在响应拦截其中拦截，判断token过期后，调用刷新接口。

# 二、HTTPS

## 1.什么是HTTPS协议

超文本传输安全协议是一种通过计算机网络进行安全通讯的传输协议，HTTPS经由HTTP进行通讯，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份认证、信息加密和完整性校验的功能，可以避免此类问题的发生。

安全层的主要职责就是对发起的HTTP请求的数据进行加密操作和对接收到的HTTP的内容进行解密。



## 2.TLS/SSL的工作原理

TLS全称**安全传输层协议**以及前身SSL**安全套接层**，是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多改造。

TLS/SSL的功能实现主要依赖三类基本算法：

- 散列函数hash：用来验证信息的完整性
- 对称加密算法：采用协商的密钥对数据加密
- 非对称加密：实现身份认证和密钥协商



## 3.对称加密和非对称加密

对称加密和非对称加密都是安全传输层里的加密算法。

**对称加密**

简介：

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥。这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难。通信双方都使用同一个密钥进行加密，解密。

优点：

计算量小，加密速度快，加密效率高。

缺点：

在数据传输前，发送方和接收方必须商定好密钥，然后双方保存好密钥。如果一方的密钥被泄露，那么加密的信息就不安全了。最不安全的地方就是在与第一次开始，互相约定密钥进行密钥传输的时候。

**非对称加密**

简介：

通讯双方时使用不同的密钥进行加密和解密，即密钥对。私钥可以解密公钥加密的内容，公钥可以解密私钥加密的内容。公开公钥，别人使用公钥加密数据传送，收到数据后再使用私钥解密。

优点：

安全性比对称加密要好。

缺点：

加密和解密时间长、速度慢、只适合少量数据进行加密。



## 4.数字证书

简介：

使用一种Hash算法对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（CA）用它的私钥对信息摘要加密，形成签名（数字签名）。然后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的Hash算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就可以发现得到的信息是否被更改了。

作用：

当存在一个中间人，截取了对方发给我们的公钥，然后把他自己的公钥发送给我们，当我们使用他的公钥进行加密发送后，他就可以使用他的私钥对信息解密，并且使用之前的公钥加密后发送信息。这样我们的信息就被窃取了并且无法知道。



## 5.HTTPS握手过程

1. 客户端向服务器发送请求，请求中包含使用的协议号版本、生成的随机数、客户端支持的加密方法
2. 服务器收到请求后，确认双方使用的加密方法，给出服务器的证书以及一个服务器生成的随机数。
3. 客户端确认服务器证书有效性后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发送给服务器。并且还会提供一个前面所有内容的hash值，用来给服务器校验。
4. 服务器使用自己的私钥解密客户端发来的随机数。并提供前面所有内容的hash值给客户端检验。
5. 客户端和饥饿服务端更具约定的加密方法，使用前面三个随机数生成密钥，以后所有对话过程都是用这个密钥来加密信息。



## 6.HTTPS的优缺点

**优点**

- 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器。
- 使用HTTPS协议可以进行加密传输、身份认证，通讯更安全，防止数据在传输过程中被篡改、窃取，确保数据的安全性。
- HTTPS是先行框架下最安全的解决方案，虽然不是绝对安全，但是大幅增加中间人攻击成本。

**缺点**

- HTTPS需要做服务器和客户端双方都加密和解密过程，耗费更多的服务器资源，过程复杂。
- HTTPS戏小姨或首阶段比较费时，增加页面加载事件。
- SSL证书是收费的，功能越强大的证书费用越高。
- HTTPS链接服务器端资源占用高很多，支持方可稍多的网站需要投入更大的成本。
- SSL证书需要绑定IP，不能在同一个IP上绑定多个域名。



## 7.HTTPS如何保证安全的

结合对称加密和非对称加密两种方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到堆成加密的密钥，然后双方使用对称加密来通讯。这个时候需要一个第三方颁发证书（CA），证明身份，防止被中间人攻击。





# 三、TCP

## 1.TCP的三次握手

**第一次握手**

客户端向服务器端发送请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端会进入SYN-SENT状态。

**第二次握手**

服务端收到连接请求后，如果同意链接，则会发送一个应答，包含自身的数据通讯初始序号，发送完成后便进入SYN-RECEIVED状态。

**第三次握手**

当客户端接收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发送完这个报文后便进入ESTABLISHED状态，服务端收到这个应答之后，也进入ESTABLISHED状态，此时链接建立成功。



## 2.为什么要进行三次握手，而不是两次

1. 为了确保双方的接受能力和发送能力都正常。
2. 如果两次握手则会发生下列异常：如果客服端放出链接请求，但是因为连接请求报文丢失而未收到确认，于是客户端再穿一次链接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户端一共发出了两个请求连接的报文，其中一个丢失，第二个到达了服务端，但是假设第一个只是在某个网络节点长时间滞留了，延误到连接释放后才到达服务端，如果不采用三次握手，那么服务端就会认为是一个新的连接从而建立连接，浪费了资源。



## 3.TCP四次挥手

**第一次挥手**

若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。

**第二次挥手**

服务端收到连接释放请求后，会告诉应用层要释放TCP连接。然后会发送ACK包，并进入CLOSE_WANT状态，此时表明客户端到服务端的链接已经释放，不再接收客户端发的数据了。但是因为TCP是双向的，所以服务端人就可以发送数据给客户端。

**第三次挥手**

服务端此时还没有发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端进入LAST_ACK状态。

**第四次挥手**

客户端收到释放请求后，向服务器发送确认应答，此时客户端进入TIME_WAIT状态。该状态会持续2MSL时间，如果该时间段内没有服务的重发请求的花，就进入CLOSED状态。当服务端收到确认应答后，已进入CLOSED状态。



## 4.为什么要进行四次挥手

应为当服务端收到客户端SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文时用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，肯可能斌不会立刻关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端"你的FIN报文我收到了"。只有等到我服务端所有报文发送完了，我才能发送FIN报文，因此不能一起发送，故需要第四次挥手。



## 5.TCP粘包

**简介**

默认情况下，TCP连接会启用延迟传送算法（Nagle），再数据发送前先缓存他们，如果短时间有多个数据发送，会缓冲到一起做一次发送，这样可以减少IO消耗，提升性能。如果是传输文件的花，那么根本不需要处理粘包，来一个包拼接一个包即可。但是如果是多条消息，或者别的用途的数据就需要处理粘包。

**解决方案**

- 多次发送之前间隔一个等待时间
- 关闭Nagle算法
- 进行封包拆包

# 四、Ajax

## 1.Ajax的组成部分

Ajax全称：`Asynchronous Javascript And XML`(异步的js与xml)

- A：Asynchronous 
- J：Javascript
- A：and
- X：XML与XMLHttpRequest（json的出现晚于xml）



## 2.XMLHttpRequest对象

简介

Ajax的核心是`XMLHttpRequest`，他是一种支持异步请求的技术。`XMLHttpRequest`使你可以使用Javascript向服务器发送请求并处理响应而不阻塞用户。可以在页面加载以后进行页面的局部更新。

1. 使用方法
2. 实例化ajax对象
3. 调用open方法指定请求相关配置
4. 设置请求头
5. 发送请求
6. 注册回调函数

```js
let xhr = new XMLHttpRequest()
xhr.open('post', 'http://www.liulongbin.top:3009/api/login')
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
xhr.send('username=admin&password=123456')
xhr.onreadystatechange = () => {
    if(xhr.readyState === 4) {
        console.log(xhr.responseText)
    }
}
```



## 3.state状态码

- 0：请求未建立（创建了xhr对象，但是没有调用open）
- 1：服务器链接已建立
- 2：请求已接受（send之后，服务器已经接受了请求）
- 3：请求处理中
- 4：请求完成，且响应已就绪



## 4.onreadstatechange事件

`onload`事件：请求完成时触发一次，此时`xhr.state === 4`

`onreadstatechange`事件：state状态码每改变一次触发一次



## 5.上传文件

步骤：

1. 给file表单注册onchange事件
2. 获取文件
3. 创建FormData对象
4. 将文件添加到对象中
5. 发送请求

代码实现：

```js
document.querySelector('#input-file').onchange = () => {
    let file = this.files[0]
    if(file === undefined) {
        return alert('请上传文件')
    }
    let fd = new FormData()
    fd.append('file', file)
    axios({
        method: 'POST',
        url: 'http://www.liulongbin.top:3009/api/upload/avatar',
        data: fd
    }).then(res => {
        console.log(res)
    })
}
```

自定义上传按钮：

为自定义按钮绑定点击事件，该事件的回调函数中会主动调用input-file中节点的点击事件

```js
DIYBtn.onclick = () => {
    FIleInput.click()
}
```



## 6.取消请求

ajax原生取消

```js
const xhr = new XMLHttpRequest()
xhr.abort()
```

axios取消

```js
const controller = new AbortController()

axios.get('/user/admin', {
    signal: controller.signal
}).then(res => {...})

controller.abort()
```

取消请求的意义

- 已发出的请求可能仍然会到达服务端
- 可以取消后续的回调操作，避免多余的回调操作、错误处理、超时处理等，节省资源
- 取消loading效果，在单页应用中，在A页面跳转到B页面时，应该取消A页面的请求，否则回调中的一些处理会影响新页面



# 五、浏览器安全与优化

## 1.有哪些可以引起前端安全的问题

**跨站脚本（Cross-Site Scripting, XSS）**

一种代码注入的方式，为了与CSS区分所以被称为XSS。早起常见于网络论坛，起因是网站没有对用户输入进行严格限制，使得攻击者可以将脚本上传到帖子然其他人浏览被注入恶意脚本的页面。其注入方式简单包括但不限于JavaScript、CSS、Flash等。

**iframe滥用**

iframe内容是由第三方提供的，默认情况下他们不受控制，他们会在iframe中运行js脚本、flash插件、弹出对话框等，这可能或破坏前端用户体验。

**跨站点请求伪造（Cross-Site Request Forgeries, CSRF）**

指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或者设定信息等某些状态的更新，属于被动共计。

**恶意第三方库**

无论是后端还是前端开发，绝大多数都是在借助开发框架和各类库进行快速开发，一旦第三方库被植入恶意代码很容易应发安全问题。



## 2.网络劫持有哪几种，如何防范

**DNS劫持**

- DNS强制解析：通过修改运营商本地DNS记录，来引导用户流量到缓存服务器
- 302跳转方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的，在对劫持的内存发起302跳转的回复，应到用户获取内容。

**HTTP劫持**

- 由于http明文传输，运营商会修改你的http相应内容，然后加上广告等。

DNS劫持已经被监管。HTTP劫持使用HTTPS加密。



## 3.进程与线程

**概念**

从本质上说，进程和线程都是CPU工作时间片的一个描述。

- 进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上说就代表一个程序。
- 线程是进程中更小的单位，描述了执行一段指令所需的时间。

**区别**

应用：进程可以看做独立应用，线程不能。

资源：进程是cpu资源分配的最小单位，是能拥有资源和独立运行的最小单位；线程是cpu调度的最小单位，线程是建立在进程基础上的一次程序运行单位，一个进程中可以有多个线程。

通信：线程可以通过直接共享同一进程中的资源，二进程通信需要借助进程中通信。

调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但是某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

开销：由于创建或者撤销进程时，系统都要为之分配或者回收资源，如内存、I/O等，其开销远大于创建或销毁线程时的开销。



## 4.如何实现浏览器内多个标签页之间的通信

**websocket协议**

websocket协议可以实现服务器推送，所以服务器就可以当做中介者。标签页通过向服务器发送数据，然后有服务器向其他标签页推送转发。

**ShareWorker**

ShareWorker会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以当中介者。标签页间通过共享一个线程，然后通过这个共享线程来实现数据的交换。

**localStorage**

可以在一个标签页对localStorage的变化时间进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候localStorage对象就是充当了中介者的角色。

**postMessage**

如果我们能过获得对应标签的引用，就可以说使用postMessage方法进行通信。



## 5.为什么需要浏览器缓存

对于浏览器的缓存，主要针对的是前端的静态资源，再发起请求之后，拉取相应的金泰资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉去资源，并保存到本地。这样就大大减少了请求的次数，提高了网站性能。

所谓的浏览器缓存指的是浏览器将用户请求过的静态资源存储到电脑的本地磁盘中，当浏览器再次访问时，直接从本地加载，不需要再去服务器请求了。



## 6.点击刷新按钮或者按F5、Ctrl+F5、地址栏回车有什么区别

**点击刷新按钮或者F5**

浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味之服务器会对文件检查新鲜度，返回结果可能是304，也可能是200。

**Ctrl+F5**

浏览器不会对本地文件过期，而且不会带上If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果时200。

**地址栏回车**

浏览器按照正常流程，价差本地缓存，然后服务器校验新鲜度，最后返回内容。



## 7.浏览器渲染过程遇到JS文件如何处理

JavaScript的加载、解析与执行会阻塞文档的解析，也就是说，在构建DOM时，HTML解析器若语法哦Javascript，那么它会暂停文档的解析，将控制权交给Javascript引擎，等JavaScript引擎运行完毕，浏览器中再从终端的地方恢复继续解析文档。

也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签放到body标签尾部的原因。当然在当下，可以给script添加`defer`或者`async`属性，来解决这个问题。



## 8.什么是文档的与解析

Webkit和Firefox都做了这个优化，当执行Javascript脚本时，另一个线程解析剩下的脚本，斌家在后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，与解析并不改变DOM树，他将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本，样式表及图片。



## 9.CSS如何阻塞文档解析

理论上，既然样式表不改变DOM树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript脚本执行时可能在文档解析时请求样式表的信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这样会导致很多问题。

所以如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器延迟JavaScript脚本执行和文档的解析，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，然后再继续文档的解析。



## 10.浏览器的本低存储方式

**1.Cookie**

**简介**

Cookie时最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否都是同一用户发起的，为解决这个问题，Cookie就出现了，Cookie的大小只有4kb，他是一种纯文本文件，每次发起HTTP请求都会携带Cookie。

就是最开始是服务端用于记录用户状态的一种方式，由服务端设置，在客户端存储，然后每次同源请求时，发送给服务端。cookie最多存储4k数据，他生存时间由expires属性确定，并且cookie只能被同源的页面访问。

**特性**

- Cookie一旦创建成功，名称就无法修改。
- Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是有Cookie'的隐私安全性决定的，这样能够阻止非法获取其他网站的Cookie。
- 每个域名下的Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb
- 有安全问题，如果Cookie被拦截了，那就可以获取session的所有信息，即使加密也于事无补，无需知道cookie的意义，只需要转发cookie就能达到目的
- Cookie再请求一个新的页面的时候都会被发送出去。

**2.LocalStorage**

**简介**

LocalStorage是HTML5引入的新特性，由于有时候我们的信息储存较大，Cookie就不能满足我们的需要，这时候就需要LocalStorage。

**优点**

- 大小为5MB，可以储存更多信息
- 是持久储存，斌不会随着页面的关闭而消失，除非主动清理。
- 仅仅存储在本地，不会随HTTP发送到服务器

**缺点**

- 兼容问题，IE8以下版本不支持
- 浏览器设置为隐私模式无法读取LocalStorage
- 有同源策略限制

**3.SessionStorage**

**简介**

SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

它借鉴了服务端session的概念，代表的是一次会话中所保存的数据。他一般能存储5M或者更大的数据，他在当前窗口关闭后就失效了，并且sessionStorage只能被同一窗口的同源页面所访问。

**SessionStorage与LocalStorage对比**

- 都是本地数据存储
- 都具有同源策略，Session Storage更加严格，要求同意浏览器的同意窗口下才能共享。
- 不能被爬虫读取



## 11.同源策略和跨域

**同源策略**

protocal（协议）、domain（域名）、port（端口）三者必须一致

**同源策略的限制**

- 当前域下的js脚本不能访问其他域下的cookie、localStorage和indexDB
- 当前域下的js脚本不能访问操作其他域下的DOM
- 当前域下的ajax无法发送跨域请求。

**同源策略的目的**

主要是为了保证用户的信息安全，它只是对js脚本的一种限制，并不是对浏览器的限制，对于一般的img、或者script脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

**跨域的概念**

指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，时浏览器对JavaScript世家的安全限制，防止他人恶意攻击网站。



## 12.如何解决跨域问题

**CORS**

CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨域通讯。

**JSONP**

jsonp的原理是用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的get请求，服务端通过将接口返回的数据平凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

**possMessage**

postMessage是HTML5中的API，且是为数不多的可以跨域操作的window属性之一，它可以解决下面的问题：

- 页面和其他打开的新窗口的数据传递
- 多窗口之间的信息传递
- 页面与嵌套的iframe信息传递
- 上面三个场景的跨域数据传递

```js
postMessage(data, origin)
data: 传参，最好使用JSON.stringify()序列化
origin：协议+主机+端口号，也可以设置为“*”，表示可以传递给任意窗口，如果只当和当前窗口同源的话设置为“/”
```

**Node中间件代理**

同源策略是浏览器需要遵循的标准，而如果是服务器向服务器发送请求则不需要遵循同源策略，代理服务器，需要做一下几个步骤：

- 接受客户端请求
- 将请求转发给服务器
- 拿到服务器响应数据

**nginx反向代理**

实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

通过nginx配置一个代理服务器，域名与domain1相同，端口不同做跳板机，反向代理domain2接口，斌且可以顺便修改cookie中的domain信息，方便当前域写入cookie，实现跨域登录。



## 13.正向代理和反向代理

**正向代理**

客户端想获取一个服务端数据，但是因为种种原因无法获取。于是客户端设置了一个代理服务器，指向指定的目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器颖仓真是客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

**反向代理**

服务器为了能够将工作负载到多个服务器来提高完整性能等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实的服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要修改DNS让域名揭晓到代理服务器IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。



## 14.XSS和CSRF

**XSS**

简介

XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户浏览器上运行，从而盗取用户的信息cookie等。

XSS攻击的本质是应为网站没有对恶意代码进行过滤，与正常代码混合在一起，浏览器没有办法分辨哪些脚本时可信的，从而导致恶意代码的执行。

危害

攻击者可以通过这种方式进行一下操作

- 获取页面数据，如DOM、cookie、localStorage
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器。
- 破坏页面结构
- 留恋劫持，将连接指向其他网站

防御方式

可以从浏览器的执行来进行预防，一种是使用纯前端方法，不适用服务端拼接后返回（不适用服务端渲染）。另一种是对需要插入HTML中的代码做好充分的转义。对于DOM型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对恶意代码进行判断。

**CSRF**

简介

CSRF指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后代的用户验证，冒充用户向服务器执行一些操作。

CSRF的本质是利用cookie会在同源请求中携带发送给服务器的特点，以此来冒充用户。

防御方式

- 进行同源检测，服务器根据http请求头中的origin或者referer信息来判断亲求是否为允许访问的站点，从而对请求进行过滤。
- 使用CSRF Token进行验证，服务器向用户返回一个随机数Token，当网站再次发起请求时，在请求参数中加入服务端返回的token，然后服务器对这个token进行验证。
- 对Cookie进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从cookie中取出这个字符串，添加到URL参数中，然后服务器通过对cookie中的数据和参数中的数据进行比较，来进行验证
- 在设置cookie属性的时候设置Samesite，限制cookie不能作为被第三方使用，从而可以避免被攻击者利用。Samesite一共有两种模式，一种是严格模式，在严格模式下cookie在任何情况都不能作为第三方Cookie使用，在宽松模式下，cookie可以被请求的时get请求，且会发生页面跳转的请求所使用。



## 15.中间人攻击

**简介**

中间人是指攻击者在通讯的两端分别建立的独立的联系，并交换其收到的数据，时通讯的两端认为他们赈灾通过一个私密的连接与对方直接对话，但事实上真个会话都被攻击者完全掌控。在中间人攻击下，攻击者可以拦截通讯双方的通话并插入新的内容。

**攻击过程**

- 客户端发送请求到服务端，被中间人截获
- 服务器向客户端发送公钥
- 中间人截获公钥，保留在自己手上。然后自己生成一个伪造公钥，发送给客户端
- 客户端收到伪造的公钥后，生成加密hash发送给服务器
- 中间人收到加密的hash后，用自己的私钥解密获得真密钥，同时生假的加密hash值，发送给服务器。
- 服务器用私钥解密获得的假密钥，然后加密数据发送给客户端



## 16.介绍websocket

websocket是一种网络通讯协议，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个是对比HTTP协议来说的，HTTP协议是一种无状态、无连接、单向的应用层协议，通信请求只能由哭护短发起，服务端对请求做出应答处理。

HTTP协议无法实现服务器主动向客户端发起消息，websocket连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需要建立一次连接，就可以一直保持连接状态。



## 17.什么是轮询

**轮询**

指的是每隔一段时间进行一次查询或者询问。轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。

**短轮询**

通过客户端定期轮询来询问服务端时候又新的信息产生，如果有则返回，没有就不响应，缺点：轮询间隔大，结果不实时；轮询间隔小，消耗的资源则多，怎加服务器负担。

**长轮询**

是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，则布里克返回，而是Hold一段时间等新的信息产生或者超时再返回，客户端收到服务器的应答后继续轮询。可以看出长轮询比端轮询可以减少大量的无用请求，并且客户端收取新信息也会实时不少。



## 18.如何做SEO优化

简介

SEO，即搜索引擎优化，SEO时随着搜索引擎出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中收录数量以及排序位置而作的优化。而优化的目的就是为了提升网站在搜索引擎中的权重，怎加对搜索引擎的友好度，使得用户访问网站时能排在前面。

方法

- 优化完整结构布局
- 控制首页连接数量
- 网页层级不要太深
- 控制页面大小，减少HTTP请求，提高网站加载速度
- 使用语义化标签
- 利用浏览器缓存
