# 闭包与作用域

## 目录

- [作用域](#作用域)
- [执行上下文](#执行上下文)
- [闭包](#闭包)
- [垃圾回收机制](#垃圾回收机制)

---

## 作用域

### 什么是作用域

作用域是一套规则，用来管理 JavaScript 引擎如何根据标识符名称查找变量。简单来说，**作用域就是变量的有效访问范围**。

### 作用域的类型

#### 1. 全局作用域

**特点：**

- 直接写在 `<script>` 标签中的 JS 代码都在全局作用域
- 在全局作用域下声明的变量叫做**全局变量**
- 全局变量在代码的任何位置都可以访问
- 全局作用域在页面打开时创建，页面关闭时销毁

**关于 window 对象：**

- `var` 和 `function` 声明的全局变量和函数是 `window` 对象的属性和方法
- `let`、`const`、`class` 声明的全局变量**不属于** `window` 对象的属性

```javascript
// var 声明的全局变量会成为 window 的属性
var globalVar = 'I am global';
console.log(window.globalVar); // 'I am global'

// let/const 声明的全局变量不会成为 window 的属性
let globalLet = 'I am also global';
console.log(window.globalLet); // undefined

// 但都可以在全局范围内访问
console.log(globalVar);  // 'I am global'
console.log(globalLet);  // 'I am also global'
```

#### 2. 函数作用域（局部作用域）

**特点：**

- 调用函数时创建函数作用域，函数执行完毕后销毁
- 每次调用函数都会创建一个新的独立作用域
- 函数内部可以访问外部变量，但外部无法访问函数内部的变量

**变量查找规则（作用域链）：**
当在函数作用域中访问一个变量时：

1. 先在当前作用域中查找
2. 如果没有找到，向上一级作用域查找
3. 一直查找到全局作用域
4. 如果全局作用域也没有，则报错 `ReferenceError`

```javascript
var a = 10;

function outer() {
  var b = 20;

  function inner() {
    var c = 30;
    console.log(a); // 10 - 从全局作用域找到
    console.log(b); // 20 - 从 outer 作用域找到
    console.log(c); // 30 - 从当前作用域找到
  }

  inner();
  console.log(c); // ReferenceError: c is not defined
}

outer();
```

#### 3. 块级作用域

**特点：**

- ES6 引入的新特性（ES6 之前只有全局作用域和函数作用域）
- 任何一对花括号 `{}` 中的语句集都属于一个块
- **只有使用 `let` 和 `const` 声明的变量才有块级作用域**
- `var` 声明的变量和非严格模式下的函数声明没有块级作用域

```javascript
// let/const 有块级作用域
{
  let blockVar = 'I am in block';
  const blockConst = 'Me too';
  console.log(blockVar); // 'I am in block'
}
console.log(blockVar); // ReferenceError: blockVar is not defined

// var 没有块级作用域
{
  var noBlockVar = 'I escape the block';
}
console.log(noBlockVar); // 'I escape the block'

// 常见场景：for 循环
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出: 0, 1, 2 (每个 i 都是独立的)

for (var j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100);
}
// 输出: 3, 3, 3 (所有回调共享同一个 j)
```

#### 4. 词法作用域（静态作用域）⭐

**核心概念：**
词法作用域是 JavaScript 采用的作用域模型，它的关键特点是：**函数的作用域在函数定义时就已经确定，而不是在函数调用时确定**。

**重要理解：**

- 词法作用域由代码书写的位置决定
- 无论函数在哪里被调用，它的作用域链都是固定的
- 编译阶段就能确定变量的作用域

```javascript
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo(); // 调用 foo
}

bar(); // 输出: 1 (不是 2!)

// 解释：foo 函数在定义时，它的外层作用域是全局作用域
// 所以 foo 中的 value 查找的是全局的 value (1)
// 而不是 bar 函数中的 value (2)
```

**对比动态作用域（JavaScript 不采用）：**

```javascript
// 如果是动态作用域（假设），上面的例子会输出 2
// 因为 foo 在 bar 中调用，会使用 bar 的 value
// 但 JavaScript 使用词法作用域，所以输出 1
```

### 什么是作用域链 ⭐

**概念：**
作用域链本质上是一个指向变量对象的指针列表。它保证了对执行环境有权访问的所有变量和函数的有序访问。

**结构：**

- 作用域链的前端始终是**当前执行上下文的变量对象**
- 作用域链的末端始终是**全局执行上下文的变量对象**

**作用：**
通过作用域链，内层作用域可以访问外层作用域的变量和函数。

```javascript
var globalVar = 'global';

function outer() {
  var outerVar = 'outer';

  function inner() {
    var innerVar = 'inner';

    // 作用域链: inner作用域 -> outer作用域 -> 全局作用域
    console.log(innerVar);  // 'inner' - 在当前作用域找到
    console.log(outerVar);  // 'outer' - 在上一级作用域找到
    console.log(globalVar); // 'global' - 在全局作用域找到
  }

  inner();
}

outer();
```

---

## 执行上下文

### 执行上下文的类型

#### 1. 全局执行上下文

- 任何不在函数内部的代码都在全局执行上下文中
- 创建一个全局对象（浏览器中是 `window`）
- 将 `this` 指向这个全局对象
- 一个程序中只有一个全局执行上下文

#### 2. 函数执行上下文

- 每当一个函数被调用时，都会为该函数创建一个新的执行上下文
- 函数执行上下文可以有任意多个
- 每次调用函数都会创建一个新的上下文

#### 3. Eval 函数执行上下文

- 执行在 `eval` 函数内部的代码会有自己的执行上下文
- 不推荐使用 `eval`

### 执行上下文栈（调用栈）⭐

**工作原理：**
JavaScript 引擎使用执行上下文栈（Call Stack）来管理执行上下文。

**执行流程：**

1. 代码开始执行，创建全局执行上下文并压入栈底
2. 每当调用一个函数，创建该函数的执行上下文并压入栈顶
3. 引擎执行位于栈顶的函数
4. 函数执行完毕，其执行上下文从栈中弹出
5. 继续执行下一个栈顶的上下文
6. 所有代码执行完毕，全局执行上下文从栈中弹出

```javascript
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}

function second() {
  console.log('Inside second function');
}

first();
console.log('Inside global execution context');

// 执行上下文栈的变化：
// 1. [全局上下文]
// 2. [全局上下文, first上下文]
// 3. [全局上下文, first上下文, second上下文]
// 4. [全局上下文, first上下文] - second执行完毕
// 5. [全局上下文] - first执行完毕
// 6. [] - 程序结束

// 输出顺序：
// Inside first function
// Inside second function
// Again inside first function
// Inside global execution context
```

### 执行上下文的三个阶段

#### 1. 创建阶段

**this 绑定：**

- 全局执行上下文：`this` 指向全局对象（浏览器中是 `window`）
- 函数执行上下文：`this` 的值取决于函数如何被调用

**创建词法环境（Lexical Environment）：**

- 词法环境是一种标识符-变量映射的数据结构
- 包含两个组件：
  - **环境记录器**：存储变量和函数声明的实际位置
  - **外部环境引用**：可以访问父级作用域

**创建变量环境（Variable Environment）：**

- 变量环境也是一个词法环境
- 用于存储 `var` 声明的变量绑定
- `let` 和 `const` 声明存储在词法环境中

#### 2. 执行阶段

- 完成对所有变量的赋值
- 执行代码

#### 3. 回收阶段

- 执行上下文出栈
- 等待垃圾回收器回收执行上下文

### 变量提升（Hoisting）⭐

**什么是变量提升：**
JavaScript 引擎在执行代码前会进行预解析，将变量和函数声明提升到当前作用域的顶部。

**提升规则：**

1. 变量声明会被提升，但赋值不会
2. 函数声明会被提升，但函数调用不会
3. 函数声明的优先级高于变量声明

```javascript
// 变量提升示例
console.log(a); // undefined (不是 ReferenceError)
var a = 10;
console.log(a); // 10

// 等价于：
var a;
console.log(a); // undefined
a = 10;
console.log(a); // 10

// 函数提升示例
foo(); // 'Hello' - 可以在声明前调用
function foo() {
  console.log('Hello');
}

// let/const 不会提升（存在暂时性死区）
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;
```

**函数声明 vs 函数表达式：**

```javascript
// 函数声明 - 会被提升
foo(); // 'I am a function declaration'
function foo() {
  console.log('I am a function declaration');
}

// 函数表达式 - 不会被提升
bar(); // TypeError: bar is not a function
var bar = function() {
  console.log('I am a function expression');
};
```

**优先级示例：**

```javascript
console.log(foo); // [Function: foo]

var foo = 'variable';
function foo() {
  return 'function';
}

console.log(foo); // 'variable'

// 等价于：
function foo() {
  return 'function';
}
var foo; // 声明被忽略，因为 foo 已经存在
console.log(foo); // [Function: foo]
foo = 'variable'; // 赋值执行
console.log(foo); // 'variable'
```

---

## 闭包

### 什么是闭包 ⭐

**官方定义：**
闭包是指有权访问另一个函数作用域中变量的函数。

**通俗理解：**
当一个内部函数被返回到外部并保存时，即使外部函数已经执行完毕，内部函数仍然可以访问外部函数的变量，这就形成了闭包。

**闭包的形成条件：**

1. 函数嵌套
2. 内部函数引用外部函数的变量
3. 内部函数被返回或以某种方式保存到外部

```javascript
function outer() {
  var count = 0; // 外部函数的变量

  function inner() {
    count++; // 内部函数访问外部变量
    console.log(count);
  }

  return inner; // 返回内部函数
}

var counter = outer(); // outer 执行完毕，但 count 没有被销毁
counter(); // 1
counter(); // 2
counter(); // 3
// count 变量被闭包保持在内存中
```

### 闭包的作用

#### 1. 创建私有变量

闭包可以模拟私有变量，实现数据封装和隐藏。

```javascript
function createPerson(name) {
  var _name = name; // 私有变量

  return {
    getName: function() {
      return _name;
    },
    setName: function(newName) {
      _name = newName;
    }
  };
}

var person = createPerson('Alice');
console.log(person.getName()); // 'Alice'
person.setName('Bob');
console.log(person.getName()); // 'Bob'
console.log(person._name); // undefined - 无法直接访问私有变量
```

#### 2. 保持变量的持久性

闭包使得函数执行完毕后，其作用域中的变量不会被销毁。

```javascript
function createCounter() {
  var count = 0;

  return {
    increment: function() {
      return ++count;
    },
    decrement: function() {
      return --count;
    },
    getCount: function() {
      return count;
    }
  };
}

var counter1 = createCounter();
var counter2 = createCounter();

console.log(counter1.increment()); // 1
console.log(counter1.increment()); // 2
console.log(counter2.increment()); // 1 - 独立的闭包
console.log(counter1.getCount());  // 2
```

#### 3. 模块化开发

闭包是实现模块模式的基础。

```javascript
var Module = (function() {
  var privateVar = 'I am private';

  function privateMethod() {
    console.log(privateVar);
  }

  return {
    publicMethod: function() {
      privateMethod();
    },
    getPrivateVar: function() {
      return privateVar;
    }
  };
})();

Module.publicMethod(); // 'I am private'
console.log(Module.privateVar); // undefined
```

### 闭包的常见陷阱 ⭐

#### 陷阱 1：循环中的闭包

```javascript
// 错误示例
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 输出: 3, 3, 3 (不是 0, 1, 2)

// 原因：所有回调函数共享同一个 i 变量
// 当回调执行时，循环已经结束，i 的值是 3

// 解决方案 1：使用 IIFE 创建独立作用域
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 1000);
  })(i);
}
// 输出: 0, 1, 2

// 解决方案 2：使用 let（推荐）
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 输出: 0, 1, 2
```

#### 陷阱 2：内存泄漏

闭包会导致外部函数的变量无法被回收，如果不当使用可能造成内存泄漏。

```javascript
// 可能导致内存泄漏的示例
function createClosure() {
  var largeData = new Array(1000000).fill('data');

  return function() {
    console.log('Closure created');
    // 即使不使用 largeData，它也会被保留在内存中
  };
}

var closure = createClosure();
// largeData 无法被回收

// 改进：只保留需要的数据
function createClosure() {
  var largeData = new Array(1000000).fill('data');
  var summary = largeData.length; // 只保留需要的信息
  largeData = null; // 释放大数据

  return function() {
    console.log('Data length:', summary);
  };
}
```

### 闭包的实际应用

#### 1. 防抖（Debounce）

```javascript
function debounce(func, delay) {
  var timer = null;

  return function() {
    var context = this;
    var args = arguments;

    clearTimeout(timer);
    timer = setTimeout(function() {
      func.apply(context, args);
    }, delay);
  };
}

// 使用
var handleInput = debounce(function(e) {
  console.log('Input value:', e.target.value);
}, 500);

// input.addEventListener('input', handleInput);
```

#### 2. 节流（Throttle）

```javascript
function throttle(func, delay) {
  var lastTime = 0;

  return function() {
    var now = Date.now();
    if (now - lastTime >= delay) {
      func.apply(this, arguments);
      lastTime = now;
    }
  };
}

// 使用
var handleScroll = throttle(function() {
  console.log('Scroll position:', window.scrollY);
}, 200);

// window.addEventListener('scroll', handleScroll);
```

#### 3. 柯里化（Currying）

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...moreArgs) {
        return curried.apply(this, args.concat(moreArgs));
      };
    }
  };
}

// 使用
function add(a, b, c) {
  return a + b + c;
}

var curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

---

## 垃圾回收机制

### 垃圾回收的基本原理

**自动回收机制：**
JavaScript 具有自动垃圾回收机制（Garbage Collection, GC），会定期找到不再使用的变量和对象，释放其占用的内存。

**变量的生命周期：**

- **全局变量**：生命周期持续到页面卸载
- **局部变量**：从函数执行开始到函数执行结束
- **闭包中的变量**：只要闭包还在使用，变量就不会被回收

```javascript
function example() {
  var localVar = 'I will be collected'; // 局部变量
  console.log(localVar);
}

example(); // 函数执行完毕后，localVar 会被回收

function closureExample() {
  var closureVar = 'I will NOT be collected'; // 被闭包引用

  return function() {
    console.log(closureVar);
  };
}

var closure = closureExample();
// closureVar 不会被回收，因为闭包还在引用它
```

### 垃圾回收算法

#### 1. 标记清除（Mark-and-Sweep）- 主流算法

**工作原理：**

1. 垃圾回收器从根对象（全局对象）开始遍历
2. 标记所有能访问到的对象
3. 清除所有未被标记的对象

```javascript
var obj1 = { name: 'Object 1' };
var obj2 = { name: 'Object 2' };
var obj3 = { name: 'Object 3', ref: obj1 };

obj1 = null; // obj1 仍然被 obj3 引用，不会被回收
obj2 = null; // obj2 没有引用，会被回收
obj3 = null; // 现在 obj1 和 obj3 都会被回收
```

#### 2. 引用计数（Reference Counting）- 已淘汰

**工作原理：**
跟踪每个对象被引用的次数，当引用次数为 0 时回收。

**缺陷：循环引用问题**

```javascript
function circularReference() {
  var obj1 = {};
  var obj2 = {};

  obj1.ref = obj2;
  obj2.ref = obj1;

  // 即使函数执行完毕，obj1 和 obj2 互相引用
  // 引用计数永远不为 0，导致内存泄漏
}

circularReference();
// 现代浏览器使用标记清除算法，可以正确处理循环引用
```

### 如何减少垃圾回收压力

#### 1. 优化数组操作

```javascript
// 不推荐：重新赋值创建新数组
var arr = [1, 2, 3, 4, 5];
arr = []; // 旧数组等待回收，创建新数组

// 推荐：设置长度为 0
var arr = [1, 2, 3, 4, 5];
arr.length = 0; // 清空数组，不创建新对象
```

#### 2. 优化对象操作

```javascript
// 不推荐：重新赋值
var obj = { a: 1, b: 2 };
obj = {}; // 旧对象等待回收

// 推荐：设置为 null
var obj = { a: 1, b: 2 };
obj = null; // 解除引用，便于回收
```

#### 3. 避免意外的全局变量

```javascript
// 错误：意外创建全局变量
function foo() {
  bar = 'I am global'; // 没有 var/let/const，成为全局变量
}

// 正确：使用严格模式
'use strict';
function foo() {
  bar = 'This will throw an error'; // ReferenceError
}

// 正确：显式声明
function foo() {
  var bar = 'I am local';
}
```

#### 4. 及时清理定时器和事件监听器

```javascript
// 可能导致内存泄漏
var element = document.getElementById('button');
element.addEventListener('click', function() {
  console.log('Clicked');
});

// 正确：移除不需要的监听器
var element = document.getElementById('button');
var handler = function() {
  console.log('Clicked');
};
element.addEventListener('click', handler);

// 不再需要时移除
element.removeEventListener('click', handler);

// 清理定时器
var timer = setInterval(function() {
  console.log('Running');
}, 1000);

// 不再需要时清除
clearInterval(timer);
```

### 常见的内存泄漏场景 ⭐

#### 1. 意外的全局变量

```javascript
function leak() {
  name = 'Global leak'; // 忘记声明，成为全局变量
}
leak();
```

#### 2. 被遗忘的定时器

```javascript
var data = new Array(1000000);

setInterval(function() {
  var node = document.getElementById('node');
  if (node) {
    node.innerHTML = JSON.stringify(data); // data 无法被回收
  }
}, 1000);

// 即使 node 被移除，定时器仍在运行，data 无法被回收
```

#### 3. 脱离 DOM 的引用

```javascript
var elements = {
  button: document.getElementById('button')
};

document.body.removeChild(document.getElementById('button'));

// button 元素已从 DOM 中移除，但 elements.button 仍然引用它
// 导致该 DOM 节点无法被回收

// 解决：清除引用
elements.button = null;
```

#### 4. 闭包引起的内存泄漏

```javascript
function assignHandler() {
  var element = document.getElementById('button');
  var id = element.id;

  element.onclick = function() {
    console.log(id);
    // 闭包引用了 element，即使只需要 id
  };

  // 改进：解除不必要的引用
  element = null;
}
```

---

## 总结与最佳实践

### 关键要点

1. **作用域**是变量的访问范围，JavaScript 使用词法作用域（静态作用域）
2. **作用域链**保证了内层作用域可以访问外层作用域的变量
3. **执行上下文**是代码执行的环境，通过执行上下文栈管理
4. **闭包**是函数和其词法环境的组合，可以访问外部函数的变量
5. **垃圾回收**是自动的，但需要注意避免内存泄漏

### 最佳实践

1. 优先使用 `let` 和 `const`，避免使用 `var`
2. 理解闭包的工作原理，避免循环中的闭包陷阱
3. 及时清理不需要的引用、定时器和事件监听器
4. 使用严格模式避免意外的全局变量
5. 注意闭包可能导致的内存泄漏问题
