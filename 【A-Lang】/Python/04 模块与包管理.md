# 模块与包管理

## import 机制

### import 语句的几种形式

```python
# 1. 导入整个模块
import os
import os.path

# 2. 从模块中导入特定名称
from os import path, getcwd

# 3. 导入并起别名
import numpy as np
from datetime import datetime as dt

# 4. 导入模块中的所有公开名称（不推荐，容易污染命名空间）
from os.path import *

# 5. 导入多个名称
from os import path, sep, linesep
```

### 模块搜索路径（sys.path）

```python
import sys

# sys.path 是一个列表，Python 按顺序在这些路径中查找模块
print(sys.path)
# 输出示例：
# ['', '/usr/lib/python3.11', '/usr/lib/python3.11/lib-dynload', ...]

# 搜索顺序：
# 1. 当前脚本所在目录（或交互式解释器的当前目录）
# 2. PYTHONPATH 环境变量中的目录
# 3. 标准库目录
# 4. site-packages 目录（第三方库安装位置）

# 运行时动态添加搜索路径
sys.path.insert(0, '/my/custom/path')  # 插入到最前面，优先级最高
sys.path.append('/another/path')       # 追加到末尾，优先级最低
```

### __name__ 与 __main__

```python
# mymodule.py

def greet(name):
    return f"Hello, {name}"

# 当该文件被直接运行时，__name__ == '__main__'
# 当该文件被其他模块 import 时，__name__ == 'mymodule'
if __name__ == '__main__':
    # 只有直接运行时才执行，import 时不执行
    print(greet("World"))
```

```python
# main.py
import mymodule

# 此时 mymodule.__name__ == 'mymodule'，不会触发上面的 if 块
print(mymodule.greet("Python"))
```

### 相对导入 vs 绝对导入

```python
# 项目结构：
# mypackage/
#   __init__.py
#   utils.py
#   subpkg/
#     __init__.py
#     helper.py

# --- 绝对导入（推荐）---
# 从项目根目录开始的完整路径
from mypackage import utils
from mypackage.subpkg import helper

# --- 相对导入（只能在包内部使用）---
# helper.py 内部使用相对导入
from .. import utils        # 导入上一级包的 utils 模块
from ..utils import some_fn # 导入上一级包 utils 模块中的函数
from . import other         # 导入同级包的 other 模块
```

### 循环导入问题

```python
# 问题示例：
# a.py
from b import func_b   # a 导入 b

# b.py
from a import func_a   # b 又导入 a，循环导入，抛出 ImportError

# 解决方案 1：将导入移到函数内部（延迟导入）
# a.py
def func_a():
    from b import func_b   # 调用时才导入，避免模块加载时的循环
    return func_b()

# 解决方案 2：重构代码，将共用部分提取到第三个模块
# common.py 存放 a 和 b 都需要的内容
# a.py 和 b.py 都从 common.py 导入，不互相依赖
```

## 包结构

### 包的定义（__init__.py）

```python
# __init__.py 的存在使目录成为一个 Python 包
# 它在包被导入时自动执行

# mypackage/__init__.py

# 1. 可以为空（最简单的包）

# 2. 控制包级别的导入，让用户可以直接从包导入
from .utils import helper_func
from .models import User

# 3. 设置包的版本信息
__version__ = '1.0.0'
__author__ = 'Your Name'

# 用户使用时：
# import mypackage
# mypackage.helper_func()   # 无需知道内部模块结构
# mypackage.__version__     # '1.0.0'
```

### 包的目录结构

```text
myproject/
├── pyproject.toml          # 项目配置与依赖（现代方式）
├── README.md
├── src/
│   └── mypackage/
│       ├── __init__.py     # 包入口，定义公开 API
│       ├── core.py         # 核心逻辑
│       ├── utils.py        # 工具函数
│       └── subpkg/
│           ├── __init__.py
│           └── helper.py
└── tests/
    ├── __init__.py
    ├── test_core.py
    └── test_utils.py
```

### __all__ 的作用

```python
# utils.py

# __all__ 定义 from module import * 时导出的名称列表
# 同时也作为模块公开 API 的文档说明
__all__ = ['public_func', 'PublicClass']

def public_func():
    """这个函数会被导出"""
    pass

def _private_func():
    """以下划线开头，约定为私有，不会被 * 导出"""
    pass

class PublicClass:
    pass

class _InternalClass:
    pass

# 使用方：
# from utils import *
# 只导入 public_func 和 PublicClass
# _private_func 和 _InternalClass 不会被导入
```

### 命名空间包

```python
# 命名空间包（PEP 420）：不需要 __init__.py 的包
# 允许同一个包分布在多个目录中

# 目录结构示例：
# /path/a/myns/module1.py
# /path/b/myns/module2.py
# 两个目录都在 sys.path 中

# 导入时 Python 会合并这两个目录为同一个命名空间包
import myns.module1   # 来自 /path/a/
import myns.module2   # 来自 /path/b/

# 常见于大型项目拆分或插件系统
# 普通小项目仍推荐使用带 __init__.py 的常规包
```
## 虚拟环境

### 为什么需要虚拟环境

```text
问题场景：
- 项目 A 需要 requests==2.28
- 项目 B 需要 requests==2.31
- 全局只能安装一个版本，产生冲突

虚拟环境的作用：
- 为每个项目创建独立的 Python 解释器和包目录
- 项目间依赖完全隔离，互不影响
- 便于复现和分发项目环境
```

### venv 的创建与激活

```bash
# 创建虚拟环境（在项目根目录执行）
python -m venv .venv          # 创建名为 .venv 的虚拟环境目录

# 激活虚拟环境
# Linux / macOS
source .venv/bin/activate

# Windows (CMD)
.venv\Scriptsctivate.bat

# Windows (PowerShell)
.venv\Scripts\Activate.ps1

# 激活后命令提示符会显示环境名称，例如：
# (.venv) $

# 验证当前使用的 Python
which python        # Linux/macOS
where python        # Windows
python --version

# 退出虚拟环境
deactivate
```

### requirements.txt

```bash
# 导出当前环境所有已安装的包及版本
pip freeze > requirements.txt

# requirements.txt 内容示例：
# requests==2.31.0
# numpy==1.26.0
# pandas==2.1.0

# 根据 requirements.txt 安装依赖（用于复现环境）
pip install -r requirements.txt

# 只导出直接依赖（不含间接依赖，更简洁）
pip install pip-tools
pip-compile pyproject.toml    # 从 pyproject.toml 生成精确的 requirements.txt
```

### pyproject.toml 简介

```toml
# pyproject.toml —— 现代 Python 项目的标准配置文件（PEP 517/518）

[build-system]
requires = ["hatchling"]          # 构建后端
build-backend = "hatchling.build"

[project]
name = "mypackage"
version = "1.0.0"
description = "A sample package"
requires-python = ">=3.11"

# 运行时依赖
dependencies = [
    "requests>=2.28",
    "pydantic>=2.0",
]

# 可选依赖（按功能分组）
[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "ruff",                       # 代码检查工具
]

# 工具配置也可以放在这里
[tool.pytest.ini_options]
testpaths = ["tests"]

[tool.ruff]
line-length = 88
```
## pip 与依赖管理

### pip 常用命令

```bash
# 安装包
pip install requests

# 安装指定版本
pip install requests==2.31.0

# 升级包
pip install --upgrade requests

# 卸载包
pip uninstall requests

# 查看已安装的包
pip list

# 查看某个包的详细信息（版本、依赖、安装位置）
pip show requests

# 检查依赖冲突
pip check
```

### 版本约束语法

```text
版本约束符号说明：

requests==2.31.0    精确匹配，只安装 2.31.0
requests>=2.28      大于等于 2.28，安装最新兼容版本
requests<=2.31      小于等于 2.31
requests!=2.30.0    排除 2.30.0 这个版本
requests~=2.28      兼容版本，等价于 >=2.28, <3.0（主版本不变）
requests>=2.28,<3   同时满足多个条件
```

### pip install 的常用选项

```bash
# 从本地目录安装（开发模式，修改代码立即生效，无需重新安装）
pip install -e .

# 从 requirements.txt 安装
pip install -r requirements.txt

# 只下载不安装（用于离线环境）
pip download requests -d ./packages

# 从本地目录安装（离线）
pip install --no-index --find-links=./packages requests

# 安装时不安装依赖
pip install --no-deps requests

# 强制重新安装
pip install --force-reinstall requests
```

### 镜像源配置

```bash
# 临时使用镜像源（单次安装）
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple

# 永久配置镜像源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple

# 常用国内镜像源：
# 清华大学：https://pypi.tuna.tsinghua.edu.cn/simple
# 阿里云：  https://mirrors.aliyun.com/pypi/simple
# 腾讯云：  https://mirrors.cloud.tencent.com/pypi/simple
```

```ini
# 也可以直接编辑配置文件 pip.ini（Windows）或 pip.conf（Linux/macOS）
# 文件位置：~/.pip/pip.conf 或 %APPDATA%\pip\pip.ini

[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn
```
## 常用第三方库概览

### 数据处理：numpy、pandas

```python
import numpy as np
import pandas as pd

# --- numpy：高性能多维数组与数学运算 ---

arr = np.array([1, 2, 3, 4, 5])          # 创建一维数组
matrix = np.zeros((3, 4))                 # 3x4 的全零矩阵
rand = np.random.rand(100)                # 100 个 [0,1) 的随机数

# 向量化运算，比 Python 列表快几十倍
result = arr * 2 + 1                      # [3, 5, 7, 9, 11]
dot = np.dot(arr, arr)                    # 点积：55

# --- pandas：表格数据处理 ---

# 从字典创建 DataFrame
df = pd.DataFrame({
    'name': ['Alice', 'Bob', 'Charlie'],
    'age': [25, 30, 35],
    'score': [88.5, 92.0, 78.3],
})

df[df['age'] > 25]                        # 筛选年龄大于 25 的行
df.groupby('age').mean()                  # 按年龄分组求均值
df.to_csv('output.csv', index=False)      # 导出为 CSV
df2 = pd.read_csv('data.csv')             # 读取 CSV
```

### Web 框架：Flask、FastAPI、Django

```python
# --- Flask：轻量级 Web 框架，适合小型应用和 API ---
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    return jsonify({'id': user_id, 'name': 'Alice'})

# --- FastAPI：现代异步框架，自动生成 OpenAPI 文档 ---
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    name: str
    age: int

@app.post('/users')
async def create_user(user: User):
    # 请求体自动验证和解析
    return {'message': f'Created user {user.name}'}

# 访问 http://localhost:8000/docs 查看自动生成的 Swagger 文档
```

```text
框架对比：

Flask    - 极简，灵活，适合小项目和学习
FastAPI  - 异步，类型安全，自动文档，适合现代 API 开发
Django   - 全栈，内置 ORM/Admin/Auth，适合大型 Web 应用
```

### 测试：pytest

```python
# test_math.py

# pytest 会自动发现以 test_ 开头的文件和函数
def add(a, b):
    return a + b

def test_add_integers():
    assert add(1, 2) == 3          # 基本断言

def test_add_floats():
    assert abs(add(0.1, 0.2) - 0.3) < 1e-9

def test_add_strings():
    assert add('hello', ' world') == 'hello world'

# 测试异常
import pytest

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

def test_divide_by_zero():
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(10, 0)
```

```bash
# 运行测试
pytest                        # 运行当前目录下所有测试
pytest tests/test_math.py     # 运行指定文件
pytest -v                     # 详细输出
pytest -k "test_add"          # 只运行名称包含 test_add 的测试
pytest --cov=mypackage        # 生成覆盖率报告（需安装 pytest-cov）
```

### 工具：requests、pydantic、loguru

```python
# --- requests：HTTP 请求库 ---
import requests

# GET 请求
resp = requests.get(
    'https://api.example.com/users',
    params={'page': 1, 'size': 10},   # 查询参数
    timeout=5,                         # 超时秒数，避免无限等待
)
resp.raise_for_status()               # 非 2xx 状态码时抛出异常
data = resp.json()                    # 解析 JSON 响应

# POST 请求
resp = requests.post(
    'https://api.example.com/users',
    json={'name': 'Alice', 'age': 25}, # 自动设置 Content-Type: application/json
    headers={'Authorization': 'Bearer <token>'},
)

# --- pydantic：数据验证与序列化 ---
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str = Field(min_length=1, max_length=50)
    age: int = Field(ge=0, le=150)    # ge=大于等于, le=小于等于

    class Config:
        str_strip_whitespace = True   # 自动去除字符串首尾空格

user = User(name='  Alice  ', age=25) # name 自动变为 'Alice'
print(user.model_dump())              # {'name': 'Alice', 'age': 25}

# 验证失败时抛出 ValidationError
try:
    User(name='', age=200)
except Exception as e:
    print(e)                          # 详细的字段错误信息

# --- loguru：简洁强大的日志库 ---
from loguru import logger

# 开箱即用，无需配置
logger.debug("调试信息")
logger.info("程序启动")
logger.warning("磁盘空间不足")
logger.error("连接失败")

# 输出到文件，自动按大小轮转
logger.add(
    "logs/app.log",
    rotation="10 MB",     # 超过 10MB 自动创建新文件
    retention="7 days",   # 保留最近 7 天的日志
    level="INFO",
)

# 结构化日志，自动包含文件名、行号、函数名
logger.info("用户登录 | user_id={user_id}", user_id=42)
```
