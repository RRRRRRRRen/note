# 函数与函数式编程

## 函数基础

### 函数定义与调用

```python
# 使用 def 关键字定义函数
def greet(name):
    print(f"Hello, {name}")

# 直接调用
greet("Alice")

# 函数也是对象，可以赋値给变量
say_hello = greet
say_hello("Bob")
```

### 返回値（单値、多値）

```python
# 单値返回
def square(x):
    return x ** 2

# 多値返回：Python 实际上返回一个 tuple
def min_max(lst):
    return min(lst), max(lst)

lo, hi = min_max([3, 1, 4, 1, 5, 9])  # 解包 tuple
print(lo, hi)  # 1 9

# 没有 return 语句时，函数返回 None
def nothing():
    pass

print(nothing())  # None
```

### 文档字符串 docstring

```python
def add(a, b):
    """
    计算两个数的和。

    Args:
        a: 第一个加数
        b: 第二个加数

    Returns:
        两数之和
    """
    return a + b

# 通过 __doc__ 属性或 help() 访问文档
print(add.__doc__)
help(add)
```
## 参数类型

### 位置参数、关键字参数

```python
def describe(name, age, city):
    print(f"{name}, {age}, from {city}")

# 位置参数：按顺序传入
describe("Alice", 30, "Beijing")

# 关键字参数：通过参数名传入，顺序可以不同
describe(age=30, city="Beijing", name="Alice")

# 混合使用：位置参数必须在关键字参数之前
describe("Alice", city="Beijing", age=30)
```

### 默认参数（陷阱：可变默认値）

```python
# 正常的默认参数
def greet(name, greeting="Hello"):
    print(f"{greeting}, {name}")

greet("Alice")           # Hello, Alice
greet("Bob", "Hi")       # Hi, Bob

# --- 陷阱：可变对象作为默认値 ---
# 默认値在函数定义时只创建一次，所有调用共享同一个对象
def bad_append(item, lst=[]):
    lst.append(item)
    return lst

print(bad_append(1))  # [1]
print(bad_append(2))  # [1, 2]  <- 预期是 [2]，但 lst 被复用了

# 正确做法：用 None 作为哨兵値
def good_append(item, lst=None):
    if lst is None:
        lst = []       # 每次调用都创建新列表
    lst.append(item)
    return lst

print(good_append(1))  # [1]
print(good_append(2))  # [2]  <- 符合预期
```

### *args 与 **kwargs

```python
# *args 收集多余的位置参数为 tuple
def sum_all(*args):
    return sum(args)

print(sum_all(1, 2, 3, 4))  # 10

# **kwargs 收集多余的关键字参数为 dict
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30)

# 同时使用
def mixed(a, b, *args, **kwargs):
    print(f"a={a}, b={b}")
    print(f"args={args}")
    print(f"kwargs={kwargs}")

mixed(1, 2, 3, 4, x=5, y=6)
# a=1, b=2, args=(3, 4), kwargs={"x": 5, "y": 6}

# 解包传参：用 * 解包列表，用 ** 解包字典
nums = [1, 2, 3]
info = {"name": "Alice", "age": 30}
print(sum_all(*nums))
print_info(**info)
```

### 仅关键字参数（keyword-only）

```python
# * 之后的参数只能通过关键字传入
def connect(host, port, *, timeout=30, retries=3):
    print(f"Connecting to {host}:{port}, timeout={timeout}, retries={retries}")

connect("localhost", 8080)                    # 使用默认値
connect("localhost", 8080, timeout=60)        # 关键字传入
# connect("localhost", 8080, 60)  # TypeError: 不能用位置参数传 timeout

# 仅位置参数（Python 3.8+）：/ 之前的参数只能按位置传入
def pos_only(x, y, /, z=0):
    return x + y + z

pos_only(1, 2)        # OK
# pos_only(x=1, y=2)  # TypeError
```

### 参数顺序规则

```python
# 完整的参数顺序：
# 位置参数 -> *args -> 仅关键字参数 -> **kwargs
def full_example(pos1, pos2, *args, kw_only1, kw_only2=10, **kwargs):
    pass

# 带 / 的完整顺序：
# 仅位置参数 / 普通参数 *args 仅关键字参数 **kwargs
def complete(p1, p2, /, normal, *args, kw_only, **kwargs):
    pass
```
## 作用域与闭包

### LEGB 规则

```python
x = "global"          # Global 作用域

def outer():
    x = "enclosing"   # Enclosing 作用域

    def inner():
        x = "local"   # Local 作用域
        print(x)      # 优先查找 Local -> Enclosing -> Global -> Built-in

    inner()           # 打印 "local"
    print(x)          # 打印 "enclosing"

outer()
print(x)              # 打印 "global"

# Built-in 作用域：Python 内置名称，如 len、print、range
print(len([1, 2, 3]))
```

### global 与 nonlocal

```python
count = 0

def increment():
    global count      # 声明使用全局变量，而非创建局部变量
    count += 1

increment()
print(count)  # 1

# nonlocal：修改外层（非全局）函数的变量
def make_counter():
    n = 0

    def counter():
        nonlocal n    # 声明修改 enclosing 作用域的 n
        n += 1
        return n

    return counter

c = make_counter()
print(c())  # 1
print(c())  # 2
print(c())  # 3
```

### 闭包的定义与应用

```python
# 闭包：内层函数引用了外层函数的变量，且外层函数已返回
def make_multiplier(factor):
    # factor 被内层函数捕获，形成闭包
    def multiply(x):
        return x * factor
    return multiply

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15

# 查看闭包捕获的变量
print(double.__closure__[0].cell_contents)  # 2

# 应用：工厂函数、延迟计算
def make_adder(n):
    return lambda x: x + n

add5 = make_adder(5)
print(add5(10))  # 15
```

### 闭包的常见陷阱

```python
# 陷阱：循环中的闭包捕获的是变量引用，而非値
funcs = []
for i in range(3):
    funcs.append(lambda: i)   # 所有 lambda 都引用同一个 i

print([f() for f in funcs])  # [2, 2, 2]  <- 预期 [0, 1, 2]

# 解决方案 1：用默认参数捕获当前値
funcs = []
for i in range(3):
    funcs.append(lambda i=i: i)  # 默认参数在定义时求値

print([f() for f in funcs])  # [0, 1, 2]

# 解决方案 2：用工厂函数
def make_func(i):
    return lambda: i

funcs = [make_func(i) for i in range(3)]
print([f() for f in funcs])  # [0, 1, 2]
```
## 装饰器

### 装饰器原理

```python
# 装饰器本质：接收函数，返回新函数的高阶函数
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Before call")
        result = func(*args, **kwargs)  # 调用原函数
        print("After call")
        return result
    return wrapper

# 语法糖 @my_decorator 等价于 greet = my_decorator(greet)
@my_decorator
def greet(name):
    print(f"Hello, {name}")

greet("Alice")
# Before call
# Hello, Alice
# After call
```

### 带参数的装饰器

```python
# 带参数的装饰器需要三层嵌套
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):       # 使用外层参数 times
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)                               # 先调用 repeat(3) 得到 decorator，再装饰
def say(msg):
    print(msg)

say("Hi")
# Hi
# Hi
# Hi
```

### functools.wraps

```python
import functools

def my_decorator(func):
    @functools.wraps(func)   # 保留原函数的 __name__、__doc__ 等元信息
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def add(a, b):
    """返回两数之和"""
    return a + b

# 没有 @wraps 时，add.__name__ 会是 "wrapper"
print(add.__name__)  # add
print(add.__doc__)   # 返回两数之和
```

### 类装饰器

```python
import functools

# 用类实现装饰器：需要实现 __call__
class CountCalls:
    def __init__(self, func):
        functools.update_wrapper(self, func)  # 等价于 @wraps
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Call #{self.count}")
        return self.func(*args, **kwargs)

@CountCalls
def hello():
    print("Hello!")

hello()  # Call #1 -> Hello!
hello()  # Call #2 -> Hello!
print(hello.count)  # 2
```

### 常用内置装饰器

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    # @property：将方法变为只读属性，通过 obj.area 访问而非 obj.area()
    @property
    def area(self):
        import math
        return math.pi * self._radius ** 2

    # @property + setter：实现可写属性，并可加入验证逻辑
    @property
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    # @staticmethod：不接收 self/cls，与类相关但不依赖实例或类状态
    @staticmethod
    def unit_circle():
        return Circle(1)

    # @classmethod：接收 cls，常用于工厂方法或操作类变量
    @classmethod
    def from_diameter(cls, diameter):
        return cls(diameter / 2)   # cls 指向当前类，支持继承

c = Circle(5)
print(c.area)                          # 78.53...
c.radius = 10
print(Circle.unit_circle().radius)     # 1
print(Circle.from_diameter(10).radius) # 5.0
```
## lambda 与高阶函数

### lambda 表达式

```python
# lambda 是匿名的单表达式函数
square = lambda x: x ** 2
print(square(4))  # 16

# 多参数
add = lambda x, y: x + y
print(add(3, 4))  # 7

# 常用于需要简短函数的场合，不适合复杂逻辑
# 等价的 def 写法更易读，复杂情况优先用 def
```

### map、filter、reduce

```python
from functools import reduce

nums = [1, 2, 3, 4, 5]

# map(func, iterable)：对每个元素应用函数，返回迭代器
squares = list(map(lambda x: x ** 2, nums))
print(squares)  # [1, 4, 9, 16, 25]

# filter(func, iterable)：保留使函数返回 True 的元素
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # [2, 4]

# reduce(func, iterable)：累积计算，将序列归约为单个値
total = reduce(lambda acc, x: acc + x, nums)
print(total)  # 15  (((1+2)+3)+4)+5

# 现代 Python 更推荐用列表推导式替代 map/filter
squares = [x ** 2 for x in nums]
evens = [x for x in nums if x % 2 == 0]
```

### sorted 的 key 参数

```python
words = ["banana", "apple", "cherry", "date"]

# key 接收一个函数，按函数返回値排序
sorted_by_len = sorted(words, key=len)
print(sorted_by_len)  # ["date", "apple", "banana", "cherry"]

# 按字母倒序
sorted_desc = sorted(words, key=lambda w: w, reverse=True)
print(sorted_desc)

# 对复杂对象排序
people = [("Alice", 30), ("Bob", 25), ("Charlie", 35)]
sorted_by_age = sorted(people, key=lambda p: p[1])
print(sorted_by_age)  # [("Bob", 25), ("Alice", 30), ("Charlie", 35)]

# 使用 operator 模块替代 lambda，性能更好
from operator import itemgetter
sorted_by_age = sorted(people, key=itemgetter(1))
```
## 生成器与迭代器

### 可迭代对象 vs 迭代器

```python
# 可迭代对象（Iterable）：实现了 __iter__ 方法，可以被 for 循环
# 迭代器（Iterator）：实现了 __iter__ 和 __next__ 方法

my_list = [1, 2, 3]          # 可迭代对象，但不是迭代器

# iter() 将可迭代对象转为迭代器
it = iter(my_list)
print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# next(it)       # StopIteration

# 手动实现迭代器
class CountUp:
    def __init__(self, limit):
        self.limit = limit
        self.current = 0

    def __iter__(self):
        return self              # 迭代器返回自身

    def __next__(self):
        if self.current >= self.limit:
            raise StopIteration  # 信号：迭代结束
        self.current += 1
        return self.current

for n in CountUp(3):
    print(n)  # 1, 2, 3
```

### yield 关键字

```python
# 含有 yield 的函数是生成器函数，调用后返回生成器对象
# 生成器是惰性求値的，每次 next() 才执行到下一个 yield
def count_up(limit):
    n = 1
    while n <= limit:
        yield n          # 暂停执行，返回 n，下次 next() 从这里继续
        n += 1

gen = count_up(3)
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3

# 生成器的优势：节省内存，不需要一次性生成所有数据
def infinite_counter(start=0):
    n = start
    while True:
        yield n
        n += 1

counter = infinite_counter()
print(next(counter))  # 0
print(next(counter))  # 1
```

### 生成器表达式

```python
# 语法类似列表推导式，但用 () 而非 []，返回生成器对象
gen = (x ** 2 for x in range(10))  # 不立即计算

# 惰性求値，按需生成
print(next(gen))  # 0
print(next(gen))  # 1

# 可以直接传入函数（省略外层括号）
total = sum(x ** 2 for x in range(10))
print(total)  # 285

# 对比：列表推导式立即生成所有元素，占用更多内存
lst = [x ** 2 for x in range(10)]   # 立即生成列表
gen = (x ** 2 for x in range(10))   # 惰性生成器
```
### yield from

```python
# yield from：委托给另一个可迭代对象，简化嵌套生成器
def chain(*iterables):
    for it in iterables:
        yield from it            # 等价于 for item in it: yield item

result = list(chain([1, 2], [3, 4], [5]))
print(result)  # [1, 2, 3, 4, 5]

# yield from 也可以用于递归生成器
def flatten(nested):
    for item in nested:
        if isinstance(item, list):
            yield from flatten(item)  # 递归展开嵌套列表
        else:
            yield item

print(list(flatten([1, [2, [3, 4]], 5])))  # [1, 2, 3, 4, 5]
```

### itertools 常用函数

```python
import itertools

# count(start, step)：无限计数
counter = itertools.count(10, 2)
print(list(itertools.islice(counter, 5)))  # [10, 12, 14, 16, 18]

# cycle(iterable)：无限循环
cycler = itertools.cycle("ABC")
print(list(itertools.islice(cycler, 7)))   # ["A", "B", "C", "A", "B", "C", "A"]

# chain(*iterables)：串联多个可迭代对象
chained = itertools.chain([1, 2], [3, 4], [5])
print(list(chained))  # [1, 2, 3, 4, 5]

# islice(iterable, stop) 或 islice(iterable, start, stop, step)：切片生成器
sliced = itertools.islice(range(100), 2, 10, 2)
print(list(sliced))  # [2, 4, 6, 8]

# product(*iterables)：笛卡尔积
pairs = itertools.product("AB", [1, 2])
print(list(pairs))  # [("A", 1), ("A", 2), ("B", 1), ("B", 2)]

# groupby(iterable, key)：按 key 分组（需先排序）
data = [("a", 1), ("a", 2), ("b", 3), ("b", 4)]
for key, group in itertools.groupby(data, key=lambda x: x[0]):
    print(key, list(group))
```
## functools 模块

### partial 偏函数

```python
from functools import partial

# partial：固定函数的部分参数，生成新函数
def power(base, exp):
    return base ** exp

square = partial(power, exp=2)    # 固定 exp=2
cube = partial(power, exp=3)      # 固定 exp=3

print(square(4))  # 16
print(cube(3))    # 27

# 固定位置参数
def log(level, message):
    print(f"[{level}] {message}")

info = partial(log, "INFO")       # 固定第一个位置参数
error = partial(log, "ERROR")

info("Server started")            # [INFO] Server started
error("Connection failed")        # [ERROR] Connection failed
```

### lru_cache 缓存

```python
from functools import lru_cache

# lru_cache：最近最少使用缓存，自动缓存函数调用结果
# maxsize=None 表示无限缓存（等价于 @cache，Python 3.9+）
@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)  # 重复调用会命中缓存

print(fibonacci(50))  # 12586269025，无缓存时递归会极慢

# 查看缓存统计
print(fibonacci.cache_info())
# CacheInfo(hits=48, misses=51, maxsize=128, currsize=51)

# 清除缓存
fibonacci.cache_clear()

# 注意：被缓存的函数参数必须是可哈希的（不能是列表、字典等）
```

### reduce

```python
from functools import reduce

# reduce(func, iterable[, initializer])：将序列归约为单个値
# func 接收两个参数：累积値和当前元素

nums = [1, 2, 3, 4, 5]

# 求和：((((1+2)+3)+4)+5) = 15
total = reduce(lambda acc, x: acc + x, nums)
print(total)  # 15

# 求积
product = reduce(lambda acc, x: acc * x, nums)
print(product)  # 120

# 带初始値：initializer 作为第一个累积値
total_with_init = reduce(lambda acc, x: acc + x, nums, 100)
print(total_with_init)  # 115

# 实际应用：展开嵌套列表
nested = [[1, 2], [3, 4], [5, 6]]
flat = reduce(lambda acc, x: acc + x, nested, [])
print(flat)  # [1, 2, 3, 4, 5, 6]
```