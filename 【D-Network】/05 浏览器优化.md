# 浏览器优化

## 浏览器安全

### XSS（跨站脚本攻击）

攻击者向网站注入恶意脚本，使其在用户浏览器中执行，从而盗取信息。本质是网站未对恶意代码过滤，导致其与正常代码混合执行。

危害：

- 获取页面数据（DOM、Cookie、LocalStorage）
- 发起 DOS 攻击
- 破坏页面结构
- 链接劫持

防御方式：

- 使用纯前端渲染，避免服务端拼接 HTML
- 对插入 HTML 的内容做充分转义
- DOM 型攻击：在数据获取、渲染和字符串拼接时过滤恶意代码
- 使用 CSP（内容安全策略）限制资源加载
- Cookie 设置 `HttpOnly` 属性，防止 JS 读取

### CSRF（跨站请求伪造）

攻击者诱导用户访问第三方网站，利用用户的登录状态向被攻击网站发送跨站请求。本质是利用 Cookie 在同源请求中自动携带的特性冒充用户身份。

防御方式：

- **同源检测**：服务器校验请求头中的 `Origin` 或 `Referer`
- **CSRF Token**：服务器下发随机 Token，请求时携带验证
- **双重 Cookie 验证**：服务器注入随机字符串到 Cookie，请求时需将其加入 URL 参数比对
- **SameSite Cookie**：
  - `Strict`：Cookie 在任何情况下都不作为第三方 Cookie
  - `Lax`：Cookie 仅在 GET 请求且发生页面跳转时可用

### iframe 滥用

第三方 iframe 内容默认不受控制，可能运行脚本、弹出对话框，破坏用户体验或造成安全隐患。

防御方式：

- 使用 `sandbox` 属性限制 iframe 行为
- 使用 CSP 限制 iframe 来源
- 通过 `X-Frame-Options` 响应头防止被嵌入

### 恶意第三方库

现代前端大量依赖第三方库，一旦被植入恶意代码易引发安全问题。

防御方式：

- 定期使用 `npm audit` 检测漏洞
- 使用 SRI（子资源完整性）验证 CDN 资源
- 锁定依赖版本，避免自动更新引入风险

### 中间人攻击（MITM）

攻击者在通信两端分别建立连接，替换公钥后可解密双方通信内容，双方无法察觉。

攻击过程：

1. 客户端发送请求，被中间人截获
2. 服务器发送公钥，中间人截获并替换为自己的公钥
3. 客户端用伪造公钥加密数据发送
4. 中间人用自己私钥解密，再用服务器公钥加密转发
5. 服务器正常解密，无法察觉

防御方式：使用 HTTPS、验证 SSL 证书、启用 HSTS 强制 HTTPS 连接

### 网络劫持

DNS 劫持：

- 修改运营商本地 DNS 记录，将流量引导到恶意服务器
- 防范：使用可信 DNS（如 8.8.8.8、1.1.1.1），使用 HTTPS

HTTP 劫持：

- HTTP 明文传输，运营商可修改响应内容注入广告或恶意代码
- 防范：使用 HTTPS 加密传输

---

## 浏览器渲染优化

### JavaScript 加载与执行

JS 的加载、解析与执行会阻塞 DOM 解析。HTML 解析器遇到 `<script>` 时暂停，等待 JS 执行完毕后继续。

优化方案：

- 将 `<script>` 放在 `<body>` 尾部
- `defer`：异步下载，在 `DOMContentLoaded` 前按顺序执行
- `async`：异步下载并立即执行，不保证顺序
- 动态加载：按需创建 script 标签

首屏渲染优先，不应在首屏加载过多 JS 文件。

### CSS 加载与阻塞

- CSS 不阻塞 DOM 解析，但阻塞 DOM 渲染
- CSS 阻塞 JS 执行（JS 可能需要获取样式信息）
- JS 阻塞 DOM 解析

执行顺序：下载并构建 CSSOM → 执行 JS → 继续 DOM 解析

### 文档预解析

Webkit 和 Firefox 均实现了预解析优化：执行 JS 时，另一个线程解析剩余文档并加载后续网络资源，实现资源并行加载。

特点：预解析不改变 DOM 树，只解析外部资源引用（脚本、样式表、图片等）。

---

## 浏览器缓存

### 缓存作用

浏览器将请求过的静态资源存储到本地，再次访问时直接从本地加载，减少网络请求，提升加载速度。

### 缓存刷新策略

| 操作 | 行为 |
| --- | --- |
| 地址栏回车 | 按正常流程检查缓存，根据缓存策略决定是否请求服务器 |
| F5 / 刷新按钮 | 标记本地缓存过期，携带 `If-Modified-Since` 和 `If-None-Match` 验证 |
| Ctrl+F5 强制刷新 | 不使用本地缓存，相当于首次请求，服务器返回 200 和完整资源 |

---

## 浏览器存储

### Cookie

- 由服务端设置，存储在客户端
- 每次同源 HTTP 请求自动携带
- 大小限制：单个 4KB，每域名约 20 个
- 生命周期由 `expires` 或 `max-age` 决定
- 缺点：容量小，增加请求流量，安全性较低（建议设置 `HttpOnly` 和 `Secure`）

### LocalStorage

- 容量约 5MB
- 持久存储，不会过期，除非主动清除
- 不随 HTTP 请求发送
- 同步操作，可能阻塞主线程

```js
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
localStorage.removeItem('key');
localStorage.clear();
```

### SessionStorage

- 容量约 5MB
- 会话级存储，窗口关闭后自动清除，刷新不清除
- 只能被同一窗口的同源页面访问

```js
sessionStorage.setItem('key', 'value');
const value = sessionStorage.getItem('key');
sessionStorage.removeItem('key');
sessionStorage.clear();
```

### 三者对比

| 特性 | Cookie | LocalStorage | SessionStorage |
| --- | --- | --- | --- |
| 容量 | 4KB | 5MB | 5MB |
| 生命周期 | 可设置过期时间 | 永久 | 窗口关闭即清除 |
| 随请求发送 | 是 | 否 | 否 |
| 作用域 | 同源 | 同源所有页面 | 同一窗口同源页面 |

---

## 同源策略与跨域

### 同源策略

协议、域名、端口三者必须完全一致才算同源。

限制内容：

- 无法读取非同源的 Cookie、LocalStorage、IndexedDB
- 无法访问非同源的 DOM
- 无法发送非同源的 AJAX 请求（可发送，但浏览器拦截响应）

以下标签允许跨域加载资源（但无法读取内容）：`<script>`、`<link>`、`<img>`、`<video>`、`<audio>`、`<iframe>`

### 跨域解决方案

**CORS（跨域资源共享）**

W3C 标准，由浏览器自动处理，关键在于服务器配置。

```js
// Node.js 示例
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
```

优点：支持所有 HTTP 请求类型，是跨域的正统解决方案。

**JSONP**

利用 `<script>` 标签不受同源策略限制的特性，服务器返回一个函数调用。

```js
// 前端
function handleResponse(data) {
  console.log(data);
}
const script = document.createElement('script');
script.src = 'http://example.com/api?callback=handleResponse';
document.body.appendChild(script);

// 服务器返回
// handleResponse({"name": "张三", "age": 20});
```

缺点：只支持 GET 请求，存在 XSS 风险，错误处理困难。

**postMessage**

HTML5 API，用于跨源通信，适合页面与新窗口、多窗口、iframe 之间的消息传递。

```js
// 发送
targetWindow.postMessage(data, targetOrigin);

// 接收
window.addEventListener('message', (event) => {
  if (event.origin !== 'http://example.com') return;
  console.log('接收到的数据：', event.data);
});
```

**代理服务器**

同源策略只限制浏览器，服务器间通信不受限制。前端请求同源代理服务器，由代理转发到目标服务器。

Nginx 反向代理配置示例：

```nginx
server {
  listen 80;
  server_name example.com;

  location /api {
    proxy_pass http://target-server.com;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

### 正向代理与反向代理

| 特性 | 正向代理 | 反向代理 |
| --- | --- | --- |
| 代理对象 | 代理客户端 | 代理服务器 |
| 隐藏对象 | 隐藏真实客户端 | 隐藏真实服务器 |
| 客户端配置 | 需要修改 | 不需要修改 |
| 常见应用 | VPN、翻墙 | 负载均衡、缓存加速 |

```text
正向代理：客户端 → 代理服务器 → 目标服务器
反向代理：客户端 → 反向代理服务器 → 服务器集群
```

---

## 浏览器通信

### 标签页间通信

| 方案 | 优点 | 缺点 |
| --- | --- | --- |
| WebSocket | 实时性强，双向通信 | 需要服务器支持 |
| SharedWorker | 不需要服务器，数据共享方便 | 兼容性较差，调试困难 |
| LocalStorage storage 事件 | 实现简单，兼容性好 | 只能传字符串，同标签页不触发 |
| postMessage | 适合父子窗口、iframe | 需要持有目标窗口引用 |

LocalStorage 跨标签页通信示例：

```js
// 标签页 A 发送
localStorage.setItem('message', JSON.stringify({ data: 'Hello', timestamp: Date.now() }));

// 标签页 B 接收
window.addEventListener('storage', (e) => {
  if (e.key === 'message') {
    console.log('收到消息：', JSON.parse(e.newValue));
  }
});
```

### WebSocket

HTML5 提供的全双工通信协议，基于单个 TCP 连接。

| 特性 | HTTP | WebSocket |
| --- | --- | --- |
| 连接方式 | 短连接 | 长连接 |
| 通信方向 | 单向（请求-响应） | 双向 |
| 状态 | 无状态 | 有状态 |
| 协议标识 | `http://` / `https://` | `ws://` / `wss://` |

```js
const ws = new WebSocket('ws://example.com');

ws.onopen = () => ws.send('Hello Server');
ws.onmessage = (event) => console.log('收到消息：', event.data);
ws.onclose = () => console.log('连接关闭');
ws.onerror = (error) => console.log('连接错误：', error);
```

适用场景：实时聊天、数据推送、在线游戏、协同编辑。

### 轮询机制

| 特性 | 短轮询 | 长轮询 |
| --- | --- | --- |
| 请求频率 | 固定间隔 | 收到响应后立即发起 |
| 服务器处理 | 立即响应 | 有数据才响应或超时 |
| 实时性 | 差（取决于间隔） | 好 |
| 资源消耗 | 高（大量无效请求） | 低 |

短轮询：

```js
setInterval(() => {
  fetch('/api/data').then(res => res.json()).then(data => {
    if (data) console.log('收到数据：', data);
  });
}, 5000);
```

长轮询：

```js
function longPolling() {
  fetch('/api/long-polling')
    .then(res => res.json())
    .then(data => {
      console.log('收到数据：', data);
      longPolling();
    })
    .catch(() => setTimeout(longPolling, 5000));
}
longPolling();
```

---

## ��览器进程与线程

### 进程与线程的区别

| 维度 | 进程 | 线程 |
| --- | --- | --- |
| 定义 | 资源分配的最小单位 | CPU 调度的最小单位 |
| 独立性 | 可独立运行 | 不能独立存在 |
| 资源 | 拥有独立资源空间 | 共享进程资源 |
| 通信 | 需要 IPC | 可直接共享数据 |
| 开销 | 创建和销毁开销大 | 开销小 |
| 崩溃影响 | 不影响其他进程 | 可能导致整个进程崩溃 |

### Chrome 多进程架构

| 进程 | 职责 |
| --- | --- |
| 浏览器进程 | 界面显示、用户交互、子进程管理 |
| 渲染进程 | 每个标签页一个，负责页面渲染、脚本执行、事件处理 |
| GPU 进程 | 3D 绘制和硬件加速 |
| 网络进程 | 网络资源加载 |
| 插件进程 | 每个插件一个 |

优点：标签页崩溃互不影响，安全性和稳定性更好，充分利用多核 CPU。缺点：内存占用较大。

---

## SEO 优化

### 网页结构

- 使用语义化标签：`<header>`、`<nav>`、`<main>`、`<article>`、`<section>`、`<aside>`、`<footer>`
- 使用 `<h1>`-`<h6>` 建立内容层级
- 网页层级不超过 3 层，保持扁平化 URL 结构

### TDK 优化

- `Title`：简洁明了，包含关键词，60 字符以内
- `Description`：准确描述页面内容，155 字符以内
- `Keywords`：选择相关性强的关键词，3-5 个为宜

### 性能优化

- 压缩 HTML、CSS、JS，优化图片（使用 WebP）
- 合并文件，减少 HTTP 请求，启用 HTTP/2
- 使用浏览器缓存、Gzip 压缩、CDN 加速
- 延迟加载非关键资源

### URL 优化

- 使用简短、描述性的 URL
- 用连字符（`-`）分隔单词
- 避免特殊字符和中文，使用小写字母

### 技术优化

- 提交 XML 格式的 sitemap
- 配置 `robots.txt` 指导爬虫抓取规则
- 使用 Schema.org 结构化数据
- 使用响应式设计，优化移动端体验
- 使用 HTTPS（搜索引擎优先索引 HTTPS 网站）
