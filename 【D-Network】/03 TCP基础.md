# TCP基础

## 三次握手

**第一次握手**

客户端向服务器发送请求报文段，包含自身的数据通讯初始序号，进入 `SYN-SENT` 状态。

**第二次握手**

服务器收到请求后，若同意连接，发送应答报文，包含自身初始序号，进入 `SYN-RECEIVED` 状态。

**第三次握手**

客户端收到应答后，向服务器发送确认报文，双方进入 `ESTABLISHED` 状态，连接建立成功。

### 为什么需要三次握手

- 确保双方的发送能力和接收能力均正常
- 防止失效的连接请求到达服务器：若某个早已超时的请求报文延迟到达，服务器误以为是新连接请求，两次握手会导致服务器单方面建立连接，浪费资源

---

## 四次挥手

**第一次挥手**

客户端认为数据发送完成，向服务器发送连接释放请求。

**第二次挥手**

服务器收到请求后，发送 ACK 包，进入 `CLOSE_WAIT` 状态。此时客户端到服务器方向的连接已释放，但服务器仍可向客户端发送数据。

**第三次挥手**

服务器将剩余数据发送完毕后，向客户端发送连接释放请求，进入 `LAST_ACK` 状态。

**第四次挥手**

客户端收到释放请求后，发送确认应答，进入 `TIME_WAIT` 状态，持续 2MSL。若期间未收到服务器重发请求，则进入 `CLOSED` 状态。服务器收到确认后直接进入 `CLOSED` 状态。

### 为什么需要四次挥手

建立连接时，服务器可以将 SYN 和 ACK 合并为一个报文发送。但关闭连接时，服务器收到 FIN 后可能还有数据未发完，只能先回复 ACK，等数据发送完毕后再单独发送 FIN，因此需要四次。

---

## TCP 粘包

### 原因

TCP 默认启用 Nagle 算法，会将短时间内的多个数据缓冲合并为一次发送，减少 IO 消耗。传输文件时无需处理，但传输多条独立消息时会导致粘包问题。

### 解决方案

- 多次发送之间间隔一个等待时间
- 关闭 Nagle 算法
- 进行封包拆包（在数据包中加入长度或分隔符）
