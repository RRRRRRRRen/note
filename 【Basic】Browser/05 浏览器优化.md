# 五、浏览器安全与优化

## 1.有哪些可以引起前端安全的问题

**跨站脚本（Cross-Site Scripting, XSS）**

一种代码注入的方式，为了与 CSS 区分所以被称为 XSS。早起常见于网络论坛，起因是网站没有对用户输入进行严格限制，使得攻击者可以将脚本上传到帖子然其他人浏览被注入恶意脚本的页面。其注入方式简单包括但不限于 JavaScript、CSS、Flash 等。

**iframe 滥用**

iframe 内容是由第三方提供的，默认情况下他们不受控制，他们会在 iframe 中运行 js 脚本、flash 插件、弹出对话框等，这可能或破坏前端用户体验。

**跨站点请求伪造（Cross-Site Request Forgeries, CSRF）**

指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或者设定信息等某些状态的更新，属于被动共计。

**恶意第三方库**

无论是后端还是前端开发，绝大多数都是在借助开发框架和各类库进行快速开发，一旦第三方库被植入恶意代码很容易应发安全问题。

## 2.网络劫持有哪几种，如何防范

**DNS 劫持**

- DNS 强制解析：通过修改运营商本地 DNS 记录，来引导用户流量到缓存服务器
- 302 跳转方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的，在对劫持的内存发起 302 跳转的回复，应到用户获取内容。

**HTTP 劫持**

- 由于 http 明文传输，运营商会修改你的 http 相应内容，然后加上广告等。

DNS 劫持已经被监管。HTTP 劫持使用 HTTPS 加密。

## 3.进程与线程

**概念**

从本质上说，进程和线程都是 CPU 工作时间片的一个描述。

- 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上说就代表一个程序。
- 线程是进程中更小的单位，描述了执行一段指令所需的时间。

**区别**

应用：进程可以看做独立应用，线程不能。

资源：进程是 cpu 资源分配的最小单位，是能拥有资源和独立运行的最小单位；线程是 cpu 调度的最小单位，线程是建立在进程基础上的一次程序运行单位，一个进程中可以有多个线程。

通信：线程可以通过直接共享同一进程中的资源，二进程通信需要借助进程中通信。

调度：进程切换比线程切换的开销要大。线程是 CPU 调度的基本单位，线程的切换不会引起进程切换，但是某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

开销：由于创建或者撤销进程时，系统都要为之分配或者回收资源，如内存、I/O 等，其开销远大于创建或销毁线程时的开销。

## 4.如何实现浏览器内多个标签页之间的通信

**websocket 协议**

websocket 协议可以实现服务器推送，所以服务器就可以当做中介者。标签页通过向服务器发送数据，然后有服务器向其他标签页推送转发。

**ShareWorker**

ShareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以当中介者。标签页间通过共享一个线程，然后通过这个共享线程来实现数据的交换。

**localStorage**

可以在一个标签页对 localStorage 的变化时间进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当了中介者的角色。

**postMessage**

如果我们能过获得对应标签的引用，就可以说使用 postMessage 方法进行通信。

## 5.为什么需要浏览器缓存

对于浏览器的缓存，主要针对的是前端的静态资源，再发起请求之后，拉取相应的金泰资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉去资源，并保存到本地。这样就大大减少了请求的次数，提高了网站性能。

所谓的浏览器缓存指的是浏览器将用户请求过的静态资源存储到电脑的本地磁盘中，当浏览器再次访问时，直接从本地加载，不需要再去服务器请求了。

## 6.点击刷新按钮或者按 F5、Ctrl+F5、地址栏回车有什么区别

**点击刷新按钮或者 F5**

浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味之服务器会对文件检查新鲜度，返回结果可能是 304，也可能是 200。

**Ctrl+F5**

浏览器不会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果时 200。

**地址栏回车**

浏览器按照正常流程，价差本地缓存，然后服务器校验新鲜度，最后返回内容。

## 7.浏览器渲染过程遇到 JS 文件如何处理

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若语法哦 Javascript，那么它会暂停文档的解析，将控制权交给 Javascript 引擎，等 JavaScript 引擎运行完毕，浏览器中再从终端的地方恢复继续解析文档。

也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放到 body 标签尾部的原因。当然在当下，可以给 script 添加`defer`或者`async`属性，来解决这个问题。

## 8.什么是文档的与解析

Webkit 和 Firefox 都做了这个优化，当执行 Javascript 脚本时，另一个线程解析剩下的脚本，斌家在后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，与解析并不改变 DOM 树，他将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本，样式表及图片。

## 9.CSS 如何阻塞文档解析

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript 脚本执行时可能在文档解析时请求样式表的信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这样会导致很多问题。

所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，然后再继续文档的解析。

## 10.浏览器的本低存储方式

**1.Cookie**

**简介**

Cookie 时最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否都是同一用户发起的，为解决这个问题，Cookie 就出现了，Cookie 的大小只有 4kb，他是一种纯文本文件，每次发起 HTTP 请求都会携带 Cookie。

就是最开始是服务端用于记录用户状态的一种方式，由服务端设置，在客户端存储，然后每次同源请求时，发送给服务端。cookie 最多存储 4k 数据，他生存时间由 expires 属性确定，并且 cookie 只能被同源的页面访问。

**特性**

- Cookie 一旦创建成功，名称就无法修改。
- Cookie 是无法跨域名的，也就是说 a 域名和 b 域名下的 cookie 是无法共享的，这也是有 Cookie'的隐私安全性决定的，这样能够阻止非法获取其他网站的 Cookie。
- 每个域名下的 Cookie 的数量不能超过 20 个，每个 Cookie 的大小不能超过 4kb
- 有安全问题，如果 Cookie 被拦截了，那就可以获取 session 的所有信息，即使加密也于事无补，无需知道 cookie 的意义，只需要转发 cookie 就能达到目的
- Cookie 再请求一个新的页面的时候都会被发送出去。

**2.LocalStorage**

**简介**

LocalStorage 是 HTML5 引入的新特性，由于有时候我们的信息储存较大，Cookie 就不能满足我们的需要，这时候就需要 LocalStorage。

**优点**

- 大小为 5MB，可以储存更多信息
- 是持久储存，斌不会随着页面的关闭而消失，除非主动清理。
- 仅仅存储在本地，不会随 HTTP 发送到服务器

**缺点**

- 兼容问题，IE8 以下版本不支持
- 浏览器设置为隐私模式无法读取 LocalStorage
- 有同源策略限制

**3.SessionStorage**

**简介**

SessionStorage 和 LocalStorage 都是在 HTML5 才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

它借鉴了服务端 session 的概念，代表的是一次会话中所保存的数据。他一般能存储 5M 或者更大的数据，他在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一窗口的同源页面所访问。

**SessionStorage 与 LocalStorage 对比**

- 都是本地数据存储
- 都具有同源策略，Session Storage 更加严格，要求同意浏览器的同意窗口下才能共享。
- 不能被爬虫读取

## 11.同源策略和跨域

**同源策略**

protocal（协议）、domain（域名）、port（端口）三者必须一致

**同源策略的限制**

- 当前域下的 js 脚本不能访问其他域下的 cookie、localStorage 和 indexDB
- 当前域下的 js 脚本不能访问操作其他域下的 DOM
- 当前域下的 ajax 无法发送跨域请求。

**同源策略的目的**

主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

**跨域的概念**

指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，时浏览器对 JavaScript 世家的安全限制，防止他人恶意攻击网站。

## 12.如何解决跨域问题

**CORS**

CORS 需要浏览器和服务器同时支持，整个 CORS 过程都是浏览器完成的，无需用户参与。因此实现 CORS 的关键就是服务器，只要服务器实现了 CORS 请求，就可以跨域通讯。

**JSONP**

jsonp 的原理是用`<script>`标签没有跨域限制，通过`<script>`标签 src 属性，发送带有 callback 参数的 get 请求，服务端通过将接口返回的数据平凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。

**possMessage**

postMessage 是 HTML5 中的 API，且是为数不多的可以跨域操作的 window 属性之一，它可以解决下面的问题：

- 页面和其他打开的新窗口的数据传递
- 多窗口之间的信息传递
- 页面与嵌套的 iframe 信息传递
- 上面三个场景的跨域数据传递

```js
postMessage(data, origin)
data: 传参，最好使用JSON.stringify()序列化
origin：协议+主机+端口号，也可以设置为“*”，表示可以传递给任意窗口，如果只当和当前窗口同源的话设置为“/”
```

**Node 中间件代理**

同源策略是浏览器需要遵循的标准，而如果是服务器向服务器发送请求则不需要遵循同源策略，代理服务器，需要做一下几个步骤：

- 接受客户端请求
- 将请求转发给服务器
- 拿到服务器响应数据

**nginx 反向代理**

实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。

通过 nginx 配置一个代理服务器，域名与 domain1 相同，端口不同做跳板机，反向代理 domain2 接口，斌且可以顺便修改 cookie 中的 domain 信息，方便当前域写入 cookie，实现跨域登录。

## 13.正向代理和反向代理

**正向代理**

客户端想获取一个服务端数据，但是因为种种原因无法获取。于是客户端设置了一个代理服务器，指向指定的目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器颖仓真是客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

**反向代理**

服务器为了能够将工作负载到多个服务器来提高完整性能等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实的服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。一般使用反向代理后，需要修改 DNS 让域名揭晓到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

## 14.XSS 和 CSRF

**XSS**

简介

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户浏览器上运行，从而盗取用户的信息 cookie 等。

XSS 攻击的本质是应为网站没有对恶意代码进行过滤，与正常代码混合在一起，浏览器没有办法分辨哪些脚本时可信的，从而导致恶意代码的执行。

危害

攻击者可以通过这种方式进行一下操作

- 获取页面数据，如 DOM、cookie、localStorage
- DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器。
- 破坏页面结构
- 留恋劫持，将连接指向其他网站

防御方式

可以从浏览器的执行来进行预防，一种是使用纯前端方法，不适用服务端拼接后返回（不适用服务端渲染）。另一种是对需要插入 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对恶意代码进行判断。

**CSRF**

简介

CSRF 指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后代的用户验证，冒充用户向服务器执行一些操作。

CSRF 的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来冒充用户。

防御方式

- 进行同源检测，服务器根据 http 请求头中的 origin 或者 referer 信息来判断亲求是否为允许访问的站点，从而对请求进行过滤。
- 使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token，当网站再次发起请求时，在请求参数中加入服务端返回的 token，然后服务器对这个 token 进行验证。
- 对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证
- 在设置 cookie 属性的时候设置 Samesite，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况都不能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求的时 get 请求，且会发生页面跳转的请求所使用。

## 15.中间人攻击

**简介**

中间人是指攻击者在通讯的两端分别建立的独立的联系，并交换其收到的数据，时通讯的两端认为他们赈灾通过一个私密的连接与对方直接对话，但事实上真个会话都被攻击者完全掌控。在中间人攻击下，攻击者可以拦截通讯双方的通话并插入新的内容。

**攻击过程**

- 客户端发送请求到服务端，被中间人截获
- 服务器向客户端发送公钥
- 中间人截获公钥，保留在自己手上。然后自己生成一个伪造公钥，发送给客户端
- 客户端收到伪造的公钥后，生成加密 hash 发送给服务器
- 中间人收到加密的 hash 后，用自己的私钥解密获得真密钥，同时生假的加密 hash 值，发送给服务器。
- 服务器用私钥解密获得的假密钥，然后加密数据发送给客户端

## 16.介绍 websocket

websocket 是一种网络通讯协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，这个是对比 HTTP 协议来说的，HTTP 协议是一种无状态、无连接、单向的应用层协议，通信请求只能由哭护短发起，服务端对请求做出应答处理。

HTTP 协议无法实现服务器主动向客户端发起消息，websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket 只需要建立一次连接，就可以一直保持连接状态。

## 17.什么是轮询

**轮询**

指的是每隔一段时间进行一次查询或者询问。轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。

**短轮询**

通过客户端定期轮询来询问服务端时候又新的信息产生，如果有则返回，没有就不响应，缺点：轮询间隔大，结果不实时；轮询间隔小，消耗的资源则多，怎加服务器负担。

**长轮询**

是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，则布里克返回，而是 Hold 一段时间等新的信息产生或者超时再返回，客户端收到服务器的应答后继续轮询。可以看出长轮询比端轮询可以减少大量的无用请求，并且客户端收取新信息也会实时不少。

## 18.如何做 SEO 优化

简介

SEO，即搜索引擎优化，SEO 时随着搜索引擎出现而来的，两者是相互促进，互利共生的关系。SEO 的存在就是为了提升网页在搜索引擎自然搜索结果中收录数量以及排序位置而作的优化。而优化的目的就是为了提升网站在搜索引擎中的权重，怎加对搜索引擎的友好度，使得用户访问网站时能排在前面。

方法

- 优化完整结构布局
- 控制首页连接数量
- 网页层级不要太深
- 控制页面大小，减少 HTTP 请求，提高网站加载速度
- 使用语义化标签
- 利用浏览器缓存
