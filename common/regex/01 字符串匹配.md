# 第一章 字符串匹配

> 正则表达式是匹配模式，要么匹配字符，要么匹配位置。这一章主要介绍匹配字符串。

## 1. 两种模糊匹配

> 正则表达式之所以强大，是因为其能实现模糊匹配。
> 而模糊匹配，有两个方向上的“模糊”：横向模糊和纵向模糊。

### 1.1 横向模糊匹配

> 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

例如使用量词实现横向模糊匹配。

```js
var regex = /ab{2,5}c/g;
var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
string.match(regex) // => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

该正则表示的匹配规则为：第一个字符是“a”，接下来是2到5个字符“b”，最后是字符“c”。

### 1.2 纵向模糊匹配

> 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

例如使用字符组实现纵向匹配。

```js
var regex = /a[123]b/g;
var string = "a0b a1b a2b a3b a4b";
string.match(regex)  // => ["a1b", "a2b", "a3b"]
```

该正则表示的匹配规则为：可以匹配如下三种字符串："a1b"、"a2b"、"a3b"。

## 2. 字符组

> 需要强调的是，虽叫字符组（字符类），但只是其中一个字符。例如`[abc]`，表示匹配一个字符，它可以是“a”、“b”、“c”之一。

### 2.1 范围表示法

如果匹配字字符可能性特别多，可以使用范围表示法。

比如`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`。用连字符`-`来省略和简写。

当需要匹配连字符`-`时，可以写成如下的方式：`[-az]`或`[az-]`或`[a\-z]`。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。

### 2.2 排除字符组

如果匹配的字符可以是任意字符，但是不能为某些字符时，可以使用排除的字符组写法。

例如`[^abc]`，表示是一个除"a"、"b"、"c"之外的任意一个字符。字符组的第一位放`^`（脱字符），表示求反的概念。

### 2.3 简写形式

| 字符  | 含义                           | 等价             | 说明                                                         |
| ----- | ------------------------------ | ---------------- | ------------------------------------------------------------ |
| `.`   | 通配符，联想省略号`...`中的`.` | `[^\n\r]`        | 匹配换行符之外的所有字符                                     |
| `\w`  | word                           | `[A-Za-z0-9_]`   | 匹配字母、数字、下划线                                       |
| `\W`  |                                | `[^A-Za-z0-9_]`  | 匹配非字母、数字、下划线                                     |
| `\d`  | digit                          | `[0-9]`          | 匹配所有数字                                                 |
| `\D`  |                                | `[^0-9]`         | 匹配所有非数字                                               |
| `\s`  | space character                | `[ \t\v\n\r\f]`  | 表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 |
| `\S`  |                                | `[^ \t\v\n\r\f]` |                                                              |
| `[^]` | 匹配任意字符                   |                  | 可以使用`[\d\D]`、`[\w\W]`、`[\s\S]`和`[^]`中任何的一个      |

| 字符 | 含义                   | 说明       |
| ---- | ---------------------- | ---------- |
| `\f` | form feed character    | 换页符     |
| `\n` | new line character     | 换行符     |
| `\r` | return character       | 回车符     |
| `\t` | tab character          | 制表符     |
| `\v` | vertical tab character | 垂直制表符 |

## 3. 量词

> 量词也称重复。掌握`{m,n}`的准确含义后，只需要记住一些简写形式。

### 3.1 简写形式

| 字符    | 记忆方式         | 等价    | 说明            |
| ------- | ---------------- | ------- | --------------- |
| `*`     | 通配符：任意次数 | `{0,}`  | 出现0次或者多次 |
| `+`     | 表示追加         | `{1,}`  | 出现1次或者多次 |
| `?`     | 询问有还是没有   | `{1,0}` | 出现0次或者1次  |
| `{n}`   |                  |         | 出现n次         |
| `{n,}`  |                  |         | 至少出现n次     |
| `{n,m}` |                  |         | 出现n到m次      |

### 3.2 贪婪匹配

> 贪婪匹配是量词匹配的默认模式

如下贪婪匹配案例：

```js
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
string.match(regex) // => ["123", "1234", "12345", "12345"]
```

贪婪匹配会在符合条件的字符中尽可能多的匹配字符串，例如`123456`中，`12` `123` `1234` `12345`都满足上述正则，直到`123456`才不满足条件，所以当匹配尽可能多的字符时，会匹配到`12345`

### 3.3 惰性模式

> 与贪婪模式相对的为惰性模式，会尽可能少的匹配符合条件的字符。

```js
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
string.match(regex) // => ["12", "12", "34", "12", "34", "12", "34", "56"]
```

在量词表示法后加`?`表示惰性匹配。

上述正则在遇到`12345`时，使用惰性匹配，会识别`12`满足条件，则不会查询更多字符。在全局模式`g`下，会继续查询其他满足规则的字符，在遇到`34`时又匹配成功，匹配`5`时失败。

## 4 分支多选

> 支持在多个子模式中任选其一。
> 具体形式为：`(p1|p2|p3)`，其中`p1`、`p2`和`p3`是子模式，用`|`（管道符）分隔，表示其中任何之一。

例如要匹配"good"和"nice"。

```js
var regex = /good|nice/g;
var string = "good idea, nice try.";
string.match(regex) // => ["good", "nice"]
```

匹配"good"和"goodbey"。

```js
var regex = /good|goodbey/g;
var string = "goodbye";
string.match(regex) // => ["good"]

var regex = /goodbey|good/g;
var string = "goodbye";
string.match(regex) // => ["goodbye"]
```

上述案例表示，分支多选时按照声明顺序进行匹配，当匹配成功时，则结束匹配不忘后查询。


