# 数据类型

## 数值类型

### 1. 整数类型

| **类型**      | **占用空间** | **范围（有符号）** | **范围（无符号）** |
| ------------- | ------------ | ------------------ | ------------------ |
| TINYINT       | 1 字节       | -128 ~ 127         | 0 ~ 255            |
| SMALLINT      | 2 字节       | -32,768 ~ 32,767   | 0 ~ 65,535         |
| MEDIUMINT     | 3 字节       | -8 百万 ~ 8 百万   | 0 ~ 1670 万        |
| INT / INTEGER | 4 字节       | -21 亿 ~ 21 亿     | 0 ~ 42 亿          |
| BIGINT        | 8 字节       | 非常大             | 更大               |

### 2. 浮点型 & 定点型

| **类型**     | **说明**                               |
| ------------ | -------------------------------------- |
| FLOAT        | 单精度浮点数（4 字节）                 |
| DOUBLE       | 双精度浮点数（8 字节）                 |
| DECIMAL(m,d) | 定点数，**用于存储精确小数**（如金额） |

**注意**

- 金额类数据 **必须用 DECIMAL**，不要用 FLOAT/DOUBLE，因为后者有精度误差
- DECIMAL 的范围由 m 和 d 决定，占用空间为 m+2
- DECIMAL 不指定 m 和 d 时，默认为(10,0)

## 字符串类型

| **类型**   | **说明**                                  |
| ---------- | ----------------------------------------- |
| CHAR(n)    | 定长字符串，最多 255 字符                 |
| VARCHAR(n) | 变长字符串，最多 65535 字节（受编码限制） |
| TEXT       | 长文本，最多 64KB                         |
| TINYTEXT   | 最多 255 字节                             |
| MEDIUMTEXT | 最多 16MB                                 |
| LONGTEXT   | 最多 4GB                                  |

### 1. CHAR VARCHAR

| **类型** | **全称**        | **说明**                 |
| -------- | --------------- | ------------------------ |
| CHAR     | Fixed-length    | **定长**字符串，长度固定 |
| VARCHAR  | Variable-length | **变长**字符串，长度可变 |

**语法格式**

```sql
-- CHAR(n)：固定 n 个字符
name CHAR(10);

-- VARCHAR(n)：最多 n 个字符
nickname VARCHAR(50);
```

> 注意：这里的 “字符” 不是字节，和字符集有关（比如 utf8 一个汉字是 3 个字节）。

**对比**

| **比较项**   | CHAR(n)                                    | VARCHAR(n)                          |
| ------------ | ------------------------------------------ | ----------------------------------- |
| 是否定长     | ✅ 是                                      | ❌ 否，变长                         |
| 空间占用     | 固定分配 n 个字符的空间                    | 实际内容长度 + 1~2 字节的长度信息   |
| 存储性能     | ✅ 更快（定长结构，容易缓存）              | ❌ 稍慢（每行长度不一致，处理复杂） |
| 末尾空格处理 | 会自动填充并保留                           | 不保留末尾空格（自动截断）          |
| 适用场景     | 长度基本一致的短字符串，如国家代码、性别等 | 可变长度的字符串，如用户名、邮箱等  |
| 最大长度     | 最多 255 个字符                            | 最多 65535 字节（受行最大限制影响） |

**示例**

```sql
CREATE TABLE country (
  code CHAR(2),          -- 如 'CN', 'US'
  name VARCHAR(100)
);
```

- CHAR(2) 永远占两个字符，不管是 'US' 还是 'U'，后者会补空格 'U '。

```sql
CREATE TABLE user (
  id INT,
  nickname VARCHAR(20)  -- 实际长度随内容变
);
```

- 插入 'Tom'：占 3 个字符 + 1 个长度字节

- 插入 'AlexanderTheGreat'：占 19 字符 + 1 个长度字节

**末尾空格处理**

```sql
-- CHAR 会保留末尾空格
SELECT LENGTH(CHAR_FIELD) FROM table;

-- VARCHAR 会自动截掉末尾空格
SELECT LENGTH(VARCHAR_FIELD) FROM table;
```

**使用场景**

| **场景**                               | **推荐类型** |
| -------------------------------------- | ------------ |
| 性别、国别码、身份证位数固定的字段     | CHAR         |
| 用户名、邮箱、地址等长度不定字段       | VARCHAR      |
| 性能更重要（数据量很大且字段长度一致） | CHAR         |
| 节省空间更重要                         | VARCHAR      |

### 2. TEXT 类

| **类型名称** | **最大长度**               | **存储空间**   | **用途示例**                                 |
| ------------ | -------------------------- | -------------- | -------------------------------------------- |
| TINYTEXT     | 255 字符（255 字节）       | 1 字节长度信息 | 短文本，类似评论、标签、标题等               |
| TEXT         | 65,535 字符（64 KB）       | 2 字节长度信息 | 一般的文章内容、评论等                       |
| MEDIUMTEXT   | 16,777,215 字符（16 MB）   | 3 字节长度信息 | 中等长度的文本，例如日志、文章等             |
| LONGTEXT     | 4,294,967,295 字符（4 GB） | 4 字节长度信息 | 用于存储非常长的文本，例如小说、数据库备份等 |

**语法示例**

```sql
CREATE TABLE articles (
  id INT PRIMARY KEY AUTO_INCREMENT,
  title VARCHAR(255),
  content TEXT
);

-- 插入文本内容
INSERT INTO articles (title, content) VALUES
('My First Article', 'This is the content of my first article. It is quite long...');
```

**注意事项**

- **不能使用 TEXT 字段作为 PRIMARY KEY 或 UNIQUE KEY**：

  - 由于 TEXT 类型存储较大，因此它不能用作索引字段，除非你指定索引的前缀长度（比如 VARCHAR(255)）。但需要注意的是，即使 TEXT 字段可以部分索引，它的索引性能可能会很差。

- **性能问题**：

  - TEXT 类型字段由于存储在外部，查询时需要额外的 I/O 操作，因此在查询长文本时可能会导致性能问题，尤其是在没有索引的情况下。

- **不适用于存储短文本**：

  - 如果字段内容较短，建议使用 VARCHAR，因为它会更高效，不会浪费存储空间。

- **没有默认长度限制**：

  - TEXT 类型的字段不像 VARCHAR 一样有字符数限制（最大为 65535 字节），它可以存储非常大的文本内容。

- **与 BLOB 的比较**：
  - TEXT 和 BLOB 都是变长字段，区别在于 TEXT 存储字符数据（通常使用字符集编码），而 BLOB 存储二进制数据。它们的存储方式和容量限制相似，但用途不同。

## 日期和时间类型

> MySQL 中的日期和时间类型，是做数据开发时非常常用的一类字段，特别是在记录创建时间、更新时间、业务时间线（比如订单时间、签到时间等）时。

| **类型**  | **示例**              | **描述**                      | **精度支持（MySQL 5.6.4+）** |
| --------- | --------------------- | ----------------------------- | ---------------------------- |
| DATE      | '2025-03-20'          | 只包含日期，格式：YYYY-MM-DD  | ❌ 无小数秒                  |
| TIME      | '12:34:56'            | 只包含时间，格式：hh:mm:ss    | ✅ 支持毫秒~微秒             |
| DATETIME  | '2025-03-20 12:34:56' | 日期 + 时间，常用于业务记录   | ✅ 支持毫秒~微秒             |
| TIMESTAMP | '2025-03-20 12:34:56' | 类似 DATETIME，但和时区强相关 | ✅ 支持毫秒~微秒             |
| YEAR      | 2025                  | 只存年份（1901–2155）         | ❌ 无小数秒                  |

### 1. YEAR

**YEAR 类型基本特性**

- 用于存储年份，例如 2025

- 格式为：**YEAR(4)**（默认写作 YEAR）

- 实际存储的是 **4 位整数**，但属于日期类型
- 0000 也可以被存储，但必须是明确指定（比如做占位符时），不是默认行为。

**存储范围**

| **最小值** | **最大值** |
| ---------- | ---------- |
| 1901       | 2155       |

**语法**

```sql
INSERT INTO t (graduation_year) VALUES (2025);
INSERT INTO t (graduation_year) VALUES ('2025');
INSERT INTO t (graduation_year) VALUES ('25'); -- 自动补成 2025
```

MySQL 会根据你插入的值自动转化：

| **插入值** | **实际存储为** |
| ---------- | -------------- |
| '70'       | 1970           |
| '99'       | 1999           |
| '00'       | 2000           |
| '69'       | 2069           |

**重点：**

- 插入两位数字时，MySQL 会使用 “切换点规则”：
  - 00–69 → 2000–2069
  - 70–99 → 1970–1999
- **尽量避免插入两位年份，容易造成歧义**

### 2. DATE

**基本特性**

| **特性**       | **说明**                                   |
| -------------- | ------------------------------------------ |
| 类型名         | DATE                                       |
| 格式           | 'YYYY-MM-DD'                               |
| 占用空间       | 3 字节                                     |
| 范围           | **1000-01-01 ~ 9999-12-31**                |
| 是否有时间部分 | ❌ 没有（只有年月日）                      |
| 是否支持默认值 | ✅ 可以设置默认值，如 DEFAULT CURRENT_DATE |

**插入语法**

```sql
INSERT INTO holidays (name, holiday_date) VALUES ('元旦', '2025-01-01');
```

**查询语法**

```sql
-- 查询所有今天的记录
SELECT * FROM events WHERE event_date = CURRENT_DATE;

-- 查询某个月的数据（比如 2025年3月）
SELECT * FROM events
WHERE event_date BETWEEN '2025-03-01' AND '2025-03-31';
```

**常用函数**

| **函数**       | **作用**                      |
| -------------- | ----------------------------- |
| CURRENT_DATE() | 当前日期（和 CURDATE() 一样） |
| DATE(NOW())    | 从 DATETIME 中提取出日期部分  |
| DATE_ADD()     | 日期加天数/月份等             |
| DATE_SUB()     | 日期减天数/月份等             |
| DATEDIFF()     | 计算两个日期相差多少天        |
| YEAR(date)     | 提取年份                      |
| MONTH(date)    | 提取月份                      |
| DAY(date)      | 提取日                        |

```sql
-- 计算距离今天还有几天
SELECT DATEDIFF('2025-12-25', CURRENT_DATE) AS days_left;

-- 提取年月日
SELECT YEAR(birthday), MONTH(birthday), DAY(birthday) FROM users;
```

**注意事项**

| **注意点**      | **说明**                                                                   |
| --------------- | -------------------------------------------------------------------------- |
| ❗ 插入非法日期 | MySQL 默认会报错，如 '2025-02-30' 会报错或变成 '0000-00-00'（看 SQL 模式） |
| ❗ 空值问题     | NULL 和 '0000-00-00' 是不同的（是否允许取决于你的 SQL 模式）               |
| ❗ 时区无关     | DATE 类型和系统时区无关，不会因时区偏移而改变                              |
| ✅ 可以索引     | DATE 是常见的索引字段（比如订单日期、注册日期）                            |

### 3. TIME

**基本特性**

| **特性**       | **说明**                       |
| -------------- | ------------------------------ |
| 类型名         | TIME                           |
| 格式           | 'hh:mm:ss'                     |
| 范围           | -838:59:59 到 838:59:59        |
| 占用空间       | 3~5 字节（取决于是否有小数秒） |
| 是否有日期     | ❌ 没有，纯时间                |
| 是否受时区影响 | ❌ 不受时区影响                |

**时间范围 & 精度**

- 最大支持：**838 小时 59 分 59 秒**（不是 24 小时！）

- 可选精度（MySQL 5.6.4+ 起支持小数秒）：

```sql
TIME(0)  -- 默认，精度到秒
TIME(3)  -- 精确到毫秒
TIME(6)  -- 精确到微秒
```

```sql
'12:34:56.789'  -- TIME(3)
'99:59:59.123456' -- TIME(6)
```

**插入与显示**

```sql
INSERT INTO schedule (start_time) VALUES ('08:30:00');
```

MySQL 接受多种格式：

| **插入值** | **实际存储**     |
| ---------- | ---------------- |
| '10:20'    | '10:20:00'       |
| '3:5:9'    | '03:05:09'       |
| -12:00:00  | 负时间段（合法） |
| '90:00:00' | 支持超过 24 小时 |

**常用函数**

| **函数**       | **描述**                 |
| -------------- | ------------------------ |
| CURTIME()      | 返回当前时间（不带日期） |
| SEC_TO_TIME(n) | 将秒数转为时间格式       |
| TIME_TO_SEC(t) | 将时间格式转为秒数       |
| ADDTIME()      | 时间相加                 |
| SUBTIME()      | 时间相减                 |
| HOUR(t)        | 提取小时                 |
| MINUTE(t)      | 提取分钟                 |
| SECOND(t)      | 提取秒                   |

```sql
-- 获取当前时间
SELECT CURTIME();  -- 例如 '16:45:22'

-- 将 3661 秒转为时间
SELECT SEC_TO_TIME(3661);  -- '01:01:01'

-- 计算两个时间差
SELECT SUBTIME('08:30:00', '07:15:00');  -- '01:15:00'
```

### 4. DATETIME

> DATETIME 是 MySQL 中最通用的时间类型，用来准确记录“一个具体时间点”，**不受时区影响、支持微秒精度**，是你设计数据库时间字段的首选！

**基本特性**

| **特性**                 | **内容**                                              |
| ------------------------ | ----------------------------------------------------- |
| 类型名                   | DATETIME                                              |
| 格式                     | 'YYYY-MM-DD HH:MM:SS'                                 |
| 范围                     | '1000-01-01 00:00:00' ~ '9999-12-31 23:59:59'         |
| 占用空间                 | 8 字节（无小数秒） / 9~13 字节（带小数秒）            |
| 精度支持（MySQL 5.6.4+） | 可选精度：DATETIME(fsp)，fsp 可为 0~6，表示小数秒位数 |
| 是否与时区有关           | ❌ 不受时区影响（不同于 TIMESTAMP）                   |

**常用场景**

| **场景**                   | **是否推荐用** DATETIME |
| -------------------------- | ----------------------- |
| 用户注册时间、更新时间     | ✅ 推荐                 |
| 博客发布时间               | ✅ 推荐                 |
| 订单生成时间               | ✅ 推荐                 |
| 记录某年某月某日几点的事情 | ✅ 推荐                 |
| 表示时间段（不含日期）     | ❌ 不推荐，用 TIME      |

**插入与查询**

```sql
-- 插入 DATETIME 字面量
INSERT INTO logs (log_time) VALUES ('2025-03-20 14:45:00');

-- 获取当前时间（不带时区影响）
INSERT INTO logs (log_time) VALUES (NOW());
```

**常用函数**

| **函数**               | **含义**                               |
| ---------------------- | -------------------------------------- |
| NOW()                  | 当前日期时间（同 CURRENT_TIMESTAMP()） |
| DATE(NOW())            | 提取日期部分                           |
| TIME(NOW())            | 提取时间部分                           |
| YEAR(), MONTH(), DAY() | 提取年月日                             |
| DATE_FORMAT()          | 自定义格式输出                         |

```sql
-- 查询今天的记录
SELECT * FROM logs WHERE DATE(log_time) = CURDATE();

-- 查询 2024 年 12 月的记录
SELECT * FROM logs
WHERE log_time BETWEEN '2024-12-01 00:00:00' AND '2024-12-31 23:59:59';
```

**小数秒精度**

支持精确到微秒：

```sql
CREATE TABLE t (
  created_at DATETIME(3)  -- 精确到毫秒，例如 2025-03-20 14:45:30.123
);
```

可选精度范围是 DATETIME(0) 到 DATETIME(6)，对应秒、小数秒、毫秒、微秒级别。

**设计建议**

```sql
-- 可以自动记录插入和更新时间，常见于“记录最后修改时间”场景。
CREATE TABLE orders (
  id INT PRIMARY KEY,
  customer_id INT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**注意事项**

| **注意点**                   | **说明**                                         |
| ---------------------------- | ------------------------------------------------ |
| 插入非法格式会报错           | 比如 '2025-02-30 00:00:00' 是非法的              |
| 不支持 'YYYY-MM-DD' 直接插入 | 少了时间部分会默认补成 '00:00:00'                |
| 不支持时区自动换算           | 与 TIMESTAMP 不同                                |
| 可以加索引/做范围查询        | 日期区间查询效率很好                             |
| 不推荐存文本时间             | 用字符串如 '2025-03-20 14:00' 会失去时间函数支持 |

### 5. TIMESTAMP

> TIMESTAMP 是一种紧凑、高效、支持自动更新时间戳的时间类型，**适合记录服务器时间点、日志、审计信息，受时区影响、最大支持到 2038 年**，相比 DATETIME 更偏系统层面用途。

**基本特性**

| **特性**       | **内容**                                                         |
| -------------- | ---------------------------------------------------------------- |
| 类型名         | TIMESTAMP                                                        |
| 格式           | 'YYYY-MM-DD HH:MM:SS'                                            |
| 时间范围       | '1970-01-01 00:00:01' ~ '2038-01-19 03:14:07'（Unix 时间戳限制） |
| 占用空间       | 4 字节（无小数秒） / 5~9 字节（有小数秒）                        |
| 是否受时区影响 | ✅ **受时区影响（存 UTC，显示按本地转换）**                      |
| 默认值         | ✅ 支持 CURRENT_TIMESTAMP                                        |

**举例**

```sql
CREATE TABLE logs (
  id INT PRIMARY KEY,
  message VARCHAR(100),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

- 插入数据时记录当前时间

- 每次更新行时自动更新 updated_at

**小数秒支持**

和 DATETIME 一样，可以加小数秒精度（最多 6 位）：

```sql
CREATE TABLE t (
  ts TIMESTAMP(3)  -- 精确到毫秒
);
```

插入：

```sql
INSERT INTO t VALUES ('2025-03-20 14:22:33.789');
```

**与时区有关**

- TIMESTAMP 实际存储的是 **UTC 时间**

- 查询时会根据 MySQL 的 time_zone 设置自动转换成本地时间

```sql
SET time_zone = '+00:00';
SELECT CURRENT_TIMESTAMP;  -- 比北京时间少 8 小时

SET time_zone = '+08:00';
SELECT CURRENT_TIMESTAMP;  -- 显示北京时间
```

**注意事项**

| **⚠️ 注意点**                         | **说明**                                                                               |
| ------------------------------------- | -------------------------------------------------------------------------------------- |
| 1️⃣ 超过 2038 年会出错                 | 因为底层是 32 位 Unix 时间戳                                                           |
| 2️⃣ 时区切换会影响显示值               | 比如迁移数据或修改时区配置前要小心                                                     |
| 3️⃣ 默认只能有一个自动更新的字段       | 一个表中只能有一个字段设置 ON UPDATE CURRENT_TIMESTAMP（除非 MySQL 5.6.5+ 并显式声明） |
| 4️⃣ 如果默认值未设置，插入 NULL 会报错 | 除非声明为 NULL 类型                                                                   |

### 6. DATETIME vs TIMESTAMP

| **对比点**   | DATETIME                           | TIMESTAMP                         |
| ------------ | ---------------------------------- | --------------------------------- |
| 存储方式     | 存储**本地时间**，格式化后存储     | 存储**UTC 时间戳（Unix time）**   |
| 时区影响     | ✅ 不受时区影响                    | ❌ 和当前系统时区有关             |
| 存储范围     | 1000-01-01 ~ 9999-12-31            | 1970-01-01 ~ 2038-01-19           |
| 默认值支持   | ❌ 不支持 CURRENT_TIMESTAMP 默认值 | ✅ 支持 DEFAULT CURRENT_TIMESTAMP |
| 占用空间     | 8 字节                             | 4 字节（或更多，取决于精度）      |
| 推荐使用场景 | 普通业务逻辑时间（创建时间等）     | 系统日志、事件时间戳（含时区）    |

**开发建议**

- 一般建议使用 DATETIME，避免时区干扰。

- 如果做系统日志同步，涉及多个服务器，适合用 TIMESTAMP。

**✅ 四、布尔类型（Boolean）**

MySQL 没有真正的 BOOLEAN 类型，它是 TINYINT(1) 的别名。

```
CREATE TABLE example (
  is_active BOOLEAN -- 实际就是 TINYINT(1)
);
```

 • TRUE = 1，FALSE = 0

## 枚举与集合

### 1. ENUM 类型

> ENUM 是一个**枚举类型**，用于存储从一组预定义的值中选择一个值。它本质上是一个字符串类型，但是它的值是从定义时指定的值集合中选出的。

**语法**

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  gender ENUM('Male', 'Female', 'Other') NOT NULL
);
```

在这个例子中，gender 字段只能是 'Male'、'Female' 或 'Other' 中的一个。

**特性**

| **特性** | **内容**                                                          |
| -------- | ----------------------------------------------------------------- |
| 允许的值 | 从定义的值集合中选择一个值                                        |
| 存储方式 | 以整数形式存储，使用 1 字节、2 字节、3 字节等空间，取决于值的个数 |
| 默认值   | 可以指定默认值，也可以为空（NULL）                                |
| 空间占用 | 根据定义的可选项数量占用不同字节空间                              |
| 比较操作 | 比较时，ENUM 值会按定义的顺序转换为整数进行比较                   |
| 适用场景 | 用于表示有限的选择，如性别、状态、等级等                          |

**优点：**

- **存储效率**：由于 ENUM 值是按整数存储的，因此它比 VARCHAR 更节省空间，尤其是在有多个选项时。

- **数据验证**：只能选择定义的几个值，有效避免无效数据的插入。

**缺点：**

- **灵活性差**：如果需要更改 ENUM 类型的值集合（例如，添加或删除选项），需要修改表结构。

- **扩展性差**：随着选择项的增加，ENUM 字段可能变得不那么方便，尤其在值的集合变化较多的情况下。

### 2. SET 类型

> SET 类型用于存储从一组预定义的值中选择**零个或多个**值。和 ENUM 不同的是，SET 可以包含多个值，允许组合多个选项，而不是单一选项。

**语法**

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  hobbies SET('Reading', 'Swimming', 'Traveling', 'Gaming') NOT NULL
);
```

在这个例子中，hobbies 字段可以包含多个选项，比如 'Reading, Traveling' 或 'Swimming, Gaming'。

**特性**

| **特性** | **内容**                                                        |
| -------- | --------------------------------------------------------------- |
| 允许的值 | 从定义的值集合中选择零个或多个值                                |
| 存储方式 | 每个 SET 值以整数位图（bitmap）存储，这使得它比 ENUM 更节省空间 |
| 默认值   | 可以指定默认值，也可以为空（NULL）                              |
| 空间占用 | 存储多个值时，存储效率较高，适用于存储多个组合数据              |
| 比较操作 | 采用位图方式，操作多个选项时，效率较高                          |
| 适用场景 | 用于表示多个选项的组合，如兴趣爱好、权限控制等                  |

**优点：**

- **存储多个值**：可以同时存储多个选项，而不需要创建多个字段或表。

- **灵活性**：非常适合存储可以组合的选项，例如用户的多个爱好或权限。

**缺点：**

- **查询和操作复杂**：与 ENUM 相比，SET 类型的查询和操作更加复杂，尤其是涉及到多选项的查询时。

- **空间浪费**：如果选择的选项很多，但实际选择的值较少，可能会浪费存储空间。

- **无法轻松修改**：如果要增加或删除选项，也需要修改表结构。

### 3. ENUM 和 SET 对比

| **特性**         | ENUM                                   | SET                                         |
| ---------------- | -------------------------------------- | ------------------------------------------- |
| 存储方式         | 用整数存储选项（一个整数代表一个选项） | 用位图存储选项（每个选项占一位）            |
| 值的选择         | 每个字段只能选一个值                   | 每个字段可以选多个值                        |
| 适用场景         | 适合表示互斥的选项（例如性别、状态）   | 适合表示可组合的选项（例如兴趣爱好、权限）  |
| 查询和操作复杂度 | 较简单，只能查询单一选项               | 较复杂，通常需要使用 FIND_IN_SET() 或位操作 |
| 最大选择项数     | 最多 65,535 个选项（实际使用时较少）   | 最多 64 个选项                              |
| 空间占用         | 占用 1~3 字节，取决于选项数量          | 占用较小的空间，取决于选项数量和选中的组合  |
| 修改字段         | 需要修改表结构才能修改选项集           | 修改选项集时需要修改表结构                  |

**适用场景**

| **场景**                       | **推荐使用** |
| ------------------------------ | ------------ |
| **性别、状态等单一选择项**     | ENUM         |
| **多个权限、兴趣爱好等多选项** | SET          |
| **固定的、有序的选择项**       | ENUM         |
| **需要组合多个选项的场景**     | SET          |

**示例**

```sql
-- ENUM 示例：性别字段
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100),
  gender ENUM('Male', 'Female', 'Other') NOT NULL
);
-- 在这个例子中，gender 字段只能存储 'Male'、'Female' 或 'Other'，适合用于性别字段。
```

```sql
-- SET 示例：兴趣爱好字段
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100),
  hobbies SET('Reading', 'Swimming', 'Traveling', 'Gaming') NOT NULL
);
-- 在这个例子中，hobbies 字段可以存储多个选项，比如 'Reading, Traveling' 或 'Swimming, Gaming'，适合存储用户的多重兴趣爱好。
```

**总结**

- **ENUM**：适合表示互斥的、有限选择项（如性别、状态、等级等），每个字段只能选择一个值。

- **SET**：适合表示可以选择多个选项的场景（如兴趣爱好、权限等），每个字段可以选择一个或多个值。

## JSON 类型

> 在 MySQL 中，JSON 类型用于存储结构化的**JSON 数据**（JavaScript Object Notation）。JSON 是一种轻量级的数据交换格式，广泛应用于现代的Web开发和API接口中。MySQL 从 5.7 版本开始原生支持 JSON 类型，提供了对 JSON 数据的存储和操作功能。

### 一、JSON 类型



> JSON 类型用于存储结构化的 JSON 数据，MySQL 会自动对存储的 JSON 数据进行验证，确保数据符合 JSON 格式，并提供了 JSON 操作函数，可以对 JSON 数据进行查询、修改等操作。

**定义方式**

```sql
CREATE TABLE example (
  id INT PRIMARY KEY,
  data JSON -- 用于存储 JSON 数据
);
```

**特性**

| **特性** | **内容**                                         |
| -------- | ------------------------------------------------ |
| 存储方式 | 存储原生的 JSON 格式数据                         |
| 存储格式 | 存储为优化过的二进制格式（比纯文本 JSON 更高效） |
| 自动验证 | 自动验证插入的数据是否为合法的 JSON 格式         |
| 查询能力 | 支持对 JSON 数据进行查询、更新、操作等           |
| 索引支持 | 支持对 JSON 数据进行索引，提升查询性能           |
| 空值处理 | 支持存储 NULL 或空 JSON 对象（{}）               |

**存储格式**

MySQL 使用一种优化过的二进制格式来存储 JSON 数据。虽然我们在插入时使用 JSON 字符串形式（如 {"name": "John", "age": 30}），但是 MySQL 会将其转为内部的二进制格式来进行存储。这种方式比纯文本存储 JSON 数据更高效，特别是对于大规模的数据。

### 二、JSON 数据类型的操作

**插入数据**

插入 JSON 数据时，可以将有效的 JSON 字符串插入到表中：

```sql
INSERT INTO example (id, data)
VALUES (1, '{"name": "Alice", "age": 25, "is_member": true}');
```

**查询 JSON 数据**

使用 -> 运算符从 JSON 数据中提取字段：

```sql
SELECT data->'$.name' AS name
FROM example
WHERE id = 1;
```

该查询返回 data 字段中的 name 键对应的值。

**更新 JSON 数据**

更新 JSON 数据时，可以通过 MySQL 提供的 JSON_SET() 函数来修改指定的 JSON 键值对。

```sql
UPDATE example
SET data = JSON_SET(data, '$.age', 26)
WHERE id = 1;
```

这个查询将 id 为 1 的记录中 data 字段的 age 键的值更新为 26。

**使用 JSON 数组**

可以存储和操作 JSON 数组。例如，以下插入 JSON 数组：

```sql
INSERT INTO example (id, data)
VALUES (2, '{"tags": ["web", "development", "mysql"]}');
```

查询时可以提取数组中的值：

```sql
SELECT data->'$.tags[0]' AS first_tag
FROM example
WHERE id = 2;
```

**查询 JSON 对象或数组的长度**



可以使用 JSON_LENGTH() 函数查询 JSON 数组的长度或 JSON 对象中键的数量：

```sql
SELECT JSON_LENGTH(data->'$.tags') AS tags_count
FROM example
WHERE id = 2;
```

**JSON 查询运算符**

- ->：从 JSON 数据中提取一个值（返回 JSON 格式）

- ->>：从 JSON 数据中提取一个值并转换为文本

- JSON_EXTRACT()：提取 JSON 中的指定路径

- JSON_UNQUOTE()：提取值并去除引号

### 三、JSON 数据的索引

> MySQL 支持对 JSON 数据进行索引。由于 JSON 数据可能包含多个键值对，因此常常需要在某些特定字段上建立索引，以优化查询性能。

**1. 使用 Generated Columns 创建索引**

MySQL 支持通过**生成列**（generated columns）来索引 JSON 数据中的字段。生成列是 MySQL 5.7 版本开始引入的功能，它允许基于其他列的值自动计算出一列。

```
CREATE TABLE example (
  id INT PRIMARY KEY,
  data JSON,
  name VARCHAR(255) GENERATED ALWAYS AS (data->>'$.name') STORED
);
```

上述例子中，name 列是根据 data 列中的 JSON 数据自动生成的。STORED 表示生成列的数据会被存储到磁盘上，因此可以被索引。

**2. 创建索引**

在生成列基础上创建索引：

```
CREATE INDEX idx_name ON example(name);
```

这样可以提高基于 JSON 数据字段的查询效率。

### 四、使用场景

**优势**

- **灵活性高**：JSON 数据结构是动态的，可以轻松存储不同格式的数据，而不需要像传统数据库一样严格定义表结构。

- **复杂数据存储**：适用于存储复杂的数据结构，例如嵌套的对象或数组。

- **查询方便**：MySQL 提供了丰富的 JSON 操作函数，支持对 JSON 数据的灵活查询和修改。

- **节省空间**：在某些情况下，JSON 数据比传统的关系型数据库结构更节省空间，尤其是对于不规则或动态变化的数据。

**使用场景**

- **存储配置数据**：当需要存储大量不规则的配置项，且每个配置项的结构可能不同，JSON 可以非常适合。

- **API 数据交换**：很多 Web API 返回的数据是 JSON 格式，MySQL 直接存储 JSON 数据能有效减少转换的开销。

- **日志存储**：存储日志信息时，JSON 可以灵活存储不同类型的日志数据，如时间戳、用户信息、操作细节等。

- **动态属性**：用于存储具有动态属性的对象，例如存储用户自定义的额外属性。

## 位类型（BIT）

BIT 是一种**位类型（bit type）**，用来存储 **二进制位（0 和 1）**，非常适合表示开关、权限、状态等信息。

```sql
CREATE TABLE users (
  id INT,
  permissions BIT(8)
);
```

- 用于存储位图，比如权限、开关等

- 操作复杂，一般不推荐新手使用

## 二进制类型

| **类型**   | **特点**                      | **适用场景**                                 |
| ---------- | ----------------------------- | -------------------------------------------- |
| BINARY     | 固定长度，存储二进制数据      | 适合存储长度固定的二进制数据（如加密数据）   |
| VARBINARY  | 可变长度，存储二进制数据      | 适合存储长度不固定的二进制数据（如图片文件） |
| BLOB       | 存储大二进制数据，最大 4 GB   | 用于存储大文件数据（如图像、音频、视频等）   |
| TINYBLOB   | 存储最大 255 字节的二进制数据 | 用于存储小型二进制数据（如小图标等）         |
| MEDIUMBLOB | 存储最大 16 MB 的二进制数据   | 用于存储中等大小的二进制数据                 |
| LONGBLOB   | 存储最大 4 GB 的二进制数据    | 用于存储非常大的二进制数据                   |

